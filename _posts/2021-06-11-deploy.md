---
title: Что такое деплой?
# subtitle: Front-End фреймворк для быстрой и простой веб-разработки.
description: Доставка кода на продакшен сервера. Миграция базы данных. Zero Downtime Deployment. Ansible, Kubernetes
# image: "assets/images/bootstrap/bootstrap.jpeg"
author: Кирилл Мокевнин
---

Деплой – процесс "разворачивания" веб-сервиса, например, сайта, в рабочем окружении. Рабочее окружение – место где сайт запускается и доступен для запросов. Это может быть как готовый хостинг, так и своя собственная серверная инфраструктура.

*Деплоятся не только веб-сервисы, но любые сервисы доступные по сети, даже если эта сеть внутренняя и не доступна для запросов через интернет.*

Для понимания деплоя, необходимо разобраться с жизненным циклом кода. Код приложения разрабатывается на рабочей машине разработчика, а запускается в другом месте, называемом продакшеном. Продакшен это среда запуска (иногда говорят боевая среда). Она может состоять из одного сервера, в случае простого приложения, а может состоять из тысяч и десятков тысяч в случае, по настоящему, сложных приложений.

Как это происходит. Разработчики добавляют код в репозиторий, затем, в какой-то момент решают, что пора доставить его до продакшена. Это может происходить как по регулярному расписанию, например раз в две недели, так и просто по необходимости, вплоть до выкатки после каждого изменения. Во многом количество деплоев зависит от уровня его автоматизации, того, насколько процесс легкий в проведении и отката в случае проблем. На Хекслете деплои выполняются практически после каждого изменения, около 3 деплоев в день.

{% include banner.html name="intensive-devops" %}

Каждый раз когда разработчики решили что все, пора, они создают релиз. Под релизом, обычно, понимают тег в git, который фиксирует то, что уйдет в деплой. То есть изменения добавленные в мастер после создания тега не повлияют на сам тег, а значит мы точно уверены в том, что деплоим.

<!-- image -->

Для статических сайтов или отдельного фронтенда (только html, css и статические файлы) деплой сводится к обновлению кода на сервере. В ситуации деплоя бекенда, как минимум, подключается база данных. В общем случае деплой может быть сложной процедурой, занимающей приличное время. В распределенных системах, состоящих из множества независимых веб-сервисов вообще не бывает общего деплоя, каждая часть приложения деплоится (выкатывается) независимо.

*Стоит сказать что PaaS платформы, такие как Heroku, берут деплой полностью на себя. Там достаточно выполнить коммит и дальше все произойдет само. Цена за это – стоимость самой платформы*

## Шаги деплоя

### Доставка кода на сервер

В зависимости от способа упаковки кода возможны разные варианты доставки. Иногда код просто копируют на сервер как набор файлов, но такое встречается редко, чаще он обновляется через git. Раньше был популярен способ деплоя через стандартные пакетные менеджеры Linux дистрибутивов. Сейчас он тоже встречается и для определенных ситуаций подходит лучше всего.

* Git: *git checkout tag-name*
* Docker: *docker pull image-name:tag-name*
* Apt (Пакет): *apt-install application-package-name*

### Обновление базы данных

Новая версия приложения может и, как правило, требует изменений в базе данных. Для этого во время (или до) деплоя запускают миграции, специальные скрипты, содержащие правила обновления базы данных. Например sql скрипты:

```sql
CREATE TABLE car (
    id INT NOT NULL PRIMARY KEY,
    license_plate VARCHAR NOT NULL,
    color VARCHAR NOT NULL
);

ALTER TABLE owner ADD driver_license_id VARCHAR;
```

### Запуск и остановка

Где-то в этом процессе происходит остановка старой версии и запуск новой. Если сначала остановить старую версию, а потом выполнить миграции и запустить новую, то мы получим простой (downtime) в работе сервиса. Так действительно работают многие, но это может быть болезненно для бизнеса и частых деплоев. Поэтому самые продвинутые проекты не останавливаются во время деплоя. О том как это делать ниже.

## Автоматизация

Деплой нужно максимально автоматизировать, от этого зависит Time To Market, ключевая характеристика бизнес-ориентированных приложений. Чем быстрее и чаще мы доставляем изменения пользователю, тем лучше. Быстрее проверяем гипотезы, быстрее вносим исправления, быстрее оправдываем деньги вложенные в разработку. Без автоматизации разработчики боятся выполнять деплой, он становится обузой, что приводит к снижению числа деплоев и регулярному стрессу для всей команды, с засиживанием на работе до позднего вечера.

Основных способа автоматизации три:

1. С помощью утилит, созданных для конкретных языков. Например в Ruby это Capistrano, одна из первых и наиболее известных утилит подобного рода, ставшая популярной далеко за пределами Ruby. Основная проблема с такими инструментами – сильная завязка на язык
1. С помощью Ansible, в который уже [встроен модуль для деплоя](https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html). Идеально подходит для большинства ситуаций деплоя на управляемые сервера
1. Системы оркестрации типа Kubernetes. Если они используются, то без автоматического деплоя никак

Но даже если автоматизация выполнена, все равно остается задача "запустить деплой". Запуск тоже автоматизируется. Существует целый подход, который называется [Непрерывная доставка](https://ru.wikipedia.org/wiki/Непрерывная_доставка)(continuous delivery). Его сложно внедрить и он не везде подходит, но если получилось, то про деплой забывают. Он выполняется полностью сам без участия людей. Главное, в таком варианте, хороший мониторинг и система оповещения (алертинг) для реакции на ошибки.

```yaml
# https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html#examples
- name: Initialize the deploy root and gather facts
  community.general.deploy_helper:
    path: /path/to/root
- name: Clone the project to the new release folder
  ansible.builtin.git:
    repo: ansible.builtin.git://foosball.example.org/path/to/repo.git
    dest: '{{ deploy_helper.new_release_path }}'
    version: v1.1.1
- name: Add an unfinished file, to allow cleanup on successful finalize
  ansible.builtin.file:
    path: '{{ deploy_helper.new_release_path }}/{{ deploy_helper.unfinished_filename }}'
    state: touch
```

## Zero Downtime Deployment

Если не предпринимать специальных шагов, то каждый деплой будет приводить к остановке (возможно частичной) сервиса. В это время пользователи либо увидят ошибку, либо сообщение о происходящем обновлении. Но такого не происходит на большинстве крупных сервисов в интернете. Почему? Из-за реализации подхода "деплой без даунтайма" (downtime – простои в работе сервиса).

Zero Downtime Deployment выглядит так, как будто сервис никогда не останавливается, но при этом обновляется. Достигается это за счет одновременного запуска старой версии и новой кода. То есть когда деплоится приложение, то сначала поднимается новая версия рядом со старой и только когда автоматика убеждается, что новая версия запустилась и работает, происходит остановка старой версии. Для выполнения этой процедуры понадобится следующее:

1. Инфраструктура. Нужен балансировщик, который может, переключать трафик (входящие соединения от браузеров или других систем) между старой и новой версией кода. И желательно иметь как минимум два сервера, хотя это и не обязательно
1. Деплой. Процесс деплоя без простоя значительно сложнее чем с остановкой. Проще всего такой деплой делается на системах оркестрации, например, Kubernetes
1. Культура кода. Обеспечить безостановочную работу невозможно без определенной культуры написания кода. Чтобы старая и новая версия могли работать одновременно, нужно следить за всеми интерфейсами. Важно соблюдение обратной совместимости (работа с api, базой, очередьми и, в целом, любыми хранилищами)
1. База данных. Она должна быть обратна совместима между старой и новой версией. Все миграции только вперед (их нельзя откатывать!) и только на добавление. Нельзя удалять и обновлять (переименовывать, менять тип) колонки и таблицы

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: tomcat-deployment-${TARGET_ROLE}
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: tomcat
        role: ${TARGET_ROLE}
    spec:
      containers:
      - name: tomcat-container
        image: tomcat:${TOMCAT_VERSION}
        ports:
        - containerPort: 8080
        readinessProbe:
          httpGet:
            path: /
            port: 8080
```

## Дополнительная литература

* [Инжиниринг в Booking](https://bronevichok.ru/posts/engineering-at-booking.com.html)
* [Стратегии деплоя](https://habr.com/ru/company/flant/blog/471620/)
* [Stateless vs Statefull](https://www.youtube.com/watch?v=WPCz_U7D8PI)
* [Ansistrano (Ansible + Capistrano)](https://github.com/ansistrano/deploy)
* [Среды разработки](https://ru.hexlet.io/blog/posts/environment)
