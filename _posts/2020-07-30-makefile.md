---
layout: post
title: Что такое Makefile и как начать его использовать
subtitle: Гайд по основам make и Makefile для использования в собственных проектах
summary: Разворачивание и запуск проекта требует ввода команд с разнообразными флагами, которые трудно запомнить и набирать вручную, приходится документировать, но документация устаревает. Этот гайд раскрывает как утилита make позволяет справиться с искусственной сложностью и унифицировать команды независимо от технологий.
cover_url: "/images/makefile/cover.jpg"
---

## Введение

В жизни многих разработчиков найдётся история про первый рабочий день с новым проектом. Большинство из них про завышенные ожидания, когда приходишь в проект, полный новых технологий и удивительных решений, а получаешь инструкцию такого типа: 

```text
Чтобы развернуть проект нужно всего лишь:
Установить глобально docker, postresql 10, redis 4
// TODO: спросить у Вовы какие утилиты ещё нужны

bin/codebattle start
docker-compose up -d db-local
docker run -it -v $PWD:/app -w /app williamyeh/ansible:ubuntu18.04 ansible-playbook ansible/terraform.yml -i ansible/production -vv --vault-password-file=tmp/ansible-vault-password
ansible-playbook ansible/development.yml -i ansible/development -vv
mix ecto.reset && mix run priv/repo/seeds.exs
bin/codebattle eval "Codebattle.Utils.Release.migrate"
mix coveralls.json --exclude code_check --max-failures 1 // возможно, это надо делать в самом начале

Если что-то не получилось - разбирайся.
```

Часть таких команд прячут в shell-скрипты, потому что они слишком длинные, содержат много флагов, их трудно не только запомнить, но и вводить вручную. Ведение документации проекта зачастую заканчивается вместе с уходом единственного человека, который её вёл. Документация быстро устаревает и порог входа в проект для новичков становится выше, потому что уже никто не во состоянии вспомнить всех деталей.

Этот гайд призван показать, как средствами *Makefile* и утилиты `make` устранить искусственную сложность, получить всегда актуальную документацию проекта, а процесс разворачивания свести к простым коротким командам такого вида:

```text
make setup-db
make setup-app
make run
make test
```

## Что такое `make` и *Makefile*

Говоря простым языком:

* *Makefile* — это файл, содержащий команды и их имена. Он хранится вместе с кодом в репозитории.
* `make` — это утилита для запуска команд из Makefile. Она поставляется в операционной системе или устанавливается отдельно. 

Изначально `make` предназначался для автоматизации сборки исполняемых программ и библиотек из исходного кода. Утилита включена в большинство *nix дистрибутивов, что привело к его широкому распространению и повсеместному использованию. 

*Makefile* выступает и как документация, и как исполняемый код. Он скрывает за собой детали реализации внешне и раскладывает "по полочкам" команды внутри себя. При внешней простоте, он является довольно мощным инструментом.

### Синтаксис *Makefile*

Задачи в *Makefile* описываются как ключи и значения:

```makefile
# Makefile
install-dependencies: # имя задачи, поддерживается kebab-case и snake_case
	package-manager install # задача, используется отступ табуляцией

run: # имя задачи описывает семантику вместо реализации, сокращая команду и скрывая флаги
	docker run -it --rm -v $HOME:/usr/src/app node:14 /bin/bash -c "'src/bin/hexlet.ts' 10"

# можно указывать зависимость между задачами
setup: install-dependencies
	ansible-playbook ansible/development.yml -i ansible/development -vv # и комбинировать с другими задачами
# такая зависимость выполнит "ansible-playbook..." только в случае успешного завершения "package-manager install"
```

Как видно из примера, мейкфайл позволяет вне зависимости от языков и инструментов описать назначение команд, что делает проект самодокументируемым. Описывая зависимость между задачами становится возможным одной командой запустить цепочку, которая прервётся только при наличии ошибки. Такой подход убирает необходимость помнить команды разработчикам, вести документацию вручную и поддерживать её в актуальном состоянии.

#### Фальшивая цель

Имена задач называются "целями" и в мейкфайле есть понятие "phony target", что можно перевести как "фальшивая цель". Как уже говорилось ранее, изначально `make` предназначался для сборок из исходного кода. Поэтому, если добавить в мейкфайл цель, имя которой совпадает с именем файла / каталога, то задача не выполнится.

```makefile
# Makefile
test:
	mix coveralls.json --exclude code_check --max-failures 1
```

```sh
# Bash
$ ls
test

make test
make: `test` is up to date.
```

Так происходит потому что `make` собрать программу из исходников указанной цели, и ею является каталог *test*. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить `.PHONY` указатель на цель:

```makefile
# Makefile last line
.PHONY: test
```

```sh
# Bash
$ make test
✓ All tests passed!
```

### Использование `make`

Чтобы выполнить задачи из конкретного мейкфайла, достаточно запустить утилиту `make` в том каталоге, где он находится. Запуск команд можно производить по одной (`make setup`, `make test`, ...) или указывать цепочкой через пробел. Так будет выглядеть установка и запуск приложения через `make`:

```sh
# Bash
$ make setup test run
package-manager install  # make setup вызвал make install-dependencies
mix coveralls.json --exclude code_check --max-failures 1  # make test
✓ PASS # результат выполнения тестов
docker run -it --rm -v $HOME:/usr/src/app node:14 /bin/bash -c "'src/bin/hexlet' 10" # make run
5 # результат выполнения кода
```

### Переменные

Зачастую команды используют параметры для конфигурации, указания путей, переменные окружения и `make` тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:

```makefile
# Makefile
say:
	echo "Hello, $(HELLO)!"
```

```sh
# Bash
$ make say HELLO=World
echo "Hello, World!"
Hello, World!

$ make say HELLO=Kitty
echo "Hello, Kitty!"
Hello, Kitty!
```

Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.

```makefile
# Makefile
HELLO?=World # знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.

say:
	echo "Hello, $(HELLO)!"
```

```sh
# Bash
$ make say
echo "Hello, World!"
Hello, World!

$ make say HELLO=Kitty
echo "Hello, Kitty!"
Hello, Kitty!
```

Некоторые переменные в Makefile имеют названия отличные от системных. Например, `$PWD` называется `$CURDIR` в мейкфайле:
```makefile
# Makefile
terraform-vars-generate:
	docker run -it -v $(CURDIR):/app -w /app williamyeh/ansible:ubuntu18.04 ansible-playbook ansible/terraform.yml -i ansible/production -vv --vault-password-file=tmp/ansible-vault-password
``` 

Уже этой функциональности достаточно для большинства типовых задач. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов.

## Заключение

В настоящее время у многих языков и технологии имеется собственный менеджер задач. Но их ключевое отличие от мейкфайла - это конкретная цель, которой они служат. Было бы неправильно включать в конфигурацию языка команды для запуска bash-скриптов, а конфигурацию CI для скачивания дампа базы данных. Именно благодаря тому, что *Makefile* не связан с конкретными технологиями и языками, он выступает как универсальный "клей" между ними. 

Повсеместное использование мейкфайла позволит выявить повторяющиеся и типовые задачи. Особенно это актуально там, где множество проектов, например, при заказной разработке. Всё что понадобится знать разработчику в проектах, использующих мейкфайл - это несколько команд: `make setup start`, `make test deploy`.

### Дополнительные материалы:

* [Руководство по современному Make](https://ru.makefile.site/) — "выжимка" из документации на русском языке;
* [Утилита make: полезный универсальный инструмент программиста](https://www.youtube.com/watch?v=pK9mF5aK05Q) — видео-версия данного гайда.

Пример использования мейкфайла в крупных проектах:

* [Codebattle](https://github.com/hexlet-codebattle/codebattle/blob/master/Makefile);
* [Babel](https://github.com/babel/babel/blob/main/Makefile);
* [Kubernetes](https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile);
