---
layout: post
title: Что такое Makefile
subtitle: Полезный универсальный инструмент программиста
summary: Современный программный продукт, как правило, состоит не из одной технологии, а включает несколько языков, использует дополнительные инструменты, что приводит к появлению объёмной документации, описывающей команды каждой утилиты в проекте. В этом гайде вы узнаете как утилита make позволяет справиться с этой сложностью и унифицировать команды, независимо от технологии.
cover_url: "Путь к файлу-обложке для соц. сетей, например, /images/encoding/Unicode-Logo.jpg"
---

## Введение

Современные программы, как правило, состоят больше, чем из одной технологии, но и одна технология может включать в себя множество команд для выполнения каких-то ежедневных операций. Например, так выглядят команды для [приложения на TypeScript](https://github.com/hexlet-boilerplates/ts-package):

```shell script
npm ci              # установка зависимостей
npm test -s         # запуск тестов
npx eslint src/**/* # запуск линтера
npm publish         # публикация пакета
npm run build       # сборка пакета в .js-файлы  
npx ts-node 'src/bin/hexlet.ts' 10                      # запуск .ts-файла
node -n --experimental-vm-modules './dist/bin/hexlet.js' 10 # запуск .js-файла
``` 

И это только "верхушка айсберга", если это приложение будет собираться в [Docker](https://guides.hexlet.io/docker/), то команды будут продублированы с приставкой `docker run <множество ключей>` и появятся ещё новые команды. 

Чем больше и сложнее проект, тем больше в нём используется команд, утилит и технологий, что приводит к таким явлениям:

* один или несколько разработчиков, обладающие тайными знаниями команд проекта;
* разработчики используют разные команды для решения одной задачи, например: `npm install` вместо `npm ci`;
* документация проекта со списком команд, которая постоянно устаревает и требует ручной поддержки;
* высокий порог входа для новичков в проекте. Чтобы развернуть проект, приходится полагаться либо на память тимлида, либо на устаревшую документацию, часть команд ничего не сообщают о своём выполнении и непонятно как они отработали.

Со временем разработчики естественным образом начинают искать способ унифицировать команды и свести их к единому интерфейсу. Часто для этого применяются велосипеды на shell-скриптах, но есть гораздо более изящное решение: `Makefile` и утилита `make`.


## Что такое `make` и `Makefile`

Говоря совсем простым языком:

* `make` - это утилита для запуска команд из Makefile. Её нужно устанавливать.
* `Makefile` - это файл, содержащий команды и их имена. Он хранится вместе с кодом в репозитории.

Изначально `make` предназначался для автоматизации сборки исполняемых программ и библиотек из исходного кода. Утилита включена в большинство *nix дистрибутивов, что привело к его широкому распространению и повсеместному использованию. В настоящее время `make` всё чаще используется для описания повторяющихся задач. Эти инструменты позволяют скрыть детали реализации за простыми командами: `make setup`, `make build`, `make test`.

### Синтаксис `Makefile`

Задачи в Makefile описываются как ключи и значения:

```makefile
install-dependencies: # имя задачи, поддерживается kebab-case и snake_case
	npm ci # задача, используется отступ табуляцией

run:
	npx ts-node 'src/bin/hexlet.ts' 10

# можно указывать зависимость между задачами
setup: install-dependencies
	npm link # и комбинировать с другими задачами
# такая зависимость выполнит "npm link" только в случае успешного завершения "npm ci"
```

Все команды, описанные в `Makefile` позволяют проекту самодокументироваться, что убирает необходимость вести документацию вручную и поддерживать её в актуальном состоянии. 

### Утилита `make`


## Заключение

### Дополнительные материалы:

* [Руководство по современному Make](https://ru.makefile.site/) - "выжимка" из документации на русском языке;
* Видео: [Утилита make: полезный универсальный инструмент программиста](https://www.youtube.com/watch?v=pK9mF5aK05Q) - видео-версия данного гайда.

----

Это про то: https://www.youtube.com/watch?v=pK9mF5aK05Q

make - утилита для автоматизации сборки исполняемых программ и библиотек из исходного кода. Таково было изначальное предназначение. 

Утилита включена в большинство *nix дистрибутивов, что привело к его широкому распространению и повсеместному использованию.

make позволяет обеспечить универсальную автоматизацию повторяющихся задач.

```text
примеры как Makefile описывает команды install, test, start, ...
```

Зачем нужен make, когда у каждого языка и технологии имеется собственный менеджер задач? Современный программный продукт, как правило, состоит не из одной технологии, а включает несколько языков, использует дополнительные инструменты, что приводит к появлению объёмной документации, описывающей команды каждой утилиты в проекте. make - это как клей между разными технологиями.

Makefile позволяет описывать зависимость между задачами, как и менеджер задач, встроенный в конкретный язык. Но Makefile не связан технологиями и языками, что даёт возможность комбинировать задачи разных технологий. 

Все команды, описанные в Makefile позволяют проекту самодокументироваться что убирает необходимость вести документацию вручную и поддерживать её в актуальном состоянии.

Использование Makefile во всех проектах позволяет создать идентичные интерфейсы независимо от проекта, например, такие команды `make install`, `make test` и другие.

Показать как пример:
https://github.com/babel/babel/blob/main/Makefile

Инструкция по применению
```makefile
# Makefile
test:
	RAILS_ENV=test make frontend
	bin/rake test

# задача deploy зависит от test
# Эта команда выполнится только при успехе предыдущей 
deploy: test
	# можно использовать переменные окружения, чтобы менять конфигурацию
	ansibleplaybook deploy.yml -i $(ENV) -u $(USR) -v
```

```shell script
# Bash
make test

make deploy ENV=production USR=ubuntu
```

```makefile
# Makefile
test:
	echo 'run tests...'
```

```shell script
# Bash
$ ls
test

make test
make: `test` is up to date.
```

Так происходит потому что make ищет файл или каталог с таким именем для сборки исходников. Это можно изменить через флаг? `.PHONY`:

```makefile
# Makefile last line
.PHONY: test log
```

