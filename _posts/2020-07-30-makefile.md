---
layout: post
title: Что такое Makefile и как начать его использовать
subtitle: Гайд по основам make и Makefile для использования в собственных проектах
summary: Разворачивание и запуск проекта требует ввода команд с разнообразными флагами, которые трудно запомнить и набирать вручную, приходится документировать, но документация устаревает. Этот гайд раскрывает как утилита make позволяет справиться с искусственной сложностью и унифицировать команды независимо от технологий.
cover_url: "/images/makefile/cover.jpg"
---

## Введение

В жизни многих разработчиков найдётся история про первый рабочий день с новым проектом. После клонирования основного репозитория проекта наступает этап, когда приходится вводить множество команд с определёнными флагами и в заданной последовательности. Без описания команд в большинстве случаев невозможно понять что происходит, например:

```sh
# Bash
touch ~/.bash_history
ufw allow 3035/tcp || echo 'cant configure ufw'
ufw allow http || echo 'cant configure ufw'
docker run \
  -v /root/:/root/ \
  -v /etc:/etc \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v /var/tmp:/var/tmp \
  -v /tmp:/tmp \
  -v $PWD:/app \
  --network host \
  -w /app \
  --env-file .env \
  ansible ansible-playbook ansible/development.yml -i ansible/development --limit=localhost -vv
grep -qxF 'fs.inotify.max_user_watches=524288' /etc/sysctl.conf || echo fs.inotify.max_user_watches=524288 | tee -a /etc/sysctl.conf || echo 'cant set max_user_watches' && sysctl -p
sudo systemctl daemon-reload && sudo systemctl restart docker
```

Эти команды являются лишь частью того, что необходимо выполнить при разворачивании проекта. В приведённом примере видно, что команды сами по себе длинные, содержат много флагов, а значит, их трудно не только запомнить, но и вводить вручную. Постоянно вести документацию становится сложнее с ростом проекта, она неизбежно устаревает, а порог входа для новичков становится выше, потому что уже никто не во состоянии вспомнить всех деталей проекта. Некоторые такие команды необходимо использовать каждый день, и даже не один раз в день.

Со временем становится понятно, что нужен инструмент, способный объединить в себе подобные команды, предоставить к ним удобные шорткаты и обеспечить самодокументацию проекта. Именно таким инструментом стал *Makefile* и утилита `make`. 

Изначально `make` предназначалась для автоматизации сборки исполняемых программ и библиотек из исходного кода. Она поставлялась по умолчанию в большинство *nix дистрибутивов, что и привело к её широкому распространению и повсеместному использованию. Позже оказалось что данный инструмент удобно использовать и при разработке любых других проектов, потому что процесс в большинстве своём сводится к тем же задачам - автоматизация и сборка приложений.

Этот гайд призван показать, как средствами *Makefile* и утилиты `make` устранить искусственную сложность, получить всегда актуальную документацию проекта, а процесс разворачивания свести к простым коротким командам такого вида:

```sh
# Bash
make setup-db
make setup-app
make run
make test
```

## Что такое `make` и *Makefile*

*Makefile* — это файл, который хранится вместе с кодом в репозитории. Он выступает и как документация, и как исполняемый код. Мейкфайл скрывает за собой детали реализации и раскладывает "по полочкам" команды, а утилита `make` запускает их. 

## Что такое `make` и *Makefile*

Говоря простым языком:

* *Makefile* — это файл, содержащий команды и их имена. Он хранится вместе с кодом в репозитории.
* `make` — это утилита для запуска команд из Makefile. Она поставляется в операционной системе или устанавливается отдельно. 

Изначально `make` предназначался для автоматизации сборки исполняемых программ и библиотек из исходного кода. Утилита включена в большинство *nix дистрибутивов, что привело к его широкому распространению и повсеместному использованию. 

*Makefile* выступает и как документация, и как исполняемый код. Он скрывает за собой детали реализации внешне и раскладывает "по полочкам" команды внутри себя. При внешней простоте, он является довольно мощным инструментом.

### Синтаксис *Makefile*

Задачи в *Makefile* описываются как ключи и значения:

```makefile
# Makefile
install-dependencies: # имя задачи, поддерживается kebab-case и snake_case
	package-manager install # задача, используется отступ табуляцией

run: # имя задачи описывает семантику вместо реализации, сокращая команду и скрывая флаги
	docker run -it --rm -v $HOME:/usr/src/app node:14 /bin/bash -c "'src/bin/hexlet.ts' 10"

# можно указывать зависимость между задачами
setup: install-dependencies
	ansible-playbook ansible/development.yml -i ansible/development -vv # и комбинировать с другими задачами
# такая зависимость выполнит "ansible-playbook..." только в случае успешного завершения "package-manager install"
```

Как видно из примера, мейкфайл позволяет вне зависимости от языков и инструментов описать назначение команд, что делает проект самодокументируемым. Описывая зависимость между задачами становится возможным одной командой запустить цепочку, которая прервётся только при наличии ошибки. Такой подход убирает необходимость помнить команды разработчикам, вести документацию вручную и поддерживать её в актуальном состоянии.

#### Фальшивая цель

Имена задач называются "целями" и в мейкфайле есть понятие "phony target", что можно перевести как "фальшивая цель". Как уже говорилось ранее, изначально `make` предназначался для сборок из исходного кода. Поэтому, если добавить в мейкфайл цель, имя которой совпадает с именем файла / каталога, то задача не выполнится.

```makefile
# Makefile
test:
	mix coveralls.json --exclude code_check --max-failures 1
```

```sh
# Bash
$ ls
test

make test
make: `test` is up to date.
```

Так происходит потому что `make` собрать программу из исходников указанной цели, и ею является каталог *test*. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить `.PHONY` указатель на цель:

```makefile
# Makefile last line
.PHONY: test
```

```sh
# Bash
$ make test
✓ All tests passed!
```

### Использование `make`

Чтобы выполнить задачи из конкретного мейкфайла, достаточно запустить утилиту `make` в том каталоге, где он находится. Запуск команд можно производить по одной (`make setup`, `make test`, ...) или указывать цепочкой через пробел. Так будет выглядеть установка и запуск приложения через `make`:

```sh
# Bash
$ make setup test run
package-manager install  # make setup вызвал make install-dependencies
mix coveralls.json --exclude code_check --max-failures 1  # make test
✓ PASS # результат выполнения тестов
docker run -it --rm -v $HOME:/usr/src/app node:14 /bin/bash -c "'src/bin/hexlet' 10" # make run
5 # результат выполнения кода
```

### Переменные

Зачастую команды используют параметры для конфигурации, указания путей, переменные окружения и `make` тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:

```makefile
# Makefile
say:
	echo "Hello, $(HELLO)!"
```

```sh
# Bash
$ make say HELLO=World
echo "Hello, World!"
Hello, World!

$ make say HELLO=Kitty
echo "Hello, Kitty!"
Hello, Kitty!
```

Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.

```makefile
# Makefile
HELLO?=World # знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.

say:
	echo "Hello, $(HELLO)!"
```

```sh
# Bash
$ make say
echo "Hello, World!"
Hello, World!

$ make say HELLO=Kitty
echo "Hello, Kitty!"
Hello, Kitty!
```

Некоторые переменные в Makefile имеют названия отличные от системных. Например, `$PWD` называется `$CURDIR` в мейкфайле:
```makefile
# Makefile
terraform-vars-generate:
	docker run -it -v $(CURDIR):/app -w /app williamyeh/ansible:ubuntu18.04 ansible-playbook ansible/terraform.yml -i ansible/production -vv --vault-password-file=tmp/ansible-vault-password
``` 

Уже этой функциональности достаточно для большинства типовых задач. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов.

## Заключение

В настоящее время у многих языков и технологии имеется собственный менеджер задач. Но их ключевое отличие от мейкфайла - это конкретная цель, которой они служат. Было бы неправильно включать в конфигурацию языка команды для запуска bash-скриптов, а конфигурацию CI для скачивания дампа базы данных. Именно благодаря тому, что *Makefile* не связан с конкретными технологиями и языками, он выступает как универсальный "клей" между ними. 

Повсеместное использование мейкфайла позволит выявить повторяющиеся и типовые задачи. Особенно это актуально там, где множество проектов, например, при заказной разработке. Всё что понадобится знать разработчику в проектах, использующих мейкфайл - это несколько команд: `make setup start`, `make test deploy`.

### Дополнительные материалы:

* [Руководство по современному Make](https://ru.makefile.site/) — "выжимка" из документации на русском языке;
* [Утилита make: полезный универсальный инструмент программиста](https://www.youtube.com/watch?v=pK9mF5aK05Q) — видео-версия данного гайда.

Пример использования мейкфайла в крупных проектах:

* [Codebattle](https://github.com/hexlet-codebattle/codebattle/blob/master/Makefile);
* [Babel](https://github.com/babel/babel/blob/main/Makefile);
* [Kubernetes](https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile);
