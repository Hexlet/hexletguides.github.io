---
layout: post
title: Что такое Makefile и как начать его использовать
subtitle: Гайд по основам make и Makefile для использования в собственных проектах
summary: Современные программы, как правило, состоят больше, чем из одной технологии, написаны на нескольких языках и использует дополнительные инструменты. Это увеличивает сложность проекта, приходится многое помнить или поддерживать объёмную устаревающую документацию. В этом гайде вы узнаете как утилита make позволяет справиться с этой сложностью и унифицировать команды независимо от технологий.
cover_url: "Путь к файлу-обложке для соц. сетей, например, /images/encoding/Unicode-Logo.jpg"
---

## Введение

Современные программы, как правило, состоят больше, чем из одной технологии, но и одна технология может включать в себя множество команд для выполнения повторяющихся задач. Например, так выглядят команды для [приложения на TypeScript](https://github.com/hexlet-boilerplates/ts-package):

```shell script
npm ci              # установка зависимостей
npm test -s         # запуск тестов
npx eslint src/**/* # запуск линтера
npm publish         # публикация пакета
npm run build       # сборка пакета в .js-файлы  
npx ts-node 'src/bin/hexlet.ts' 10                      # запуск .ts-файла
node -n --experimental-vm-modules './dist/bin/hexlet.js' 10 # запуск .js-файла
``` 

И это только "верхушка айсберга", если приложение будет собираться в [Docker](https://guides.hexlet.io/docker/), то появятся ещё новые команды, а предыдущие будут продублированы с приставкой `docker run <множество ключей>`. 

Чем больше и сложнее проект, тем больше в нём используется команд, утилит и технологий, что приводит к таким явлениям:

* один или несколько разработчиков, обладающие тайными знаниями команд проекта;
* разработчики используют разные команды для решения одной задачи, например, обновление зависимостей вместо установки (`npm install` вместо `npm ci`);
* документация проекта со списком команд, которая постоянно устаревает и требует ручной поддержки;
* высокий порог входа для новичков в проекте. Чтобы развернуть проект, приходится полагаться либо на память тимлида, либо на устаревшую документацию, а часть команд ничего не сообщают о своём выполнении и непонятно, как они отработали.

Со временем разработчики естественным образом начинают искать способ унифицировать команды и свести их к единому интерфейсу. Часто для этого применяются "велосипеды" на shell-скриптах, но есть гораздо более изящное решение: *Makefile* и утилита `make`.


## Что такое `make` и *Makefile*

Говоря совсем простым языком:

* `make` — это утилита для запуска команд из Makefile. Она поставляется в операционной системе или устанавливается отдельно. 
* *Makefile* — это файл, содержащий команды и их имена. Он хранится вместе с кодом в репозитории.

Изначально `make` предназначался для автоматизации сборки исполняемых программ и библиотек из исходного кода. Утилита включена в большинство *nix дистрибутивов, что привело к его широкому распространению и повсеместному использованию. В настоящее время `make` всё чаще используется для описания повторяющихся задач. Эти инструменты позволяют скрыть детали реализации за простыми командами: `make setup`, `make build`, `make test`.

### Синтаксис *Makefile*

Задачи в Makefile описываются как ключи и значения:

```makefile
install-dependencies: # имя задачи, поддерживается kebab-case и snake_case
	npm ci # задача, используется отступ табуляцией

run: # имя задачи описывает семантику вместо реализации
	npx ts-node 'src/bin/hexlet.ts' 10

# можно указывать зависимость между задачами
setup: install-dependencies
	npm run build # и комбинировать с другими задачами
# такая зависимость выполнит "npm run build" только в случае успешного завершения "npm ci"
```

Makefile позволяет описывать зависимость между задачами, как и менеджер задач, встроенный в конкретный язык. Но Makefile не связан технологиями и языками, что даёт возможность комбинировать задачи разных технологий. Использование мейкфайла делает проект самодокументируемым, что убирает необходимость помнить команды, вести документацию вручную и поддерживать её в актуальном состоянии.

#### Фальшивая цель

Имена задач называются "целями" и в мейкфайле есть понятие "phony target", что можно перевести как "фальшивая цель". Если добавить в мейкфайл цель, имя которой совпадает с именем файла / каталога, то задача не выполнится.

```makefile
# Makefile
test:
	npm test -s
```

```shell script
# Bash
$ ls
test

make test
make: `test` is up to date.
```

Так происходит потому что `make` пытается выполнить своё изначальное предназначение — собрать программу из исходников указанной цели, и ею является каталог *test*. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить указатель на цель:

```makefile
# Makefile last line
.PHONY: test
```

```shell script
# Bash
$ make test
✓ All tests passed!
```

### Использование `make`

Утилита `make` ищет мейкфайл в каталоге, где она была запущена. Конечно, это поведение можно изменять флагами, но в рамках данного гайда такие кейсы будут опущены. В качестве образца будет использоваться упомянутый *ts-package*. Запуск команд можно производить по одной (`make setup`, `make test`, ...) или указывать цепочкой через пробел. Так будет выглядеть установка и запуск пакета через `make`:

```shell script
ts-package: $ ls
│
├── Makefile # здесь содержатся задачи, описанные ранее
├── node_modules
├── package.json
├── package-lock.json
├── README.md
├── src
├── __tests__
└── tsconfig.json
```

```shell script
ts-package: $ make setup test run
npm ci        # make install-dependencies
npm WARN prepare removing existing node_modules/ before installation
added 734 packages in 2.82s
npm run build # make build

> @hexlet/ts-package@1.0.0 build /home/melodyn/projects/opensource/ts-package
> tsc

npm test -s   # make test
 PASS  __tests__/half.test.ts
  ✓ halt (5 ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.118 s
Ran all test suites.

npx ts-node 'src/bin/hexlet.ts' 10 # make run
5
```

### Переменные

Зачастую команды используют параметры для конфигурации, указания путей, переменные окружения и `make` тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:

```makefile
# Makefile
run:
	npx ts-node 'src/bin/hexlet.ts' $(NUMBER)
```

```shell script
# Bash
$ make run NUMBER=10
npx ts-node 'src/bin/hexlet.ts' 10
5

$ make run NUMBER=20
npx ts-node 'src/bin/hexlet.ts' 20
10
```

Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.

```makefile
# Makefile
NUMBER?=10 # знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.

run:
	npx ts-node 'src/bin/hexlet.ts' $(NUMBER)
```

```shell script
# Bash
$ make run
npx ts-node 'src/bin/hexlet.ts' 10
5

$ make run NUMBER=20
npx ts-node 'src/bin/hexlet.ts' 20
10
```

Уже этой функциональности достаточно для большинства типовых задач. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов.

## Заключение

Зачем нужен `make`, когда у каждого языка и технологии имеется собственный менеджер задач? Он позволяет описывать зависимость между задачами, как и менеджер задач, встроенный в конкретный язык. Но *Makefile* не связан технологиями и языками, а утилита `make` поставляет в большинство *nix систем. Таким образом `make` выступает как "клей" между разными технологиями и задачами.

Повсеместное использование мейкфайла позволит выявить паттерны, которые будут стандартизироваться, а позже их можно будет автоматизировать. Особенно это актуально там, где множество проектов на разных технологиях, но всё что нужно знать разработчику - это несколько команд: `make setup start`, `make test deploy`.

### Дополнительные материалы:

* [Babel Makefile](https://github.com/babel/babel/blob/main/Makefile) —  пример как выглядит мейкфайл в крупных проектах;
* [Руководство по современному Make](https://ru.makefile.site/) — "выжимка" из документации на русском языке;
* [Утилита make: полезный универсальный инструмент программиста](https://www.youtube.com/watch?v=pK9mF5aK05Q) — видео-версия данного гайда.
