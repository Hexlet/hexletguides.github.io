---
layout: post
title: Что такое Makefile и как начать его использовать
subtitle: Гайд по основам make и Makefile для использования в собственных проектах
summary: Разворачивание и запуск проекта требует ввода команд с разнообразными флагами, которые трудно запомнить и набирать вручную, приходится документировать, но документация устаревает. Этот гайд раскрывает как утилита make позволяет справиться с искусственной сложностью и унифицировать команды независимо от технологий.
cover_url: "/images/makefile/cover.jpg"
---

## Введение

Разворачивание и запуск проекта требует ввода команд с разнообразными флагами, которые трудно запомнить и набирать вручную. Разработчики могут тратить часы, а то и дни, выполняя команды, чтобы:
* скачать дамп базы данных;
* запустить базу данных в контейнере и развернуть дамп через миграции;
* установить зависимости проекта;
* запустить приложение в контейнере;
* прокинуть порты, подключить кэш, очередь, систему обмена сообщениями;
* запуск тестов и линтера;
* сборка проекта для разных окружений.

Чтобы не забыть порядок действий и выполняемые команды, разработчики начинают вести документацию и прятать команды в shell-скрипты. При этом доходит до нецелевого инструментов, например, прописывание bash-команд в секцию скриптов файла, описывающего зависимости проекта.  

Чем больше и сложнее проект, тем больше в нём используется сложных команд, что приводит к таким явлениям:

* один или несколько разработчиков, обладающие тайными знаниями команд проекта;
* разработчики используют разные команды для решения одной задачи;
* документация проекта со списком команд, которая постоянно устаревает и требует ручной поддержки;
* высокий порог входа для новичков в проекте. Чтобы развернуть проект, приходится полагаться либо на память тимлида, либо на устаревшую документацию, а часть команд ничего не сообщают о своём выполнении и непонятно, как они отработали.

Решением, которое позволяет убрать искусственную сложность и получить всегда актуальную документацию проекта, является *Makefile* и утилита `make`.

## Что такое `make` и *Makefile*

Говоря простым языком:

* `make` — это утилита для запуска команд из Makefile. Она поставляется в операционной системе или устанавливается отдельно. 
* *Makefile* — это файл, содержащий команды и их имена. Он хранится вместе с кодом в репозитории.

Изначально `make` предназначался для автоматизации сборки исполняемых программ и библиотек из исходного кода. Утилита включена в большинство *nix дистрибутивов, что привело к его широкому распространению и повсеместному использованию. В настоящее время `make` всё чаще используется для описания повторяющихся задач.

*Makefile* выступает и как документация, и как исполняемый код. Он скрывает длинные команды, флаги и другие детали реализации. Это позволяет подобные инструкции:

```text
Чтобы развернуть проект нужно всего лишь:
Установить глобально docker, postresql 10, redis 4
docker-compose up -d db-local
docker run -it -v $PWD:/app -w /app williamyeh/ansible:ubuntu18.04 ansible-playbook ansible/terraform.yml -i ansible/production -vv --vault-password-file=tmp/ansible-vault-password
ansible-playbook ansible/development.yml -i ansible/development -vv
mix ecto.reset && mix run priv/repo/seeds.exs
bin/codebattle eval "Codebattle.Utils.Release.migrate"
bin/codebattle start
mix coveralls.json --exclude code_check --max-failures 1

Если что-то не получилось - разбирайся.
```

превратить в простые команды:

```text
make setup-db
make setup-app
make run
make test
```

### Синтаксис *Makefile*

Задачи в Makefile описываются как ключи и значения:

```makefile
install-dependencies: # имя задачи, поддерживается kebab-case и snake_case
	package-manager install # задача, используется отступ табуляцией

run: # имя задачи описывает семантику вместо реализации, сокращая команду и скрывая флаги
	docker run -it --rm -v $HOME:/usr/src/app node:14 /bin/bash -c "'src/bin/hexlet.ts' 10"

# можно указывать зависимость между задачами
setup: install-dependencies
	ansible-playbook ansible/development.yml -i ansible/development -vv # и комбинировать с другими задачами
# такая зависимость выполнит "ansible-playbook..." только в случае успешного завершения "package-manager install"
```

Makefile позволяет описывать зависимость между задачами, как и менеджер задач, встроенный в конкретный язык. Но Makefile не связан технологиями и языками, что даёт возможность комбинировать задачи разных технологий. Использование мейкфайла делает проект самодокументируемым, что убирает необходимость помнить команды, вести документацию вручную и поддерживать её в актуальном состоянии.

#### Фальшивая цель

Имена задач называются "целями" и в мейкфайле есть понятие "phony target", что можно перевести как "фальшивая цель". Если добавить в мейкфайл цель, имя которой совпадает с именем файла / каталога, то задача не выполнится.

```makefile
# Makefile
test:
	mix coveralls.json --exclude code_check --max-failures 1
```

```sh
# Bash
$ ls
test

make test
make: `test` is up to date.
```

Так происходит потому что `make` пытается выполнить своё изначальное предназначение — собрать программу из исходников указанной цели, и ею является каталог *test*. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить указатель на цель:

```makefile
# Makefile last line
.PHONY: test
```

```sh
# Bash
$ make test
✓ All tests passed!
```

### Использование `make`

Утилита `make` ищет мейкфайл в каталоге, где она была запущена. Конечно, это поведение можно изменять флагами, но в рамках данного гайда такие кейсы будут опущены. Запуск команд можно производить по одной (`make setup`, `make test`, ...) или указывать цепочкой через пробел. Так будет выглядеть установка и запуск пакета через `make`:

```sh
$ make setup test run
package-manager install  # make setup вызвал make install-dependencies
mix coveralls.json --exclude code_check --max-failures 1  # make test
✓ PASS # результат выполнения тестов
docker run -it --rm -v $HOME:/usr/src/app node:14 /bin/bash -c "'src/bin/hexlet' 10" # make run
5 # результат выполнения кода
```

### Переменные

Зачастую команды используют параметры для конфигурации, указания путей, переменные окружения и `make` тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:

```makefile
# Makefile
say:
	echo "Hello, $(HELLO)!"
```

```sh
# Bash
$ make say HELLO=World
echo "Hello, World!"
Hello, World!

$ make say HELLO=Kitty
echo "Hello, Kitty!"
Hello, Kitty!
```

Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.

```makefile
# Makefile
HELLO?=World # знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.

say:
	echo "Hello, $(HELLO)!"
```

```sh
# Bash
$ make say
echo "Hello, World!"
Hello, World!

$ make say HELLO=Kitty
echo "Hello, Kitty!"
Hello, Kitty!
```

Некоторые переменные в Makefile имеют названия отличные от системных. Например, `$PWD` называется `$CURDIR` в мейкфайле:
```makefile
terraform-vars-generate:
	docker run -it -v $(CURDIR):/app -w /app williamyeh/ansible:ubuntu18.04 ansible-playbook ansible/terraform.yml -i ansible/production -vv --vault-password-file=tmp/ansible-vault-password
``` 

Уже этой функциональности достаточно для большинства типовых задач. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов.

## Заключение

В настоящее время у многих языков и технологии имеется собственный менеджер задач. Но их ключевое отличие от мейкфайла - это конкретная цель, которой они служат. Было бы неправильно включать в конфигурацию языка команды для запуска bash-скриптов, а конфигурацию CI для скачивания дампа базы данных. Именно благодаря тому, что  *Makefile* не связан с конкретными технологиями и языками, а утилита `make` поставляет в большинство *nix систем, они выступают как "клей" между разными задачами. 

Повсеместное использование мейкфайла позволит выявить паттерны, которые будут стандартизироваться, а позже их можно будет автоматизировать. Особенно это актуально там, где множество проектов на разных технологиях, но всё что нужно знать разработчику - это несколько команд: `make setup start`, `make test deploy`.

### Дополнительные материалы:

* [Руководство по современному Make](https://ru.makefile.site/) — "выжимка" из документации на русском языке;
* [Утилита make: полезный универсальный инструмент программиста](https://www.youtube.com/watch?v=pK9mF5aK05Q) — видео-версия данного гайда.

Пример использования мейкфайла в крупных проектах:

* [Codebattle](https://github.com/hexlet-codebattle/codebattle/blob/master/Makefile);
* [Babel](https://github.com/babel/babel/blob/main/Makefile);
* [Kubernetes](https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile);
