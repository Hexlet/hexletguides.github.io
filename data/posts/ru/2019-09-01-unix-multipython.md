---
title: Несколько версий Python на Linux-машине
redirect_to: https://ru.hexlet.io/blog/posts/ispolzovanie-neskolkih-versiy-python-na-unix-podobnyh-operatsionnyh-sistemah
subtitle: Использование нескольких версий Python на unix-подобных операционных системах.
description: Возможные способы установки нескольких версий среды исполнения Python на одну машину под управлением ОС семейства Unix. Решение проблем с установкой приложений, рассчитанных на использование конкретной версии Python, с применением виртуальных окружений.
image: "/assets/images/python-2-and-3-logo.png"
hidden: true
author: Кирилл Мокевнин
---

### Использование нескольких версий Python на unix-подобных операционных системах.


#### Что и зачем?

Python как язык постоянно развивается. Ветка Py2 скоро будет объявлена неподдерживаемой. Однако до сих пор существуют окружения, где приходится использовать Py2 и даже не свежий 2.7.x, а что-то по-старее. Да и Python 3.x нынче — это большое семейство версий, кое-где несовместимых между собой, в т.ч. и синтаксически! Поэтому практикующий питонист широкого профиля должен понимать, как на одной машине иметь несколько версий среды исполнения. Даже если "в продакшне" и используется какой-нибудь Docker!

![logo](/assets/images/python-2-and-3-logo.png)

#### Установка Python из репозиториев пакетов операционной системы.

Если вам повезло, то в репозитории пакетов ОС будет нужная версия Python и вы сможете её установить с помощью команды вроде `sudo apt-get install python3.5`. Однако достаточно старые [дистрибутивы ОС](https://ru.wikipedia.org/wiki/Дистрибутив_Linux) могут не содержать новых версий Python, а достаточно новые дистрибутивы — старых версий Python. В особых случаях репозиторий вообще может содержать только одну версию среды исполнения.


#### Сборка из исходного кода.

CPython — проект с исходным кодом. Доступ к исходному коду всех версий CPython позволяет собрать нужную версию самостоятельно. Однако это процесс, пусть и достаточно хорошо документирован, но всё же требует понимания того, что вам может потребоваться для компиляции кода под вашу операционную систему.

А ещё сборка из исходного кода — это единственный вариант для тех, кто хочет что-то в этом самом коде изменить или скомпилировать интерпретатор для какой-то экзотической платформы (встраиваемые системы, ретро-железо).


#### pyenv

Ещё одним из способов получения разных версий среды исполнения на одной машине является [pyenv](https://github.com/pyenv/pyenv). Это "менеджер версий", выполненный в стиле rbenv для Ruby, nvm для NodeJS и т.п.

Миссия pyenv — управлять установленными версиями Python и делать некую версию "активной". Активная версия вызывается, если мы выполняем команду `python` (а также `pip`), при этом разные проекты могут использовать разные активные версии и даже более чем одну одновременно. Последнее свойство полезно авторам библиотек, рассчитанных на широкий круг пользователей — таковые *всегда нужно тестировать на разных версиях* Python.

Установить pyenv достаточно просто, ведь инструмент представляет собой набор shell scripts. Именно поэтому получился pyenv максимально кроссплатформенным. Но за эту кроссплатформенность приходится платить тем, что каждую версию среды исполнения *нужно компилировать из исходного кода*! Для компиляции того же CPython потребуется компилятор Си (`gcc` на Linux и `clang` на MacOS), и [заголовочные файлы](https://ru.wikipedia.org/wiki/Заголовочный_файл) для библиотек, которые использует интерпретатор. Полный список пререквизитов для сборки приходится гуглить.


#### Установка системным пакетным менеджером из сторонних источников.

Для большинства Unix-like ОС, помимо официальных репозиториев, существуют и неофициальные источники пакетов.

Для Debian-like систем, таких как Ubuntu и её производные, сторонние источники пакетов называются *PPA, Personal Package Archives*. Подключить любой PPA достаточно просто, но нужно понимать, что вы таким образом соглашаетесь на установку пакетов из стороннего источника, никак не подчиняющегося авторам дистрибутива ОС! Подключайте только хорошо зарекомендовавшие себя PPA, например — от самих авторов ПО, которое вы хотите установить!

Для Ubuntu-based систем существует [PPA от команды "deadsnakes"](https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa). Это проверенный источник пакетов с самыми разными версиями Python как для свежих релизов ОС, так и для релизов "второй свежести".

Главное преимущество установки пакетов из проверенных PPA состоит в том, что пакеты обычно содержат оптимизированные под конкретный дистрибутив сборки с должным количеством обновлений и исправлений. Такие сборки более безопасны и производительны, чем те, что собраны вручную из исходников.

К тому же в популярных PPA пакеты обновляются своевременно, чего нельзя сказать про пакеты для устаревших релизов ОС, для которых срок поддержки закончился. Конечно, такие релизы лучше вообще не использовать (небезопасно!), но иногда может не быть выбора, а с PPA вы хотя бы будете иметь свежие версии среды исполнения.


#### Псевдонимы `python`, `python2`, `python3`.

Исторически сложилось так, что интерпретатор Python запускается командой `python`. Но в какой-то момент случились Python3, обратная несовместимость, "разброд и шатания". Чтобы внести некоторую определённость, был представлен [PEP-394](https://www.python.org/dev/peps/pep-0394/): *The "python" Command on Unix-Like Systems*. Однако даже этот PEP разрешает разным системам *самим выбирать*, использовать ли Py2 и Py3 вместе или выбрать что-то одно. Системы должны лишь обеспечить, чтобы

- команда `python2` вызывала некую версию Python 2.x, если таковая вообще предоставляется;
- команда `python3` вызывала некую версию Python 3.x, если таковая предоставляется;
- команда `python` соответствовала либо `python2`, либо `python3` (но не ссылалась на какую-то "третью" версию рантайма).

При этом не гарантируется, что все эти команды будут присутствовать в конкретном случае: где-то будет доступна только команда `python3`, где-то — `python2`. Псевдоним `python` вообще *обязан присутствовать лишь в виртуальном окружении* и всегда соответствовать той версии интерпретатора, которая *была выбрана при создании окружения*.

Такое "разнообразие" сильно усложняет жизнь разработчикам ПО, особенно — авторам инструментов разработки! Разработчик может написать скрипт для Py2 и указать в [shebang](https://ru.wikipedia.org/wiki/Шебанг_(Unix)) `#!/usr/bin/env python`. Но на одних ОС команда `python` вообще не будет доступна и скрипт просто не запустится, а на других `python` будет означать какой-нибудь Python 3.8 и скрипт может даже запуститься, но сломается в процессе выполнения.

И даже если автор использует техники, позволяющие писать портируемый код ([six](https://pypi.org/project/six/), [3to2](https://pypi.org/project/3to2/)), умеющий выполняться и на Py2, и на Py3, всё равно непонятно что же указать в shebang!

Вышеупомянутый PEP советует

- либо фиксировать версию явно (только Py2 или только Py3),
- либо требовать использования виртуальных окружений (в ВО всегда будет доступна команда `python`)
- либо не писать shebang руками, а вместо этого использовать средства setuptools или другой системы пакетирования, создающие точки входа в зависимости при установке пакета (у точек входа shebang будет правильный).


### Установка poetry на системы с разными версиями Python

На момент написания статьи poetry (это такой менеджер виртуальных окружений, сборщик пакетов и проч — "швейцарский нож" разработчика на Python) страдал от проблем с версиями рантайма: при установке рекомендованными способом скрипт-установщик завершался с ошибкой, либо установка проходила успешно, но затем не работала сама программа.

Дело (было?) в том, что и в скрипте-установщике и в точках входа в программу в shebang прописан `python`! Сама программа работает и на Py2, и на Py3, но авторы исходили из предположения, что на целевой системе в любом случае будет присутствовать псевдоним `python`, вызывающий тот или иной интерпретатор. На некоторых системах такой команды нет&#x2026;

Если использовать pyenv, оный всегда предоставляет команду `python` и poetry "просто работает". Нет проблем и на старых дистрибутивах, где ещё не отказались окончательно от `Py2`. И конечно всё работает в виртуальном окружении. Рассмотрим этот вариант поподробнее.


#### Установка в выделенное виртуальное окружение

Для начала нам понадобится само окружение. Предположим, что Python3 вы уже так или иначе поставили. Делаем раз

```shell
$ python3 -m venv $HOME/.poetry.venv
```

Делаем два

```shell
$ $HOME/.poetry.venv/bin/pip install poetry
```

Проверяем

```shell
$ $HOME/.poetry.venv/bin/poetry --version
Poetry 0.12.17
```

Программа установлена! Теперь создаём символическую ссылку на точку входа в папке, видимой в `PATH`, например, в `$HOME/.local.bin`:

```shell
$ ln -s $HOME/.poetry.venv/bin/poetry $HOME/.local/bin
```

Проверяем

```shell
$ poetry --version
Poetry 0.12.17
```

Работает! Обновлять программу в будущем можно с помощью того же `pip` (который в окружении). А можно и вовсе автоматизировать процесс установки такого вот Python-софта с помощью [pipx](https://pipxproject.github.io/pipx/).


#### Особенности использования poetry, установленного в виртуальное окружение.

Poetry построен так, чтобы работать с абстрактной версией python. Поэтому он хорошо сочетается с pyenv: один на себя берёт управление разными пайтонами, а другой — проектами на этих пайтонах.

Но эта привязка к команде `python` немного мешает, когда poetry установлен в своём собственном виртуальном окружении: в этом окружении Python уже известен и не может быть изменён. Данная особенность упомянута в документации к poetry, так что это "не баг, а фича". И всё же есть способ обойти сие ограничение: можно инициализировать окружение вручную с нужной версией Python и настроить poetry на использование этого готового окружения.

Для начала учим poetry создавать окружения не в своём кэше, а в папке с проектом:

```shell
$ poetry config settings.virtualenvs.in-project true
```

С этих пор для каждого проекта виртуальное окружение будет располагаться в поддиректории `.venv`.

Уже в конкретном проекте инициализируем окружение командой

```shell
$ python3 -m venv .venv
```

(для Py2 команда будет другой, т.к. модуль `venv` тогда ещё не поставлялся вместе со средой исполнения).

Теперь можно работать с poetry как обычно. Несмотря на то, что Python в проекте, возможно, отличается от рантайма, запускающего poetry!
