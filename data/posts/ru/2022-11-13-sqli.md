---
title: Что такое SQL-инъекция
description: |
  Вводная информация об одной из известнейших уязвимостей

# image: "/assets/images/bootstrap/bootstrap.jpeg"
author: Александр Коростелин
---

Защита создаваемого приложения от злонамеренных воздействий третьих лиц — одна из важных задач, стоящих перед разработчиком. За сухой формулировкой скрывается незатейливая идея: в то время как большинство людей будут использовать ваше приложение в соответствии с задуманным функционалом, немногочисленные иные пользователи непременно попытаются сделать так, чтоб оно "сломалось". Мотивы и цели такого поведения могут различаться, от банального развлечения до коммерческих интересов, но статья не об этом — условимся принять как факт, что действия пользователя могут не соответствовать ожидаемому разработчиком сценарию. В случае, если подобные "неправильные" действия предприняты пользователем умышленно (а не в результате ошибки ввода, например), мы говорим об **атаке** на приложение. Соответственно, если приложение не игнорирует подобные действия каким-либо безопасным образом, а демонстрирует непредсказуемое, отличающееся от задуманного разработчиком, поведение — мы говорим о том, что оно **уязвимо**. Разумеется, для построения безопасных приложений нам важно хотя бы базовое понимание, как организовываются атаки и какие части приложения уязвимы. 

## Что такое инъекция кода

Мы можем представить веб-приложение состоящим из двух частей: клиентской и серверной. Клиентская часть отображает пользовательский интерфейс, серверная — обрабатывает запросы клиента. В своей работе, серверная часть активно взаимодействует с хранилищем данных — обычно, это некоторая база данных. Соответственно, цепочка взаимодействий такова: веб-сервер получает запрос от клиента, на основе которого формирует запрос к движку БД, движок БД выполняет этот запрос и отдаёт некоторую информацию, которую веб-сервер обрабатывает и отдает клиенту в виде веб-странички.  

Давайте рассмотрим этот процесс на чуть более жизненном примере. Пусть дана некоторая организация, сотруднику которой необходимо получить список заказов из города Лондон. Несложно предположить, что сотрудник каким-то образом передаст серверу информацию, из какого же именно города ему требуется выборка заказов. Посмотрим на диаграмму взаимодействий:  

![diag1](https://user-images.githubusercontent.com/86118729/208390430-f4e80e88-5457-4e21-a4b3-bf557fbfd5f8.svg) 

Подчеркнём, что в действительности клиент запрашивает не какую-то произвольную информацию от сервера, а заданную конкретным **параметром запроса** — названием города или организации, логином пользователя, идентификатором страницы, и т.п. Подробности процесса для нас, на самом деле, сейчас не сильно важны; главное, что требуется понимать — отправленный веб-серверу запрос в конечном итоге вызовет исполнение движком БД некоторых команд, причем, в этих командах будет в том или ином виде включена информация, переданная в параметрах изначального запроса. На приведенной диаграмме это — название города.  

Как раз здесь и скрывается уязвимость — параметр запроса может быть некорректно обработан приложением. Например, в запрос может быть **внедрена** некоторая команда, которая попадёт в движок БД в виде, пригодном для исполнения. И тогда, вместо ожидаемого разработчиком выполнения легитимного запроса (или вместе с ним), приложение продемонстрирует непредсказуемое поведение, которое и требуется злоумышленнику — например, раскроет информацию, хранящуюся в других таблицах БД или удалит записи из неё.  

Разумеется, коль скоро мы говорим о реляционных базах данных (а их до сих пор в вебе большинство), то и команды движку БД будут составлены на языке запросов SQL. Принцип внедрения таких команд в легитимные запросы дает название рассматриваемому классу атак: "внедрение SQL-кода", или, что привычнее — **SQL-инъекция** (калька с англ. SQL injection, сокр. SQLi).  

Атаки типа инъекции не новы – на самом деле, они известны примерно с конца 90-х, с тех самых пор, когда статичные HTML-страницы сайтов стали вытесняться интерактивным контентом. Именно в те времена веб-сайты стали обзаводиться базами данных и первыми веб-приложениями, обеспечивающими взаимодействие с посетителем. Классические SQL-инъекции встречаются всё реже, поскольку современные веб-фреймворки оснащаются встроенными механизмами защиты. Тем не менее, уязвимые приложения существуют, и подверженность рассматриваемому типу атак являет собой критическую уязвимость системы. Внедрение вредоносного кода занимает третье место в списке наиболее критичных уязвимостей веб-приложений [OWASP Top Ten](https://owasp.org/www-project-top-ten/) на 2021 год.

## Примеры SQL injection

Рассмотрим простейший пример. Вряд ли он встретится в жизни, но достаточен для иллюстрации. Пусть среди функционала нашего гипотетического приложения присутствует выборка из БД заказов, отправляемых в некий город, название которого передаётся параметром GET-запроса. 

```
http://vulnerable.com/something/orders?view=London
```

И на стороне сервера выполняется следующий запрос к БД:

```sql
SELECT * FROM orders WHERE destination = 'London'
```

Где название города подставляется напрямую из параметра запроса веб-клиента. На нашей диаграмме это можно отобразить следующим образом (красным цветом выделена информация, передаваемая с запросом, неправильная обработка которой и несёт в себе уязвимость):  

![diag2](https://user-images.githubusercontent.com/86118729/208392514-bc97ac88-299e-4c74-8702-bc8f92472a2c.svg)


Теперь предположим, что клиент изменил название города с London на:

```
London'; drop table orders -- 
```

И тогда на стороне сервера выполняется следующий запрос к БД:

```sql
SELECT * FROM orders WHERE destination = 'London'; drop table orders -- '
```

В языке SQL, точка с запятой отделяет один запрос от другого, а пробел и двойной дефис означают начало комментария. Таким образом, данная строка может быть представлена в виде двух последовательных запросов:

```sql
SELECT * FROM orders WHERE destination = 'London'
DROP TABLE orders
```

И после их выполнения таблица с информацией о заказах будет удалена из БД:  

![diag3](https://user-images.githubusercontent.com/86118729/208393649-3f51dae9-5537-4133-aa1e-3638e47020de.svg)  

Можно сконструировать и другие запросы к рассматриваемому серверу. Например, передадим такое название города:  

```
London' OR 1=1 -- 
```

И получим следующий запрос к БД на стороне сервера:  

```sql
SELECT * FROM orders WHERE destination = 'London' OR 1=1 -- '
```  

В этом случае, условие будет всегда истинно, и уязвимый сервер выдаст всё содержимое таблицы заказов. Также злоумышленник может комбинировать запросы, используя ключевое слово `UNION`, и получить ещё больше информации, в том числе и из других таблиц БД. Наконец, запрос может быть составлен таким образом, чтоб получить в ответ ошибку — интерпретация текста ошибки также бывает полезна для атакующего, поскольку может раскрывать версии используемого на сервере ПО, что, в свою очередь, даёт информацию для проведения последующих атак.  

К примеру, добавим в наш легитимный запрос всего один специальный символ к названию города, а именно, одиночную кавычку: `London'`. Или так: `Lon'don`. Или даже заменим название города на кавычку, вот так: `'`. Во всех случаях синтаксис генерируемого запроса к БД будет нарушен, и мы получим сообщение об ошибке. Например:  

```
An error occurred: PG::SyntaxError: ERROR: unterminated quoted string at or near "'destination'' ...
```  

По тексту ошибки нам становится понятно, что на сервере работает PostgreSQL. А это значит, что мы можем узнать версию БД запросом `SELECT version()`, и затем поискать специфичные уязвимости для конкретной версии. Такой тип атак, направленный на генерацию сообщений об ошибках, носит название **Error-based SQL injection**.

Как мы видим, уязвимость системы во всех рассмотренных случаях базируется на том, что полученный извне параметр запроса используется для генерации SQL-кода "как есть", без какой-либо предварительной проверки или фильтрации. Как раз в этом и заключается ошибка разработчика.    

Больше примеров разных типов SQL-инъекций можно посмотреть, в частности, на сайте [W3C](https://www.w3schools.com/sql/sql_injection.asp).

## Приёмы работы с параметрами

Как мы выяснили выше, для защиты от инъекций следует исключить попадание непроверенной информации в движок БД извне. Несложно прийти к выводу, что, исключив на стороне сервера из наших вредоносных запросов всего один специальный символ — одиночную кавычку — мы избавились бы от уязвимости. К примеру, запрос:  

```sql
SELECT * FROM orders WHERE destination = 'London'; drop table orders -- '
```  

превратился бы в "безобидный":  

```sql
SELECT * FROM orders WHERE destination = 'London; drop table orders -- ''
```

Замена специальных (управляющих) символов на их строковые представления называется экранированием. Обычно, экранируемый спецсимвол предваряется обратной косой чертой \, и результирующая последовательность будет интерпретирована как простой текст. Конечно, в действительности экранированию подлежат и другие спецсимволы, такие как двойные кавычки, и сама по себе обратная косая черта — тоже.  

Для защиты от более изощрённых методов атаки одного лишь экранирования недостаточно. Здесь потребуется валидация параметров (проверка их на соответствие типу, размеру, формату, граничным значениям), удаление из строковых параметров Escape-последовательностей и фрагментов команд. В частности, если мы ожидаем числовой параметр запроса (идентификатор пользователя или страницы), следует отфильтровывать всё, кроме цифр; а если мы ожидаем строковое значение (название города или имя пользователя), целесообразно ввести некоторое ограничение длины этого значения и усекать принимаемый параметр соответственно. 

Разумеется, разработчики разнообразных фреймворков осведомлены и об атаках, и о способах противодействия, вследствие чего реализовывают встроенные средства защиты. В общем случае, нет никакой необходимости изобретать собственный разносторонний механизм валидации параметров в разрабатываемом приложении, взамен следует применять как раз встроенные механизмы конструирования запросов. Например, в C# используется свойство Parameters класса SqlCommand:  

```csharp
using Microsoft.Data.SqlClient;

string cityname = ""; //хранит небезопасное значение параметра запроса
string sqlexpression = "SELECT * FROM orders WHERE destination = @City";

using (SqlConnection connection = new SqlConnection(connectionString))
{
  connection.Open();
  SqlCommand command = new SqlCommand(sqlExpression, connection);
  //создаём новый параметр команды и добавляем его в коллекцию параметров
  command.Parameters.Add(new SqlParameter("@City", cityname));
  SqlDataReader reader = command.ExecuteReader();
  if (reader.HasRows)
  {
    //... обработка данных ...
  }
  reader.Close();
}
```

А фреймворк Dapper поддерживает передачу анонимных типов параметров:  

```csharp
var result = connection.Query(sqlexpression, new { City = cityname })
```

Аналогичные средства предоставляют и другие языки (фреймворки). Посмотреть некоторые примеры параметризации можно в [OWASP Query Parameterization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html).

Напоследок отметим, что в борьбе с любыми уязвимостями полезно максимально возможное ограничение прав учетных записей на сервере, используемых для работы с БД, и ограничение выдаваемой «наружу» информации в случае возникновения ошибок и сбоев. Последнее в особенности важно для противодействия Error-based SQLi.

## Проверка на наличие уязвимости

Простейший и популярнейший способ обнаружения SQL-инъекций — подстановка специальных символов (напр. одиночной кавычки или точки с запятой) в доступные поля пользовательского ввода, и анализ поведения веб-сервера. Помимо полей ввода, следует обратить внимание на адресную строку браузера при переходе по ссылками и других действиях с веб-приложением — ведь при этих действиях также могут передаваться запросы с уязвимыми параметрами.  

Как показано выше, в уязвимом приложении наличие спецсимвола в параметре запроса приведёт к возникновению ошибки. Соответственно, цель проверки — найти такое поле, спецсимвол в котором вызовет непредвиденное поведение приложения.  

Не лишним будет упомянуть, что ошибка сервера может и не быть отображена в интерфейсе тестируемого приложения, однако при этом её иногда можно увидеть в исходном коде генерируемой веб-страницы.  

Разработаны и автоматизированные инструменты тестирования, например [SQLMap](https://sqlmap.org/), [jSQL Injection](https://www.kali.org/tools/jsql/), NoSQLMap для NoSQL БД. Обширная информация по тестированию включена в состав OWASP Web Security Testing Guide [WSTG-INPV-05]( https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection.html)

## Заключение

SQL Injection — это атака, суть которой заключается во внедрении произвольных команд в легитимный запрос к веб-серверу, что и дает её название. Если данный сервер уязвим (т.е. не вполне корректным образом обрабатывает запросы), такие команды могут быть выполнены.  

Среди опасных последствий SQL-инъекций можно упомянуть: 
- Раскрытие хранящихся на сервере данных, в том числе конфиденциальной и чувствительной информации
- Нарушение целостности данных хранящихся на сервере данных, включая несанкционированное изменение и удаление информации
- Получение несанкционированного доступа к скомпрометированной системе. Это, в свою очередь, может привести к несанкционированным раскрытию или модификации данных, хранящихся на сервере.  

Для исключения уязвимости ключевую роль играет правильность обработки параметров запроса в коде приложения. Современные языки или фреймворки предоставляют соответствующие механизмы безопасного построения параметризованных запросов, которые подлежат обязательному использованию разработчиком. В данной статье не рассматриваем эти механизмы в подробностях из-за многочисленности реализаций. На самом деле, важно понимать, что лежит в основе — а детали будут проиллюстрированы в документации соответствующего фреймворка.  

Кстати, помимо SQL, существуют и другие типы инъекций родственной природы: NoSQL injection (направлена на NoSQL БД), ORM injection (направлена на ORM-прослойки между сервером и БД), shell injection (внедрение в запрос команд операционной системы) и прочие. Мы также оставляем их за рамками данной статьи для сохранения её объёма в границах приличия.  

В качестве источника дальнейшей информации можно обратиться к:

- Описание атаки на сайте [OWASP](https://owasp.org/www-community/attacks/SQL_Injection) и [Лаборатории Касперского](https://www.kaspersky.ru/resource-center/definitions/sql-injection)
- Информация о защите [Microsoft](https://learn.microsoft.com/en-us/sql/relational-databases/security/sql-injection?view=sql-server-ver15) и [PHP Group](https://www.php.net/manual/ru/security.database.sql-injection.php)
