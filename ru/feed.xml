<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:yandex="http://news.yandex.ru"
     xmlns:media="http://search.yahoo.com/mrss/"
     xmlns:turbo="http://turbo.yandex.ru"
     version="2.0">
    <channel>
        <title>Hexlet Guides</title>
        <link>https://guides.hexlet.io/</link>
        <description>Полезные статьи и гайды для разработчиков
</description>
        <language>ru</language>
        <!-- <turbo:analytics></turbo:analytics> -->
        <!-- <turbo:adNetwork></turbo:adNetwork> -->
        
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/cryptography/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое криптография?</turbo:topic> -->
            <title>Что такое криптография?</title>
            <pubDate>Wed, 18 May 2022 00:00:00 +0000</pubDate>
            <author>Василий Васильев</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/cryptography/">Что такое криптография?</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/cryptography/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Это может быть не очевидно, но мы сталкиваемся с криптографией каждый день. Например, когда мы оплачиваем покупки картой, смотрим видео на YouTube или заправляем машину, криптография защищает нашу информацию. Может показаться, что криптография – это удел разработчиков, хакеров и корпораций, а простому пользователю знать о ней вовсе не обязательно. Однако это полезно не только узким специалистам, но и всем, кто заботится о собственной безопасности. Этот гайд поможет разобраться, что такое криптография и какое применение она находит в повседневной жизни.</p>

<h3 id="как-появилась-криптография">Как появилась криптография?</h3>

<p>С момента зарождения человеческой цивилизации информация была одним из наших самых ценных активов. Уже много тысячелетий назад наши предки столкнулись с необходимостью передавать информацию в пространстве (из точки А в точку Б) или во времени (например, от учителя к ученикам). Письменность помогла решить эту задачу, однако следом возникла следующая: как сохранить передаваемую информацию от глаз тех, к кому она попасть не должна?</p>

<p>Примерно 3500 лет назад гончары в Месопотамии защищали секреты своего мастерства от конкурентов с помощью шифрования на глиняных табличках. Политики шифровали свои послания, чтобы сохранить их в тайне.</p>

<p>Как выглядел этот шифр? Разберем на примере:</p>

<p>Допустим, нам нужно зашифровать сообщение «Привет». Один из путей — сдвигать буквы алфавита на фиксированное число позиций. Такой метод называется шифр сдвига или <strong>шифр Цезаря</strong>.</p>

<p>На рисунке ниже показан сдвиг на две буквы вперд.</p>

<p><img src="/assets/images/cryptography/alphabet.png" alt="alphabet" /></p>

<p>Сдвиг на две буквы означает, что:</p>

<p>А ⇒ В
Б ⇒ Г
В ⇒ Д</p>

<p>Сообщение «Привет» превращается в «Сткджб».</p>

<p>Шифр можно улучшить, применив более продвинутый метод. Представим, что после каждого использования алгоритм шифрования меняется, то есть повторное сообщение с такой же информацией будет выглядеть совершенно по-другому. Проще говоря, если в первом случае мы получили «Сткджб», то следом то же слово будет зашифровано как «Опздбдс»: теперь сдвиг произошел на одну букву назад.</p>

<h2 id="современные-методы-криптографии">Современные методы криптографии</h2>

<p>Современная криптография совсем не похожа на перестановку букв. Для шифрования и безопасной передачи данных используются алгоритмы, которые невозможно «разгадать». Речь идет об алгоритмах, основанных на математических преобразованиях — работать с ними способен только компьютер. Карандашом и листком бумаги уже не обойтись. Чаще всего используются три криптографических метода, каждый из которых имеет преимущества и недостатки. Рассмотрим каждый из них.</p>

<h3 id="симметричная-криптография">Симметричная криптография</h3>

<p>Один из самых простых типов шифрования. Симметричная криптография использует секретный ключ, который может быть числом, словом или строкой случайных символов для шифрования и расшифровки данных. Единственный ключ известен как отправителю, так и получателю. Это один из старейших и наиболее распространенных методов шифрования.</p>

<p>Этот метод обычно не используется для передачи сообщений через интернет, так как ключ необходимо передавать отдельно. Если третья сторона каким-то образом получит ключ, она сможет просмотреть зашифрованные данные.</p>

<p>Получается уловка-22: если вы хотите отправить зашифрованное сообщение, чтобы его содержимое было скрыто от посторонних глаз, вам придется сначала отправить незашифрованное сообщение, которое будет полностью видно. Это делает данный метод крайне небезопасным.</p>

<p>Именно поэтому симметричная криптография обычно используется для шифрования локальных баз данных, например, на жестком диске сервера или данных в вашем iPhone.</p>

<h3 id="асимметричное-шифрование">Асимметричное шифрование</h3>

<p>Метод шифрования данных, в котором используются два ключа — открытый и закрытый. Открытый или «публичный» ключ используется для шифрования информации и может передаваться по незащищенным каналам. Закрытый или «приватный» ключ используется для расшифровки данных, зашифрованных с помощью открытого ключа. Открытый и закрытый ключи — это очень большие числа, связанные определенной функцией, но таким образом, что если вы знаете один ключ, то вычислить другой крайне сложно.</p>

<p>Асимметричное шифрование решает основную проблему безопасности симметричного шифрования, когда для шифрования и получения данных используется один и тот же ключ. С другой стороны, асимметричные алгоритмы намного медленнее симметричных, поэтому часто используются оба метода.</p>

<h3 id="хеширование">Хеширование</h3>

<p>Отдельно выделим метод, который преобразовывает информацию в уникальный набор символов, но не шифрует данные. По сути, хеширование — это изменение сообщения в нечитаемую строку не для того, чтобы скрыть сообщение, а для проверки его содержимого. Чаще всего он используется при передаче больших файлов.</p>

<p>Допустим, нам нужно обновить программное обеспечение на компьютере. Хеширование — хороший способ проверки загружаемых файлов, файлов Windows (.ISO) или Mac (.DMG). Когда мы скачиваем обновление, вместе с файлом мы получаем хеш от этого файла. Наш компьютер хеширует скачанный файл еще раз и сравнивает хеши (полученный и скачанный): если они совпадают, значит, мы получили неповрежденный файл. Даже самое незначительное изменение загруженного файла, вызванное повреждением или намеренным вмешательством, резко изменит полученный хеш. Только после проверки целостности компьютер может продолжить работу с файлом.</p>

<h2 id="принципы-криптографии">Принципы криптографии</h2>

<p>Задача криптографии — обеспечить защиту информации. Она основана на четырех принципах:</p>

<h3 id="аутентификация">Аутентификация</h3>

<p>Проще говоря, — это процесс, обеспечивающий уверенность в том, что стороны на обоих концах соединения действительно являются теми, за кого себя выдают.</p>

<p>По крайней мере один тип аутентификации используется в интернете всякий раз, когда вы пользуетесь защищенным веб-сайтом. Например, внутренним сайтом вашей компании или, например, сайтом Hexlet.</p>

<p>В зависимости от используемого браузера пользователь в увидит закрытый замок или зеленый URL (или и то, и другое), указывающий на то, что сайт, к которому он подключен, является тем сайтом, за который себя выдает.</p>

<p><img src="/assets/images/cryptography/hexlet.png" alt="hexlet" /></p>

<p>Это особенно важно, когда мы совершаем покупки в Интернете, делаем банковские операции или оплачиваем счета через Интернет. Это гарантирует, что мы не передадим хакерам информацию о своих банковских счетах или кредитных картах.</p>

<p>Другим примером использования криптографии для аутентификации является Pretty Good Privacy — пакет бесплатного программного обеспечения. Он используется для шифрования и аутентификации сообщений, цифровых подписей, сжатия данных, а также электронных писем и их вложений.</p>

<h3 id="неотказуемость-от-англnon-repudiation">Неотказуемость (от англ. non-repudiation)</h3>

<p>Эта концепция особенно важна для тех, кто использует или разрабатывает финансовые приложения или приложения для электронной коммерции.</p>

<p>На заре развития финансовых операций и электронной коммерции в интернете одной из серьезных проблем была повсеместная распространенность пользователей, которые могли опровергнуть транзакции после того, как совершали ее. Например, клиент банка просит перевести деньги на другой счет. Позже он заявляет, что никогда не делал этого запроса, и требует вернуть всю сумму на его счет.</p>

<p>Однако если банк принял меры по обеспечению безопасности с помощью криптографии, он может доказать, что данная транзакция действительно была инициирована пользователем.</p>

<h3 id="целостность">Целостность</h3>

<p>Криптография помогает убедиться, что данные не были просмотрены или изменены во время передачи или хранения.</p>

<p>Например, использование криптографической системы для обеспечения целостности данных гарантирует, что конкурирующие компании не смогут подделать внутреннюю переписку и конфиденциальные данные конкурента.</p>

<p>Наиболее распространенным способом обеспечения целостности данных с помощью криптографии является использование криптографических хешей, о которых говорилось выше.</p>

<h3 id="конфиденциальность">Конфиденциальность</h3>

<p>В условиях постоянных утечек информации и бесконечного числа скандалов, связанных с конфиденциальностью, сохранение частной информации является одной из главных задач для криптографии. Именно с целью защиты информации и были изначально разработаны криптографические системы.</p>

<p>С помощью правильных инструментов шифрования пользователи могут защитить конфиденциальные данные компании, личные переписки или просто заблокировать свой компьютер простым паролем.</p>

<p>Однако в современных условиях такие методы не смогут обеспечить безопасность огромных систем электронных коммуникаций или торговли. Теперь приходится работать не только с частными случаями хранения или передачи информации, но и с огромными объемами данных.</p>

<h2 id="как-обычным-пользователям-использовать-криптографию">Как обычным пользователям использовать криптографию?</h2>

<p>Как говорилось в начале статьи, криптография — часть повседневной жизни. Оплата покупки картой или простое подключение к Wi-Fi требуют использования криптографии.</p>

<p>Хотя большинство операций в повседневной жизни уже защищены криптографией,  существуют области, в которых можно сравнительно легко докупить еще один уровень безопасности к повседневным действиям.</p>

<h3 id="vpn">VPN</h3>

<p>Виртуальная частная сеть (VPN) шифрует интернет-соединение, не позволяя посторонним следить за вашей деятельностью в Интернете.</p>

<p>VPN заключает интернет-соединение в «туннель» шифрования, который действует подобно туннелю метро. Хотя мы можем знать, что в туннеле есть поезда, мы не сможем определить, где они находятся, сколько вагонов в составе и куда он направляется.</p>

<p><strong>Виртуальная</strong> – означает, что VPN создаётся программным способом в виде отдельной прослойки поверх другой сети. Для передачи данных используется туннелирование — трафик заворачивается в отдельный туннель, который проходит по более низкоуровневому каналу связи. Информация в VPN-туннеле надёжно зашифрована.
<strong>Частная</strong> – VPN – внутренняя сеть, в которой находятся только доверенные устройства.
<strong>Сеть</strong> – соединение происходит между двумя устройствами — клиентом и VPN-сервером, образующими единую сеть.</p>

<p>VPN обеспечивает защиту — никто не сможет узнать, какие сайты посещает пользователь или какие файлы скачивает.</p>

<p>В последнее время VPN стали популярным инструментом для пользователей, которые хотят защитить свои действия в интернете от постороннего наблюдения.</p>

<h3 id="https">HTTPS</h3>

<p>Страницы HTTPS обычно используют протокол SSL (Secure Sockets Layer) или TLS (Transport Layer Security) для повышения безопасности страниц, которые просматривает пользователь, с помощью открытых ключей.</p>

<p>Этот тип соединения шифрует сообщения, отправляемые между вашим компьютером и просматриваемым сайтом, чтобы защитить данные пользователя от хищения. 
Это очень важно, когда вы передаете важную личную информацию или финансовые данные.</p>

<p>HTTPS — это расширение браузера с открытым исходным кодом, совместимое с Chrome, Firefox и Opera. С помощью этого расширения любой сайт, который вы посещаете, будет вынужден использовать соединение HTTPS вместо менее безопасного соединения HTTP.</p>

<h3 id="bitlocker-for-windows-or-filevault2-for-mac">BitLocker (for Windows) or FileVault2 (for Mac)</h3>

<p>Дополнительный шаг (помимо пароля для входа в систему) для обеспечения безопасности личной информации на компьютере или ноутбуке — это установка <a href="https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview">BitLocker</a> или <a href="https://support.apple.com/en-us/HT204837">FileVault2</a>.</p>

<p>Эти программы шифрования дисков защищают данные с помощью криптографического алгоритма AES, обеспечивая шифрование целых томов. Если выбирать это программное обеспечение, обязательно нужно записать свои учетные данные и храните их в надежном месте. Если эти учетные данные будут утеряны, то почти наверняка навсегда будет утерян и доступ ко всей зашифрованной информации.</p>

<h2 id="криптография-не-совершенна">Криптография не совершенна</h2>

<p>Мы разобрались, как работает криптология и как она защищает данные. Хотя криптография, безусловно, может обеспечить защиту информации, она не может обеспечить полную безопасность. Даже самые лучшие криптографические алгоритмы несовершенны.</p>

<p>Поэтому стоит осознавать, что «более безопасно» не означает «абсолютно безопасно».</p>

<h2 id="заключение">Заключение</h2>

<p>Благодаря более глубокому пониманию распространенных методов шифрования и криптографических алгоритмов, используемых сегодня, мы сможем лучше защитить себя от потенциальных кибератак.</p>

<p>Существует множество способов использования криптографии и, возможно, лучшим способом обеспечить надежный уровень шифрования для действий в интернете является использование качественного VPN.</p>

<p>Хотя криптография не совершенна, она необходима для обеспечения безопасности личной информации.</p>

<h2 id="другие-гайды-по-теме">Другие гайды по теме</h2>

<ol>
  <li><a href="https://guides.hexlet.io/ru/http-api/">Что такое API?</a></li>
</ol>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/dynamic-programming/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое динамическое программирование</turbo:topic> -->
            <title>Что такое динамическое программирование</title>
            <pubDate>Tue, 19 Apr 2022 00:00:00 +0000</pubDate>
            <author>Валерий Жила</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/dynamic-programming/">Что такое динамическое программирование</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/dynamic-programming/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Работу разработчика часто можно сравнить с решением головоломок. Как в настоящей головоломке, разработчику приходится тратить существенные ресурсы не столько на реализацию конкретного решения, сколько на выбор оптимального подхода. Иногда задача решается легко и эффективно, а порой — только полным перебором всех возможных вариантов. Такой подход часто называют наивным решением. Он имеет существенный минус — временные затраты.</p>

<p>Представим хакера, который пытается взломать какой-то пароль перебором всех комбинаций символов. Если пароль допускает 10 цифр, 26 маленьких букв, 26 больших букв и 32 специальных символа (например, значок доллара), то для каждого символа в пароле есть 94 кандидата. Значит, чтобы взломать перебором пароль, состоящий из одного символа, потребуется 94 проверки. Если в пароле два символа — 94 кандидата на первую позицию, 94 кандидата на вторую позицию — то придется перебрать аж 94*94 = 8836 возможных пар. Для пароля из десяти символов потребуется уже перебор 94^10 комбинаций.</p>

<p>Если обобщить, то для взлома пароля с произвольной длиной N требуется O(94^N) операций. Такие затраты часто называют «экспоненциальными»: появление каждой новой позиции влечёт за собой увеличение количества операций в 94 раза. Взлом пароля может показаться чем-то экзотическим, но задачи, требующие полного перебора всех вариантов — совсем не экзотика, скорее угрюмая реальность.</p>

<p>Экспоненциальное время — это долго. Даже O(2^N) — это просто непозволительно долго. Настолько долго, что никому и в голову не придет запустить подобный алгоритм даже на простых данных — ведь на решение такой задачи с сотней элементов потребуются тысячи, миллионы или миллиарды лет вычислений. А в реальной жизни нужно решать задачи с намного большим количеством элементов. Как же быть?</p>

<p>Дело в том, что многие задачи без эффективного алгоритма решения можно решить за привлекательное время с помощью одной хитрости — динамического программирования.</p>

<h2 id="динамическое-программирование">Динамическое программирование</h2>

<p>Динамическое программирование — это особый подход к решению задач. Не существует какого-то единого определения динамическому программированию, но все-таки попробуем её сформировать. Идея заключается в том, что оптимальное решение зачастую можно найти, рассмотрев все возможные пути решения задачи, и выбрать среди них лучшее.</p>

<p>Работа динамического программирования очень похожа на рекурсию с запоминанием промежуточных решений — такую рекурсию еще называют мемоизацией. Рекурсивные алгоритмы, как правило, разбивают большую задачу на более мелкие подзадачи и решают их. Динамические алгоритмы делят задача на кусочки и вычисляют их по очереди, шаг за шагом наращивая решения. Поэтому динамические алгоритмы можно представить как рекурсию, работающую сниз увверх.</p>

<p><img src="/assets/images/dynamic_programming/recursion_vs_dynamic_prog.png" alt="recursion_vs_dynamic_prog" /></p>

<p>Магия динамического программирования заключается в умном обращении с решениями подзадач. «Умный» в этом контексте значит «не решающий одну и ту же подзадачу дважды». Для этого решения мелких подзадач должны где-то сохраняться. Для многих реальных алгоритмов динамического программирования этой структурой данных является таблица.</p>

<p>В самых простых случаях эта таблица будет состоять только из одной строки — аналогично обычному массиву. Эти случаи будут называться одномерным динамическим программированием, и потреблять O(n) памяти. Например, алгоритм эффективного вычисления чисел Фибоначчи использует обычный массив для запоминания вычисленных промежуточных результатов. Классический рекурсивный алгоритм делает очень много бессмысленный работы — он по миллионному разу рассчитывает то, что уже было рассчитано в соседних ветках рекурсии.</p>

<p>В самых распространённых случаях эта таблица будет выглядеть привычно и состоять из строчек и столбиков. Обычная таблица, похожая на таблицы из Excel. Это называется двумерным динамическим программированием, которое при n строках и n столбцах таблицы потребляет O(n*n) = O(n^2) памяти. Например, квадратная таблица из 10 строк и 10 столбцов будет содержать 100 ячеек. Чуть ниже будет подробно разобрана именно такая задача.</p>

<p>Бывают и более запутанные задачи, использующие для решения трехмерные таблицы, но это редкость — решение задачи с использованием трехмерной таблицы зачастую просто нельзя себе позволить. Небольшая двухмерная таблица на 1024 строки и 1024 столбца может потребовать несколько мегабайт памяти. Трехмерная таблица с такими же параметрами будет занимать уже несколько гигабайт.</p>

<p><img src="/assets/images/dynamic_programming/1d_vs_2d_vs_3d.png" alt="1d_vs_2d_vs_3d" /></p>

<p>Что нужно, чтобы решить задачу динамически, помимо ее исходных данных? Всего три вещи:</p>

<ul>
  <li>Таблица, в которую будут вноситься промежуточные результаты. Один из них будет выбран в конце работы алгоритма в качестве ответа</li>
  <li>Несколько простых правил по заполнению пустых ячеек таблицы, основанных на значениях в уже заполненных ячейках. Универсального рецепта тут нет и к каждой задаче требуется свой подход</li>
  <li>Правило выбора финального решения после заполнения таблицы</li>
</ul>

<p>Разберем эти принципы на примере.</p>

<h2 id="пример-решения-задачи">Пример решения задачи</h2>

<p>Демонстрационным подопытным выступит классическая задача динамического программирования — Расстояние Левенштейна. Несмотря на кажущееся сложным название, в действительности это задача о трансформации одного слова в другое путем добавления, удаления и замены букв с минимальным количеством операций.</p>

<p>Эта задача может быть сформулирована так: найти минимальное «расстояние» между двумя словами. Расстоянием в этом случае будет минимальное количество операций, которые нужно применить к первому слову, чтобы получить второе (или наоборот).</p>

<p>Доступных операции у нас три:</p>

<ul>
  <li>insert — добавить одну букву в любое место в слове, в том числе в самое начало и в конец</li>
  <li>delete — удалить одну букву из любого места в слове</li>
  <li>replace — заменить одну букву в определенном месте на другую букву</li>
</ul>

<p>Все эти операции имеют равную стоимость: +1 к расстоянию между словами.</p>

<p>Возьмем для примера два простых слова, MONEY и MONKEY. Какое минимальное количество операций необходимо, чтобы превратить MONEY в MONKEY? Находчивый человеческий глаз быстро смекнет, что одна: добавить букву K после между третьей и четвертой буквой.</p>

<p>Возьмем случай посложнее. Попробуем превратить слово SUNDAY в слово SATURDAY, и увидим, что количество комбинаций, которые нужно перебрать, потенциально очень велико. Если решать задачу перебором, то можно рассмотреть все возможные комбинации, как в примере со взломом пароля. Вместо возможных 94 символов-кандидатов у нас есть три операции — insert, delete, replace. Три комбинации для первой буквы, 3*3 для двух букв, 3*3*3 для трех букв, 3^N для N букв. Комбинаторный взрыв.</p>

<h3 id="динамическое-решение">Динамическое решение</h3>

<p>Приступим к динамическому решению. Для начала, создадим таблицу и разместим исходные слова на ее краях, оставив немного свободного места. Второй столбик и вторую строчку буем использовать для пустых строк — их часто обозначают символом ε, читается epsilon. Аналог того, что вы имеете в виду, когда используете пустую строку на своем языке программирования: String eps = “”.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">U</th>
      <th style="text-align: center">R</th>
      <th style="text-align: center">D</th>
      <th style="text-align: center">A</th>
      <th style="text-align: center">Y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>N</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>D</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>A</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Y</strong></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>Теперь заполним второй столбик и вторую строчку, руководствуясь абсолютно интуитивными соображениями: как превратить пустую строку в какую-то строку? Конечно же, добавить в нее нужные символы! Например, чтобы перевести ε в SATU, необходимо добавить букву S, букву A, букву T и букву U. Четыре операции. Что делать с превращением ε в ε (вторая строка, второй столбец)? Элементарно — ничего делать не нужно, ноль действий.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">U</th>
      <th style="text-align: center">R</th>
      <th style="text-align: center">D</th>
      <th style="text-align: center">A</th>
      <th style="text-align: center">Y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">8</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>N</strong></td>
      <td style="text-align: center">3</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>D</strong></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>A</strong></td>
      <td style="text-align: center">5</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Y</strong></td>
      <td style="text-align: center">6</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>Теперь нужна система простых правил, с помощью которой мы сможем заполнить таблицу. Таблица будет именоваться D, а первая строчка и столбик останутся на ее полях. Работать с таблицей мы будем, как с двухмерным массивом: D[0, 2] означают ячейку на пересечении нулевой строки и второго столбика. В нашем примере D[0, 2] = 2.</p>

<p>Также назовём слово по вертикали A, а слово по горизонтали B. Эта парочка нам нужна, чтобы иметь доступ к оригинальным словам на полях. Из-за дополнительных колонок в для ε индексы в A и B отличаются от индексов в таблице. Если быть точнее — они сдвинуты на единицу. A[0] = S, A[1] = U, A[2] = N, B[7] = Y, и так далее.</p>

<p>Наконец, создадим наше правило заполнения таблицы. Для каждой новой ячейки мы проверяем верхнюю, левую или лево верхнюю по диагонали соседние ячейки. Из трех чисел будет выбрано наименьшее и записано в новую ячейку.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>D[i, j] = minimum(
	D[i-1, j] + 1,                              // delete
	D[i, j-1] + 1,                              // insert 
	D[i-1, j-1] + (A[i-1] == B[j-1] ? 1 : 0)    // replace 
)  
</code></pre></div></div>

<p>Это важный момент в динамическом программировании: правила кажутся бессмысленными, а собрать общую картину происходящего в голове сложно. Давайте посмотрим на маленький кусочек таблицы — возможно, он прольет свет на некоторые детали.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>Что следует записать в ячейку D[1,1] как результат перехода из S в S? Интуитивно ясно, что для этого ничего делать и не нужно, ноль операций. Запишем в ячейку ноль. На что похоже это значение, учитывая, что вычитать ничего нельзя? Среди соседей ноль есть только по диагонали.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>Что записать в ячейку D[2,1] как результат перехода из SU в S? Нужно удалить букву U — значит, это одна операция. По-сути, стоимость перехода из SU в S будет равно стоимости удаления буквы U и перехода из S в S (чья стоимость уже была посчитана и лежит в ячейке D[1,1]).</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>Теперь посмотрим на ячейку D[1,2], переход из S в SA. Да, именно, стоимость перехода будет равна стоимости добавления буквы A и перехода из S в S, итого единица.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>Последняя ячейка, D[2,2], переход из SU в SA. Самым оптимальным решением было бы заменить букву U на букву A, плюс цена бесплатного перехода из S в S.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p>В самой правой нижней ячейке содержится финальная стоимость перехода из слова SU в слово SA. Аналогичным образом можно заполнить всю таблицу. Из ячейки D[6,8] мы узнали, что переход из слова SUNDAY в слово SATURDAY стоит минимум три операции. Жирным шрифтом выделим оптимальный путь.</p>

<p>Давайте проследим его по шагам. Переход из S в S ничего не стоит. Переход из S в SA стоит одну операцию. Переход из S в SAT стоит две операции. Переход из SU в SATU стоит две операции. Переход из SUN в SATUR стоит три операции. Переход из SUND в SATURD стоит три операции (стоимость предыдущего перехода плюс нулевая цена перехода из D в D). Переход из SUNDA в SATURDA стоит три операции. Наконец, переход из SUNDAY в SATURDAY требует тех же трёх операций.</p>

<p>Кстати, если присмотреться к таблице, можно заметить, что оптимальных решений несколько: из D[1,2] можно перейти как в D[1,3], так и в D[2,2]. В этой постановке задачи нас интересует только минимальное количество, а не список всех возможных путей решения, так что это не существенно.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">ε</th>
      <th style="text-align: center">S</th>
      <th style="text-align: center">A</th>
      <th style="text-align: center">T</th>
      <th style="text-align: center">U</th>
      <th style="text-align: center">R</th>
      <th style="text-align: center">D</th>
      <th style="text-align: center">A</th>
      <th style="text-align: center">Y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>ε</strong></td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
      <td style="text-align: center">8</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>S</strong></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"><strong>0</strong></td>
      <td style="text-align: center"><strong>1</strong></td>
      <td style="text-align: center"><strong>2</strong></td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">7</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>U</strong></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center"><strong>2</strong></td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>N</strong></td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center"><strong>3</strong></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">6</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>D</strong></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><strong>3</strong></td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>A</strong></td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><strong>3</strong></td>
      <td style="text-align: center">4</td>
    </tr>
    <tr>
      <td style="text-align: center"><strong>Y</strong></td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">5</td>
      <td style="text-align: center">4</td>
      <td style="text-align: center"><strong>3</strong></td>
    </tr>
  </tbody>
</table>

<p>Вот так, собственно, и выглядит большинство решений из мира динамического программирования. Кстати, это решение имеет название — алгоритм Вагнера-Фишера. Забавный факт: этот алгоритм практически параллельно опубликовали разные группы незнакомых ученых с разных концов планеты в эпоху, когда еще не был интернета. Товарищи Вагнер и Фишер, кстати, были далеко не первыми.</p>

<p>Давайте теперь рассмотрим, в чем отличия приеменения этого алгоритма от решения перебором.</p>

<h3 id="анализ-решения">Анализ решения</h3>

<p>Как уже было сказано, решение перебором этой задачи простой рекурсией имеет временную сложность O(3^n), но не требует лишней памяти — значит, O(1) операций в памяти.</p>

<p>Какие издержки у динамического решения? Давайте представим, что сравниваются слова равной длины, по n символов в слове. Все решение сводится к заполнению таблицы с n+1 строчками (отдельная для пустой строки ε), и n+1 столбиками. Значит, используется (n+1)^2 ячеек. Не будем считать копейки, и округлим количество ячеек до n^2. Для каждой ячейки мы будем проверять трех ее соседей, что требует константного времени O(1). Значит, на заполнение всей таблицы потребуется O(n^2) операций.</p>

<p>Какой будет расход памяти? Для таблицы с n^2 ячеек нам нужно O(n^2) памяти.</p>

<p>Если слова разной длины, то можно либо смотреть по самому длинному, либо несколько повысить степень сложности формулы. Например, если первое слово имеет длину n, а второе — m, то потребуется O(nm) времени и O(nm) памяти.</p>

<h2 id="итог">Итог</h2>

<p>Основная идея динамического программирования должна прослеживаться в представленном примере: мы жертвуем солидным количеством памяти (O(nm) вместо O(1)), но получаем просто сумасшедший выигрыш во времени (O(nm) против O(3^n)).</p>

<p>Перечислим все ключевые особенности динамического программирования.</p>

<p><strong>Преимущества</strong>:</p>

<ul>
  <li>
    <p><strong>Скорость</strong>. Главное достоинство динамического программирования. Нерешаемые задачи становятся решаемыми, в большинстве случаев — за квадратичное время! Одна операция на заполнение каждой ячейки таблицы — и вопрос закрыт.</p>
  </li>
  <li>
    <p><strong>Универсальность</strong>.  One Ring to rule them all — создание компактной системы из нескольких правил для заполнения таблицы гарантирует решение задачи на любых данных. Ни исключений, ни пограничных случаев, несколько строчек, — и сложная проблема решена.</p>
  </li>
  <li>
    <p><strong>Точность</strong>. Поскольку алгоритм динамического программирования рассматривает абсолютно все возможные варианты и сценарии, он гарантированно обнаружит самое оптимальное решение. Никакой потери точности, никаких приблизительных ответов. Если решение существует — оно будет найдено.</p>
  </li>
</ul>

<p><strong>Недостатки</strong>:</p>

<ul>
  <li>
    <p><strong>Память</strong>. В большинстве случаев алгоритмы динамического программирования требуют времени на построение и заполнение таблиц. Таблицы потребляют память. Это может стать проблемой: в случае, если сами таблицы очень большие, или если для решения какой-то задачи нужно построить очень много таких таблиц и держать их всех в памяти.</p>
  </li>
  <li>
    <p><strong>Когнитивная нагрузка</strong>. Решение запутанной задачи с помощью компактной система правил — очень заманчивая идея. Но тут есть один нюанс: для составления или хотя бы для понимания этих систем правил необходимо научиться «думать на динамическом программировании». Это является причиной довольно спорной репутации динамического программирования.</p>
  </li>
</ul>

<h2 id="области-применения">Области применения</h2>

<p>Динамическое программирование — не теоретическая конструкция, которая не выходит за рамки научных работ. Оно пользуется популярностью во многих прикладных областях. Их достаточно много: прикладная математика, машиностроение, теории управления или прогнозирование финансовых данных. Но мы остановимся на одной — на биоинформатике.</p>

<p>Ученые в этой области занимаются «оцифровыванием» биологического материала, а так же хранением и анализом полученной информации. В этой науке сотни захватывающих аспектов, и она ставит перед разработчиками очень серьезные задачи, ведь данных невероятно много. Например, в геноме человека около трех миллиардов пар нуклеотидов (кирпичиков ДНК). Одна пара обычно кодируется одним байтом, в итоге выходит около трех миллиардов байт информации на один-единственный геном — три гигабайта данных на одно человека.</p>

<p>Один геном не создает серьезных проблем, но геномы сами по себе малоинтересны: чтобы обнаружить мутации в геноме конкретного человека, нужно сначала «выровнять» его с другими, референсными геномами (выровненными и размеченными заранее). Возможных вариантов этого выравнивания может быть огромное количество, но нужно найти самый правдоподобный из них. То есть вариант, у которого максимальная вероятность возникновения. Например, вариант с наименьшим количеством мутаций. Если принять во внимание, что генетический код обычно хранятся в виде очень длинных строк, состоящих из разных букв, то пример с Расстоянием Левенштейна начинает играть новыми красками. Эта задача, потенциально приводящая к комбинаторному взрыву (прямо как перебор всех комбинаций символов для взлома пароля), замечательно решается методами динамического программирования!</p>

<p>Если интересно, почитайте про <a href="https://en.wikipedia.org/wiki/Multiple_sequence_alignment#Dynamic_programming">Multiple Sequence Alignment (MSA)</a></p>

<p>Это только один пример. Биоинформатика буквально живет динамическим программированием — вот еще несколько примеров:</p>

<ul>
  <li>Построение молекулярных деревьев для опеределения последовательности эволюционных изменений</li>
  <li>Эффективный перевод генетической информации (например, из кусочка кожи) в длинную строку в базе данных</li>
</ul>

<p>Если 15 лет назад полное считывание генома (секвенирование) имело себестоимость в десятки миллионов долларов, то сегодня эта услуга стоит одну-две тысячи долларов, и постепенно дешевеет. Этот скачок произошел не столько за счет роста вычислительных мощностей, сколько за счет появления эффективных алгоритмов.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/numeral-systems/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Системы счисления</turbo:topic> -->
            <title>Системы счисления</title>
            <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
            <author>Марк Шевченко</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/numeral-systems/">Системы счисления</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/numeral-systems/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>В этом гайде разберемся, что такое системы счисления, для чего программисты используют непривычные способы для записи чисел и как их понимать.</p>

<h2 id="что-такое-системы-счисления">Что такое системы счисления</h2>

<p>С давних пор людям нужно было записывать числа. В торговле числа нужны, чтобы знать, сколько товаров есть на складе и сколько денег принесла сделка. Записи о положении небесных тел помогли шумерам составить первый календарь, а календарь, в свою очередь, пригодился, чтобы заранее готовиться к посевным и сбору урожая. Строительные сметы, переписи населения, распределение наследства — числа оказались очень востребованными даже в самых древних государствах.</p>

<p>Так что люди научились записывать числа в незапамятные времена. Небольшие числа легко записывались зарубками или насечками, но если в числе несколько знаков, требуется иная система записи. Эту проблему в разных странах решали по-разному.</p>

<p>Сейчас разные способы записи чисел называются <em>системами счисления</em>.</p>

<p>Систем счисления было придумано довольно много, и даже в наши дни мы используем две системы, возникшие в далёкой древности. Из Древнего Рима к нам пришла <em>римская система счисления</em>, где цифры обозначаются буквами латинского алфавита. За основу римляне взяли количество пальцев на одной руке — 5, и на двух руках — 10. Числа 1, 5 и 10 в римской системе обозначаются буквами I, V и X, и с помощью них можно записать любое число от 1 до 49. Например, VII это 7, а XIX — 19.</p>

<p>От Древних Шумеров мы научились делить дроби на шестьдесят частей. Именно из-за них в нашем часе 60 минут, а в минуте 60 секунд. Шумерская система счисления так и называется — <em>шестидесятеричная</em>. Но, конечно, наиболее привычной выглядит численная запись в системе, которую придумали в Древней Индии. Сейчас ее называют арабской или <em>десятичной системой счисления</em>.</p>

<h2 id="от-десятичных-чисел-к-двоичным">От десятичных чисел к двоичным</h2>

<p>Разберемся, как устроена десятичная система, на примере произвольного большого числа.</p>

<p><img src="/assets/images/numeral-systems/example01.png" alt="1072" /></p>

<p>Это четырехзначное число, потому что оно состоит из четырёх цифр. И, поскольку речь идёт о десятичной системе, мы можем использовать десять различных цифр.</p>

<p><img src="/assets/images/numeral-systems/example02.png" alt="0123456789" /></p>

<p>Величина, которая скрывается за каждой цифрой, зависит от её позиции, поэтому такую систему счисления называют также и позиционной. Справа мы записываем самые младшие значения — <em>единицы</em>, слева от них <em>десятки</em>, затем <em>сотни</em>, и так далее. Запись 1702 означает буквально следующее.</p>

<p><img src="/assets/images/numeral-systems/example03.png" alt="1×1000+7×100+0×10+2×1" /></p>

<p>Цифры, записанные в соседних позициях, различаются в десять раз — это и есть десятичная система. Однако, как мы говорили ранее, привычная нам десятичная система — далеко не единственная. Однако, опираясь на неё, нам будет проще понять принципы работы других систем счисления. Например, для записи того же самого числа 1702 в двоичной системе надо придерживаться тех же правил, но вместо десяти цифр нам потребуется всего две — 0 и 1.</p>

<p>Цифры, записанные в соседних позициях, будут различаться не в десять раз, а в два. То есть там, где в десятичной системе мы видим 1, 10, 100, 1 000, 10 000, в двоичной будут числа 1, 2, 4, 8, 16 и так далее.</p>

<p><img src="/assets/images/numeral-systems/example04.png" alt="1×1024+1×512+0×256+ +1×128+0×64+1×32+0×16+ +0×8+1×4+1×2+0×1" /></p>

<p>Это очень большое двоичное число. Давайте запишем его в привычной форме:</p>

<p><img src="/assets/images/numeral-systems/example05.png" alt="1 1 0 1 0 1 0 0 1 1 0 1024 512 256 128 64 32 16 8 4 2 1" /></p>

<p>Это число могло бы быть очень большим десятичным числом, потому что состоит из тех же цифр. Чтобы отличать двоичные числа от десятичных, в качестве индекса у них указывают основание системы счисления, то есть 2.</p>

<p><img src="/assets/images/numeral-systems/example06.png" alt="11010100110₂" /></p>

<p>Это особенно важно, когда в тексте одновременно встречаются десятичные и двоичные числа.</p>

<p><img src="/assets/images/numeral-systems/example07.png" alt="11010100110₂ = 1702" /></p>

<h2 id="зачем-нужна-двоичная-система">Зачем нужна двоичная система</h2>

<p>Двоичная система выглядит очень непривычно и числа, записанные в ней, получаются огромными. Зачем она вообще нужна? Разве компьютеры не могут работать с привычной нам десятичной системой?</p>

<p>Оказывается, когда-то они именно так и работали. Самый первый компьютер ENIAC, разработанный в 1945 году, хранил числа в десятичной системе счисления. Для хранения одной цифры применялась схема, которая называется кольцевым регистром, она состояла из десяти радиоламп.</p>

<p>Чтобы записать все числа до миллиона — от 0 до 999 999 — надо шесть цифр, значит, для хранения таких чисел нужно целых 60 ламп.</p>

<p><img src="/assets/images/numeral-systems/ring-counter.png" alt="Кольцевой регистр" /></p>

<p>Инженеры заметили, что если бы они кодировали числа в двоичной системе, то для хранения таких же больших чисел им бы потребовалось всего двадцать радиоламп — в три раза меньше!</p>

<p>Первое преимущество двоичных чисел — простота схем. Второе, и не менее важное — быстродействие. Сложение чисел, хранящихся в кольцевом регистре, требует до десяти тактов процессора на каждую операцию. Сложение двоичных чисел можно выполнить за один такт — то есть в десять раз быстрее.</p>

<p>Группа инженеров, создавших первый компьютер, в 1946 году опубликовала статью, где обосновала преимущество двоичной системы для представления чисел в компьютерах. Первой среди авторов была указана фамилия американского математика Джона фон Неймана. Поэтому сейчас принципы проектирования компьютеров называются архитектурой фон Неймана, хотя это не совсем справедливо по отношению к другим изобретателям компьютера.</p>

<p>При разработке программы с двоичной записью столкнуться довольно сложно: компьютер в подавляющем большинстве случаев сам переводит двоичные числа в десятичные и обратно. Можно долго писать код, даже не подозревая, что внутри компьютера данные хранятся каким-то особым образом.</p>

<p>Зачем изучать двоичную систему, если компьютер делает всю работу за нас? Иногда программистам приходится писать программы, которые работают напрямую с оборудованием. Например, разработчики игр должны знать, как работают видеокарты, чтобы сделать компьютерную графику быстрее. А разработчики операционных систем понимают, как устроены диски, чтобы надежно хранить данные.</p>

<p>Программы, которые работают с железом напрямую, называются системными или низкоуровневыми. Для их создания разработчик должен понимать, как устроен компьютер. Поэтому изучение систем счисления позволяет программисту расширить свой профессиональный диапазон и стать специалистом широкого профиля.</p>

<p>Поэтому для того, чтобы писать сложные системные программы, нужно понимать, как устроена двоичная система счисления.</p>

<h2 id="как-переводить-двоичные-числа-в-десятичные">Как переводить двоичные числа в десятичные</h2>

<p>Разберемся, как быстро переводить двоичные числа в десятичные. Для примера потребуется достаточно большое двоичное число, чтобы мы не могли вычислить его на пальцах.</p>

<p><img src="/assets/images/numeral-systems/example08.png" alt="11010" /></p>

<p>Запишем его в математической записи, помня, что вместо основания 10, мы используем основание 2.</p>

<p><img src="/assets/images/numeral-systems/example09.png" alt="1×16+1×8+0×4+1×2+0×1" /></p>

<p>Из этого примера видно, что у всех слагаемых только два множителя — 0 и 1. Слагаемые с множителем 0 равны нулю, поэтому их можно отбросить, оставив только слагаемые с множителем 1.</p>

<p><img src="/assets/images/numeral-systems/example10.png" alt="1×16+1×8+1×2" /></p>

<p>У слагаемых с множителем 1 этот множитель можно не записывать.</p>

<p><img src="/assets/images/numeral-systems/example11.png" alt="16+8+2" /></p>

<p>Теперь нетрудно посчитать сумму.</p>

<p><img src="/assets/images/numeral-systems/example12.png" alt="26" /></p>

<p>Вывод: число 11010 в двоичной записи — то же самое, что 26 в десятичной.</p>

<p><img src="/assets/images/numeral-systems/example13.png" alt="11010₂=26" /></p>

<p>Ещё раз повторим, как перевести двоичное число в десятичное.</p>

<ul>
  <li>Записать число в математическом виде</li>
  <li>Отбросить слагаемые с множителем 0</li>
  <li>Сложить результат</li>
</ul>

<p>Программисты иногда запоминают некоторые степени числа два, чтобы уметь оценивать порядок двоичных чисел. Вы можете подглядывать в эту таблицу:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Двоичное число</th>
      <th style="text-align: right">Степень 2</th>
      <th style="text-align: right">Десятичное число</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1<sub>2</sub></td>
      <td style="text-align: right">2<sup>0<sup></sup></sup></td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td style="text-align: right">10<sub>2</sub></td>
      <td style="text-align: right">2<sup>1<sup></sup></sup></td>
      <td style="text-align: right">2</td>
    </tr>
    <tr>
      <td style="text-align: right">100<sub>2</sub></td>
      <td style="text-align: right">2<sup>2<sup></sup></sup></td>
      <td style="text-align: right">4</td>
    </tr>
    <tr>
      <td style="text-align: right">1000<sub>2</sub></td>
      <td style="text-align: right">2<sup>3<sup></sup></sup></td>
      <td style="text-align: right">8</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>4<sup></sup></sup></td>
      <td style="text-align: right">16</td>
    </tr>
    <tr>
      <td style="text-align: right">10 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>5<sup></sup></sup></td>
      <td style="text-align: right">32</td>
    </tr>
    <tr>
      <td style="text-align: right">100 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>6<sup></sup></sup></td>
      <td style="text-align: right">64</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>7<sup></sup></sup></td>
      <td style="text-align: right">128</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>8<sup></sup></sup></td>
      <td style="text-align: right">256</td>
    </tr>
    <tr>
      <td style="text-align: right">10 0000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>9<sup></sup></sup></td>
      <td style="text-align: right">512</td>
    </tr>
    <tr>
      <td style="text-align: right">100 0000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>10<sup></sup></sup></td>
      <td style="text-align: right">1 024</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000 0000 0000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>16<sup></sup></sup></td>
      <td style="text-align: right">65 536</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000 0000 0000 0000 0000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>24<sup></sup></sup></td>
      <td style="text-align: right">16 777 216</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000 0000 0000 0000 0000 0000 0000 0000<sub>2</sub></td>
      <td style="text-align: right">2<sup>32<sup></sup></sup></td>
      <td style="text-align: right">4 294 967 296</td>
    </tr>
  </tbody>
</table>

<p>С помощью этой таблицы можно переводить числа из двоичной системы в десятичную практически «в уме».</p>

<p><img src="/assets/images/numeral-systems/example14.png" alt="11010₂=10000₂+1000₂+10₂=16+8+2=26" /></p>

<h2 id="как-переводить-десятичные-числа-в-двоичные">Как переводить десятичные числа в двоичные</h2>

<p>Эта задача похожа на математическую загадку, и её можно встретить на олимпиаде для школьников.</p>

<p>Чтобы научиться её решать, давайте ещё раз посмотрим на первые натуральные числа в двоичной и десятичной записи.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Десятичное число</th>
      <th style="text-align: right">Двоичное число</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">1</td>
      <td style="text-align: right">1<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">2</td>
      <td style="text-align: right">10<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">3</td>
      <td style="text-align: right">11<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">4</td>
      <td style="text-align: right">100<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">5</td>
      <td style="text-align: right">101<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">6</td>
      <td style="text-align: right">110<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">7</td>
      <td style="text-align: right">111<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">8</td>
      <td style="text-align: right">1000<sub>2</sub></td>
    </tr>
    <tr>
      <td style="text-align: right">9</td>
      <td style="text-align: right">1001<sub>2</sub></td>
    </tr>
  </tbody>
</table>

<p>Обратим внимание на следующую закономерность: все чётные числа — 2, 4, 6 и 8 — в двоичной записи заканчиваются на 0. Все нечётные числа 1, 3, 5, 7 и 9 — на 1. Этому есть простое объяснение — в двоичной записи число 2 это как 10 в десятичной. Если двоичное число делится на два, оно круглое. Математики говорят, что чётные числа делятся на 2 без остатка (или с остатком 0), а нечётные — с остатком 1:</p>

<ul>
  <li>при делении 4 на 2 остаток 0;</li>
  <li>при делении 5 на 2 остаток 1;</li>
  <li>при делении 6 на 2 остаток 0;</li>
  <li>при делении 9 на 2 остаток 1.</li>
</ul>

<p>Попробуем перевести десятичное число 26 в двоичную систему. Для этого используем деление уголком на 2.</p>

<p><img src="/assets/images/numeral-systems/example24.png" alt="Перевод десятичного числа в двоичное" /></p>

<p>Если 26 разделить на 2, то в результате получится 13, остаток от деления 0. Продолжаем дальше:</p>
<ul>
  <li>13 разделить на 2, в результате получится 6, остаток от деления 1;</li>
  <li>6 разделить на 2, в результате получится 3, остаток от деления 0;</li>
  <li>3 разделить на 2, в результате получится 1, остаток от деления 1;</li>
  <li>1 разделить на 2, в результате получится 0, остаток от деления 1;</li>
</ul>

<p>Из остатков 1, 1, 0, 1 и 0 складывается нужная нам двоичная запись.</p>

<p><img src="/assets/images/numeral-systems/example08.png" alt="11010" /></p>

<h2 id="шестнадцатеричная-система-счисления">Шестнадцатеричная система счисления</h2>

<p>Мы знаем, что компьютер использует числа для представления любой информации. Например, цвета хранятся в виде трёх чисел — яркости красной, зелёной и синей компонентов цвета. На каждый компонент отводится восемь двоичных позиций, поэтому максимальная яркость компонента равна 11111111₂ или 255. Цвет целиком описывается большим 24-х разрядным двоичным числом, например, 11111010 10000000 01110010. Это цвет Salmon из таблицы цветов HTML, он же <em>лососевый цвет</em>.</p>

<p><img src="/assets/images/numeral-systems/salmon-color.png" alt="Лососевый цвет" /></p>

<p>Старшие восемь позиций отводятся для хранения красного компонента, средние восемь — зелёного, и младшие восемь — синего. Мы видим, что такая запись очень громоздка и неудобна.</p>

<p>Кажется, что цвет удобнее записать как десятичное число 16416882. Хотя оно занимает меньше места, по нему трудно понять, какова яркость каждого компонента.</p>

<p>Чтобы записывать большие двоичные числа, программисты придумали использовать шестнадцатеричную систему счисления:</p>

<ul>
  <li>В десятичной системе десять цифр, а в шестнадцатеричной — шестнадцать</li>
  <li>В десятичной системе соседние позиции отличаются в десять раз, а в шестнадцатеричной — в шестнадцать раз</li>
</ul>

<p>Как и в случае с двоичной системой, цифры 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9 заимствуются из десятичной системы. Но в данном случае этих цифр не хватает: нужно ещё шесть. Их в шестнадцатеричной системе принято обозначать первыми буквами английского алфавита:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Основание 16</th>
      <th style="text-align: right">Основание 10</th>
      <th style="text-align: right">Основание 2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">0</td>
      <td style="text-align: right">0</td>
      <td style="text-align: right">0</td>
    </tr>
    <tr>
      <td style="text-align: right">1</td>
      <td style="text-align: right">1</td>
      <td style="text-align: right">1</td>
    </tr>
    <tr>
      <td style="text-align: right">2</td>
      <td style="text-align: right">2</td>
      <td style="text-align: right">10</td>
    </tr>
    <tr>
      <td style="text-align: right">3</td>
      <td style="text-align: right">3</td>
      <td style="text-align: right">11</td>
    </tr>
    <tr>
      <td style="text-align: right">4</td>
      <td style="text-align: right">4</td>
      <td style="text-align: right">100</td>
    </tr>
    <tr>
      <td style="text-align: right">5</td>
      <td style="text-align: right">5</td>
      <td style="text-align: right">101</td>
    </tr>
    <tr>
      <td style="text-align: right">6</td>
      <td style="text-align: right">6</td>
      <td style="text-align: right">110</td>
    </tr>
    <tr>
      <td style="text-align: right">7</td>
      <td style="text-align: right">7</td>
      <td style="text-align: right">111</td>
    </tr>
    <tr>
      <td style="text-align: right">8</td>
      <td style="text-align: right">8</td>
      <td style="text-align: right">1000</td>
    </tr>
    <tr>
      <td style="text-align: right">9</td>
      <td style="text-align: right">9</td>
      <td style="text-align: right">1001</td>
    </tr>
    <tr>
      <td style="text-align: right">A</td>
      <td style="text-align: right">10</td>
      <td style="text-align: right">1010</td>
    </tr>
    <tr>
      <td style="text-align: right">B</td>
      <td style="text-align: right">11</td>
      <td style="text-align: right">1011</td>
    </tr>
    <tr>
      <td style="text-align: right">C</td>
      <td style="text-align: right">12</td>
      <td style="text-align: right">1100</td>
    </tr>
    <tr>
      <td style="text-align: right">D</td>
      <td style="text-align: right">13</td>
      <td style="text-align: right">1101</td>
    </tr>
    <tr>
      <td style="text-align: right">E</td>
      <td style="text-align: right">14</td>
      <td style="text-align: right">1110</td>
    </tr>
    <tr>
      <td style="text-align: right">F</td>
      <td style="text-align: right">15</td>
      <td style="text-align: right">1111</td>
    </tr>
  </tbody>
</table>

<p>Шестнадцатеричная система счисления хороша тем, что группа из четырёх двоичных цифр кодируется одной шестнадцатеричной цифрой. Таким образом, лососевый цвет выглядит как:</p>

<p><img src="/assets/images/numeral-systems/example25.png" alt="1111 1010 1000 0000 0111 0010" /></p>

<p>В шестнадцатеричной системе счисления он записывается так:</p>

<p><img src="/assets/images/numeral-systems/example26.png" alt="FA 80 72" /></p>

<p>Вначале трудно понять, каков порядок у шестнадцатеричного числа FA. Как и в случае с двоичными числами, программисты обычно помнят порядки круглых шестнадцатеричных чисел. Но можно не запоминать, а подглядывать в эту таблицу:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Шестнадцатеричное число</th>
      <th style="text-align: right">Десятичное число</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">10<sub>16</sub></td>
      <td style="text-align: right">16</td>
    </tr>
    <tr>
      <td style="text-align: right">20<sub>16</sub></td>
      <td style="text-align: right">32</td>
    </tr>
    <tr>
      <td style="text-align: right">30<sub>16</sub></td>
      <td style="text-align: right">48</td>
    </tr>
    <tr>
      <td style="text-align: right">40<sub>16</sub></td>
      <td style="text-align: right">64</td>
    </tr>
    <tr>
      <td style="text-align: right">50<sub>16</sub></td>
      <td style="text-align: right">80</td>
    </tr>
    <tr>
      <td style="text-align: right">60<sub>16</sub></td>
      <td style="text-align: right">96</td>
    </tr>
    <tr>
      <td style="text-align: right">70<sub>16</sub></td>
      <td style="text-align: right">112</td>
    </tr>
    <tr>
      <td style="text-align: right">80<sub>16</sub></td>
      <td style="text-align: right">128</td>
    </tr>
    <tr>
      <td style="text-align: right">90<sub>16</sub></td>
      <td style="text-align: right">144</td>
    </tr>
    <tr>
      <td style="text-align: right">A0<sub>16</sub></td>
      <td style="text-align: right">160</td>
    </tr>
    <tr>
      <td style="text-align: right">B0<sub>16</sub></td>
      <td style="text-align: right">176</td>
    </tr>
    <tr>
      <td style="text-align: right">C0<sub>16</sub></td>
      <td style="text-align: right">192</td>
    </tr>
    <tr>
      <td style="text-align: right">D0<sub>16</sub></td>
      <td style="text-align: right">208</td>
    </tr>
    <tr>
      <td style="text-align: right">E0<sub>16</sub></td>
      <td style="text-align: right">224</td>
    </tr>
    <tr>
      <td style="text-align: right">F0<sub>16</sub></td>
      <td style="text-align: right">240</td>
    </tr>
    <tr>
      <td style="text-align: right">100<sub>16</sub></td>
      <td style="text-align: right">256</td>
    </tr>
    <tr>
      <td style="text-align: right">1000<sub>16</sub></td>
      <td style="text-align: right">4 096</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000<sub>16</sub></td>
      <td style="text-align: right">65 536</td>
    </tr>
    <tr>
      <td style="text-align: right">10 0000<sub>16</sub></td>
      <td style="text-align: right">1 048 576</td>
    </tr>
    <tr>
      <td style="text-align: right">100 0000<sub>16</sub></td>
      <td style="text-align: right">16 777 216</td>
    </tr>
    <tr>
      <td style="text-align: right">1000 0000<sub>16</sub></td>
      <td style="text-align: right">268 435 456</td>
    </tr>
    <tr>
      <td style="text-align: right">1 0000 0000<sub>16</sub></td>
      <td style="text-align: right">4 294 967 296</td>
    </tr>
  </tbody>
</table>

<p>Чтобы переводить числа из десятичной системы в шестнадцатеричную и обратно, двоичное представление можно использовать как промежуточное. Часто это самый простой способ: двоичное и шестнадцатеричное представления без труда переводятся друг в друга.</p>

<h2 id="восьмеричная-система-счисления">Восьмеричная система счисления</h2>

<p>Восьмеричная система когда-то использовалась наравне с шестнадцатеричной. Из названия понятно, что она использует всего восемь цифр: 0, 1, 2, 3, 4, 5, 6 и 7. Восьмеричная система подходит для представления шести-, девяти- и двенадцатиразрядных двоичных чисел.</p>

<p>Такие числа встречаются нечасто. Один из самых известных примеров использования восьмеричных чисел — права доступа в операционной системе UNIX. Они записываются девятизначным двоичным числом, например 110100100 или 111101100. Запоминать и передавать такие числа неудобно, поэтому программисты предпочитают восьмеричную систему счисления, и записывают права доступа в виде 644 или 754.</p>

<p>Популярные операционные системы Linux и MacOS берут своё начало в UNIX, поэтому там права доступа также задаются восьмеричным числом.</p>

<p><img src="/assets/images/numeral-systems/stat-chmod.jpg" alt="stat и chmod" /></p>

<p>Пользователи UNIX используют команду stat, чтобы узнать права доступа, и команду chmod, чтобы изменить их. На рисунке вы видите, что команды stat и chmod используют восьмеричные числа. Подробный рассказ об этих командах выходит за рамки нашей статьи. Узнаете больше о правах доступа, и о том, что означают эти числа, можно изучив командную строку Linux.</p>

<p>Подводя итог, можно сказать, что восьмеричные числа сейчас используются редко. В подавляющем большинстве случаев программисты используют шестнадцатеричную запись.</p>

<h2 id="конвертация-чисел-в-программах">Конвертация чисел в программах</h2>

<p>Языки программирования умеют работать с числами, записанными в разных системах счисления, и переводить их из одной системы в другую. Для примера рассмотрим работу с разными системами счисления на Python и JavaScript.</p>

<h3 id="python">Python</h3>

<p>Чтобы записать в Python двоичное число, добавьте перед ним <em>префикс</em> <strong>0b</strong>. Десятичное число 26 можно записать в виде 0b11010. У шестнадцатеричных чисел префикс <strong>0x</strong>, а у восьмеричных — <strong>0o</strong>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">print</span><span class="p">(</span><span class="mb">0b11010</span><span class="p">)</span> <span class="c1"># =&gt; 26
</span><span class="k">print</span><span class="p">(</span><span class="mh">0x1a</span><span class="p">)</span> <span class="c1"># =&gt; 26
</span><span class="k">print</span><span class="p">(</span><span class="mo">0o32</span><span class="p">)</span> <span class="c1"># =&gt; 26
</span></code></pre></div></div>

<p>Во всех случаях, чтобы записать число, мы пишем сначала цифру ноль «0», а затем букву, которая определяет систему счисления. Буква «b» — первая в слове binary (двоичный), а буква «o» — в слове octal (восьмеричный). Буква «x» выбивается из общего правила — это третья буква в слове hexadecimal (шестнадцатеричный).</p>

<p>Функции <code class="language-plaintext highlighter-rouge">bin()</code>, <code class="language-plaintext highlighter-rouge">hex()</code> и <code class="language-plaintext highlighter-rouge">oct()</code> преобразуют число в двоичную, шестнадцатеричную и восьмеричную системы.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">print</span><span class="p">(</span><span class="nb">bin</span><span class="p">(</span><span class="mi">26</span><span class="p">))</span> <span class="c1"># =&gt; '0b11010'
</span><span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="mi">26</span><span class="p">))</span> <span class="c1"># =&gt; '0x1a'
</span><span class="k">print</span><span class="p">(</span><span class="nb">oct</span><span class="p">(</span><span class="mi">26</span><span class="p">))</span> <span class="c1"># =&gt; '0o32'
</span></code></pre></div></div>

<p>Благодаря префиксной записи и функциям <code class="language-plaintext highlighter-rouge">bin()</code>, <code class="language-plaintext highlighter-rouge">hex()</code> и <code class="language-plaintext highlighter-rouge">oct()</code>, мы можем преобразовывать числа из любой системы в любую.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="mo">0o32</span><span class="p">))</span> <span class="o">//</span> <span class="o">&gt;=</span> <span class="s">'0x1a'</span>
</code></pre></div></div>

<h3 id="javascript">JavaScript</h3>

<p>В JavaScript для представления чисел используются те же самые префиксы, что и в Python. 0b11010, 0x1a и 0o32 — записи числа 26 в двоичной, шестнадцатеричной и восьмеричной системах счисления.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mb">0b11010</span><span class="p">)</span> <span class="c1">// =&gt; 26</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mh">0x1a</span><span class="p">)</span> <span class="c1">// =&gt; 26</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mo">0o32</span><span class="p">)</span> <span class="c1">// =&gt; 26</span>
</code></pre></div></div>

<p>Для преобразования чисел в другую систему счисления нужно вызывать метод <code class="language-plaintext highlighter-rouge">toString()</code>, передав в качестве параметра основание системы.</p>

<p>Обычно в JavaScript мы можем вызвать метод у объекта с помощью точки. Например, если мы сохранили число в переменной <code class="language-plaintext highlighter-rouge">i</code>, мы можем узнать его шестнадцатеричное представление, вызвав метод <code class="language-plaintext highlighter-rouge">i.toString(16)</code>. Но мы не можем вызывать метод у числа 2 — <code class="language-plaintext highlighter-rouge">2.toString(16)</code> — потому что в JavaScript точка в записи чисел разделяет целую и дробную части. Если дробная часть равна нулю, её можно не записывать, поэтому «2.» означает то же самое, что и «2.0».</p>

<p>В примере вы видите три корректных способа обойти эту проблему, и вызвать метод <code class="language-plaintext highlighter-rouge">toString()</code> у числа 26.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">((</span><span class="mi">26</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c1">// =&gt; '11010'</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">26</span><span class="p">..</span><span class="nx">toString</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span> <span class="c1">// =&gt; '1a'</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">26</span> <span class="p">.</span><span class="nx">toString</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="c1">// =&gt; '32'</span>
</code></pre></div></div>

<h2 id="сервисы-для-перевода-из-системы-в-систему">Сервисы для перевода из системы в систему</h2>

<p>Существует множество сервисов для перевода чисел из системы в систему. Это умеет даже Google.
Чтобы перевести двоичное число, например, 11010 в десятичную систему, надо ввести запрос <strong>0b11010 decimal</strong>.</p>

<p><img src="/assets/images/numeral-systems/google01.png" alt="0b11010 decimal" /></p>

<p>Чтобы перевести десятичное число, например, 26 в двоичную систему, надо ввести запрос <strong>26 binary</strong>.</p>

<p><img src="/assets/images/numeral-systems/google02.png" alt="26 binary" /></p>

<p>Обратите внимание, что Google использует префикс 0b, чтобы отличать двоичные числа от десятичных.</p>

<p>Чтобы перевести десятичное число 137 в шестнадцатеричную систему, введите запрос <strong>137 hex</strong>.</p>

<p><img src="/assets/images/numeral-systems/google03.png" alt="137 hex" /></p>

<p>Чтобы перевести шестнадцатеричное число 2BAD в десятичную систему, введите запрос <strong>0x2BAD decimal</strong>.</p>

<p><img src="/assets/images/numeral-systems/google04.png" alt="0x2BAD decimal" /></p>

<p>Google использует префикс 0x для того, чтобы отличать шестнадцатеричные числа от всех прочих.
Чтобы перевести число 121 в восьмеричную систему, введите запрос <strong>121 octal</strong>.</p>

<p><img src="/assets/images/numeral-systems/google05.png" alt="121 octal" /></p>

<p>Чтобы перевести число обратно, введите в строке поиска запрос <strong>0o171 decimal</strong>.</p>

<p><img src="/assets/images/numeral-systems/google06.png" alt="0o171 decimal" /></p>

<p>Мы видим, что Google для представления чисел в двоичной, шестнадцатеричной и восьмеричной системах счисления использует такие же префиксы, которые мы видели в примерах на Python и JavaScript.</p>

<h2 id="заключение">Заключение</h2>

<p>Люди изобрели разные способы записывать числа. Мы называем их системами счисления. Привычный для нас способ записи называется десятичной системой счисления.</p>

<p>Компьютеры, которые работали в десятичной системе, оказались сложными и медленными. Хранение чисел в двоичной системе позволило упростить схемы и ускорить работу компьютеров.</p>

<p>Обычно нам не нужно знать, как именно компьютер хранит числа, потому что он умеет переводить их в привычную нам форму. Но если мы хотим разрабатывать программы, которые работают с оборудованием напрямую — системные утилиты или компьютерные игры, — нужно разобраться, как устроены двоичная и шестнадцатеричная системы.</p>

<p>Существует ряд алгоритмов, которые помогают перевести число из одной системы в другую, но они достаточно запутанные. Проще использовать Google.</p>

<p>Двоичная запись чисел очень громоздкая, поэтому программисты предпочитают записывать числа в шестнадцатеричной системе счисления. Восьмеричная запись чисел сейчас используется очень редко.</p>

<p>Вы можете конвертировать числа из системы в систему на своём любимом языке программирования.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/transpilers/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое транспиляция</turbo:topic> -->
            <title>Что такое транспиляция</title>
            <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
            <author>Казанцев Игорь</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/transpilers/">Что такое транспиляция</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/transpilers/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Понять, что такое транспайлеры и какова их роль в программировании, поможет следующий пример. Представим, что вы разрабатываете софт для TV-приставок и вам нужно добавить калькулятор на все приставки определенной фирмы. Есть одно но — некоторые приставки не обновлялись уже 7 лет и могут работать только со старой версией языка, на котором написан калькулятор. Тут появляется выбор:</p>

<ul>
  <li>Разрабатывать программу для двух типов приставок: на старой версии языка для тех, которые давно не обновлялись, и на новой — для современных.</li>
</ul>

<p><img src="/assets/images/transpilers/cover.png" alt="transpilers, cover" /></p>

<ul>
  <li>Использовать «переводчик» с версии языка, которую используете вы, на версии, работающие на всех устройствах</li>
</ul>

<p>Роль такого переводчика выполняют транспайлеры: они преобразуют код, на котором мы пишем, в другой, который может применяться и работать у конечного пользователя на любых устройствах с любыми версиям языка разработки.</p>

<p><strong>Транспиляция</strong> — преобразование программы, написанной на одном языке программирования в качестве исходных данных, в эквивалентный код другой версии этого языка или в другой язык программирования того же уровня абстракции.</p>

<h2 id="когда-нужна-транспиляция">Когда нужна транспиляция?</h2>

<p>Рассмотрим практический пример, в котором пригодится транспайлер. За основу возьмем кейс с обновлением софта в TV-приставках, но дополним его деталями.</p>

<p>Калькулятор запускается на встроенном браузере TV-приставки и написан на JavaScript последней версии. Также учтем, что приставки выпускались каждый год с ограниченным сроком поддержки и сейчас мы имеем множество устройств с разными версиями браузера (а, следовательно, и отличающиеся версии поддерживаемого JS-кода). Кроме того, браузер пользователя давно не обновлялся и код на JS, который может там работать, сильно отличается от текущих версий языка.</p>

<p>В такой ситуации чаще всего может пригодиться транспиляция кода. Транспайлеры помогут преобразовать код, написанный на последней версии JavaScript, в тот, который будет работать у всех пользователей независимо от времени, прошедшего с последнего обновления.</p>

<h2 id="как-используют-транспайлеры">Как используют транспайлеры?</h2>

<p>Тринспайлеры широко используются во многих областях программирования. В целом можно выделить две основных области применения:</p>

<ul>
  <li>
    <p>Транспиляция одной версии языка в другую. Поскольку языки программирования постоянно обновляются, возникают ситуации, когда разработчик уже пишет на новой версии языка, а среда, где используется код, поддерживает и работает только с предыдущими версиями. Например, для переходов между версиями стандарта ECMAScript используется Babel. Транспайлеры позволяют преобразовывать код и в другую сторону: например, помогают перевести проект на более новую версию языка. Делать это вручную долго и больно. Например,  если проект написан на Python 2.x, перевести его на Python 3 можно с помощью трансплайнера 2to3</p>
  </li>
  <li>
    <p>Транспиляция между разными языками. Например преобразование TypeScript в JS. Подробнее об этом расскажем ниже</p>
  </li>
</ul>

<h2 id="как-работают-транспайлеры">Как работают транспайлеры?</h2>

<p>В качестве примера рассмотрим работу транспайлера над возведением в квадрат кода на JS:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>a ** b
</code></pre></div></div>

<p>Вот как выглядит то же преобразование, проведенное с помощью объекта Math — он и использовался для операций по возведению в квадрат в старых версиях языка:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Math.pow(a, b)
</code></pre></div></div>

<p>В данном случае у нас есть начальное и желаемое конечное состояния. Мы уже знаем, что для транспайлера не составит труда провести такое преобразование. Однако для нас механизм его работы пока выглядит как черный ящик. Пора в деталях разобраться, как происходит транспиляция.</p>

<h3 id="преобразование-исходного-кода-в-абстрактною-форму">Преобразование исходного кода в абстрактною форму</h3>

<p>На первом этапе транспайлер создает на основе кода абстрактное представление. В общем случае такое преобразование происходить в два этапа — сначала программа проводит лексический, а затем синтаксический анализ.</p>

<ul>
  <li>Лексический анализ берёт «сырой» код и разбивает его на изолированные части, которые называются токенами. Это могут быть цифры, пунктуация, метки, операторы: всё, что угодно. В нашем случае токенами будут бинарный оператор (применяется к двум операндам, например 2 + 2) и его операнды:</li>
</ul>

<p><img src="/assets/images/transpilers/tokens.png" alt="transpilers, tokens" /></p>

<ul>
  <li>Синтаксический анализ строит объект, который описывает все токены и их связи между собой. Он называется AST (abstract syntax tree или абстрактное синтаксическое дерево). Оператор возведения в квадрат является бинарным выражением внутри программы (в нашем случае — единственным), а операнды станут идентификаторами в этом выражении:</li>
</ul>

<p><img src="/assets/images/transpilers/AST.png" alt="transpilers, AST" /></p>

<h3 id="трансформация-ast">Трансформация AST</h3>

<p>После преобразования в абстрактную модель происходит трансформация, которая производит все необходимые для дальнейшей работы изменения в AST.</p>

<p>На этом этапе дерево из предыдущего шага изменяется: трансформация меняет текущий код на код на предыдущей версии языка. В данном случае оператор умножения заменяется на вызов выражения, при этом его операнды становятся аргументами выражения (Math.pow):</p>

<p><img src="/assets/images/transpilers/transformed_AST.png" alt="transpilers, transformedAST" /></p>

<h3 id="генерация-конечного-кода">Генерация конечного кода</h3>

<p>Когда все изменения внесены, транспайлер берёт трансформированное AST кода и на его основе генерирует новый код.</p>

<p><img src="/assets/images/transpilers/generate_result.png" alt="transpilers, generate" /></p>

<p>В итоге код из начального состояния проходит ряд преобразований (анализ -&gt; трансформация -&gt; генерация) до конечного состояния — этот процесс и называется транспиляцией.</p>

<h3 id="обратная-связь">Обратная связь</h3>

<p>После всех преобразований мы получили конечный код, который работает на нужной нам версии языка. Но представим, что после трансилиляции в нашей программе появились  ошибки. Как понять, где именно находится ошибка, если она ссылается какое-то место в трансипилированном коде (который может значительно отличаться от того, что мы писали изначально)?</p>

<p>Использование транспайлеров может затруднить отладку, когда нам нужно найти точное место поломки в исходном коде по транспилированному коду. В таких случаях используются различные утилиты, позволяющие сопоставить результат транспиляции с оригинальным кодом. Например, в JS есть утилита SourceMap, которая в процессе создания конечного кода создает файл-маппер — с его помощью можно связать исходный и конечный код.</p>

<h2 id="инструменты-реализации-транспиляции-кода">Инструменты (реализации) транспиляции кода</h2>

<p>Для фронтенд-разработки основной инструмент транспиляции — Babel. Он позволяет не только выполнять транспиляцию между версиями, которую мы рассмотрели выше, но и:</p>

<ul>
  <li>преобразовывать JSX-код в JavaScript при разработке на React</li>
  <li>трансформировать LESS/SCSS в CSS при использовании CSS препроцессоров</li>
  <li>транспилировать TypeScript в JS, когда нужно использовать типизацию</li>
</ul>

<p>Среди транспиляторов, которые трансформируют код на бэкэнд языках программирования в код на других языках, популярностью пользуются:</p>

<ul>
  <li>Haxe предназначен для транспилирования во Flash, JavaScript и Neko. Со временем Haxe разросся до набора инструментов, поддерживающих транспиляцию на разные языки и платформы, включая JavaScript, C++, C#, Java, JVM, Python, Lua, PHP и Flash.</li>
  <li>Lombok — решение для тех, кому хочется расширить возможности Java. Это плагин, добавляющий в Java новые «ключевые слова» и превращающий аннотации в Java-код. Он сокращает время на разработку и обеспечивает дополнительную функциональность.</li>
  <li>Bridge.NET позволяет использовать в JavaScript производительность C#, а также мощные VisualStudio IDE и стандартные инструменты .NET.
Grumpy обеспечивает трансляцию кода на языке Python в представление на языке Go и позволяет бесшовно запускать Python-программы в runtime-окружении Go.</li>
</ul>

<h2 id="итого">Итого</h2>

<p>В мире, где есть огромное количество языков программирования, а сами языки имеют множество версий, транспайлеры выполняют крайне важную работу — делают разработку удобнее. Программисты могут писать код на языке или версии языка, которая им удобна или имеет нужные функции, а транспайлеры выполнят работу по доставке этого кода до среды исполнения в нужном виде.</p>

<p>На данный момент реализовано множество различных транспайлеров (Babel, Vala, Typescript transpiler, Bridge и другие), каждый из них решает свою задачу по-своему, но общий принцип работы транспайлеров похож у всех.</p>

<p><img src="/assets/images/transpilers/scheme.png" alt="transpilers, scheme" /></p>

<p>Исходный код преобразуется в абстрактное синтаксическое дерево, далее AST трансформируется в структуру, которая соотносится с конечным кодом, и из этой структуры генерируется необходимый нам код.</p>

<h2 id="дополнительные-материалы">Дополнительные материалы</h2>

<ul>
  <li><a href="https://astexplorer.net/">Сайт для построения AST</a></li>
  <li><a href="https://github.com/VladReshet/the-super-tiny-compiler-rus">Перевод проекта The Super Tiny Compiler! (Супер Маленького Компилятора)</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/http-api/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое API</turbo:topic> -->
            <title>Что такое API</title>
            <pubDate>Fri, 26 Nov 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/http-api/">Что такое API</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/http-api/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>В двух словах: Под API, обычно, подразумевают способ, с помощью которого программы или сервисы могут запрашивать данные у других сервисов.</p>

<h2 id="пример-twitter-api">Пример Twitter API</h2>

<p>Пример. У твиттера есть сайт, на котором мы можем просматривать твиты. Кликая по ссылкам мы попадаем на разные адреса, по которым доступна разная информация: лента твитов, страница твита, личный кабинет, сброс пароля, рекламный кабинет и так далее.</p>

<ul>
  <li>https://twitter.com/mokevnin – страница конкретного пользователя</li>
  <li>https://twitter.com/mokevnin/status/1446464250499710976 – страница конкретного твита</li>
</ul>

<p>Каждая из этих страниц возвращает HTML, в котором информация представлена в том виде, в котором мы ее видим, со всеми элементами дизайна. Сайт твиттера адаптирован под небольшие экраны, поэтому открывается с любого устройства где есть браузер. Но кроме сайта у твиттера есть и мобильное приложение, которое показывает ту же самую информацию, но с другим, более удобным интерфейсом, адаптированным под конкретный телефон.</p>

<p>Мобильное приложение, в отличии от сайта, физически хранится и запускается прямо на телефоне. И весь внешний вид тоже описывается внутри приложения. Для работы такого приложения нужны чистые данные, которых на телефоне нет, они есть на серверах твиттера. Как загрузить их на телефон? Обычные адрес страниц нам не подходят, так как они возвращают не данные, а готовые html-страницы.</p>

<p>Именно здесь на помощь приходит API. Твиттер предоставляет специальные http-адреса, по которым доступны чистые данные, а не конкретные интернет-страницы с готовым внешним видом. Данные по таким адресам отдаются в структурированном формате, чаще всего JSON. Один сервис “упаковывает” данные в JSON формат, другой, который ходит за данными, “распаковывает” их из JSON и использует внутри себя для отображения. Пример запроса пользователя:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Адрес, по которому возвращается список указанных пользователей</span>
<span class="c"># В данном случае запрашивается один пользователь</span>
https://api.twitter.com/2/users/by?usernames<span class="o">=</span>hexletHQ

<span class="c"># В ответ приходит JSON такой структуры:</span>
<span class="o">{</span>
  <span class="s2">"data"</span>: <span class="o">[</span>
    <span class="o">{</span>
      <span class="s2">"created_at"</span>: <span class="s2">"2013-12-14T04:35:55.000Z"</span>,
      <span class="s2">"id"</span>: <span class="s2">"2244994945"</span>,
      <span class="s2">"name"</span>: <span class="s2">"HexletHQ"</span>,
      <span class="s2">"description"</span>: <span class="s2">"Хекслет - курсы программирования"</span>,
      <span class="s2">"pinned_tweet_id"</span>: <span class="s2">"1464165859761573893"</span>,
      <span class="s2">"username"</span>: <span class="s2">"hexlethq"</span>
    <span class="o">}</span>,
  <span class="o">]</span>,
<span class="o">}</span>
</code></pre></div></div>

<p>Задача этого API дать удобный доступ к данным твиттера. Причем это API используется как самим твиттером в мобильных приложениях, так и сторонними сервисами, которые управляют твиттером. Например маркетологи используют сервисы, которые автоматически публикуют твиты по расписанию.</p>

<p>Кстати, сам твиттер использует свое API, в том числе для виджетов, которые можно встраивать на любой сайт для отображения конкретного твита или ленты твитов, хороший пример – <a href="https://ru.hexlet.io">главная Хекслета</a>. И, если говорить откровенно, то сам сайт твиттера работает по API. В браузер грузится JS-код, который реализует логику вывода и ходит за данными на сервер (по API).</p>

<p>У твиттера есть <a href="https://developer.twitter.com/en/docs/twitter-api">специальный сайт</a> для разработчиков, на котором подробно описано их API, адреса, параметры, которые можно передавать и форматы ответов. Подобное описание есть у любого сервиса с публичным API, то есть доступным для использования в интернете. Правда публичное не означает бесплатное, API может быть и часто бывает платным.</p>

<p><img src="/assets/twitter-api.png" alt="Twitter API" /></p>

<h2 id="http-api">HTTP API</h2>

<p>Twitter API – это пример HTTP API, оно работает по протоколу HTTP, через который браузеры загружают и показывают сайты. HTTP наиболее распространенный и удобный способ делать API для публичных интернет-сервисов. На него заточен весь интернет, у него хорошая поддержка в любом языке программирования. В конце-концов это простой протокол, который так или иначе знают все веб-программисты.</p>

<p>Но не все HTTP API одинаковые. HTTP оставляет многое на откуп разработчикам, поэтому разные HTTP API могут отличаться друг от друга кардинально, например, форматом данных. Самый популярный формат JSON, но кроме него используется и XML. XML и HTML очень похожи по внешнему виду, но XML описывает данные, а не то как они расположены и выглядят:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c">&lt;!-- Просто пример API из интернета --&gt;</span>
<span class="nt">&lt;Contents&gt;</span>
    <span class="nt">&lt;Key&gt;</span>europe/france/cannes.jpg<span class="nt">&lt;/Key&gt;</span>
    <span class="nt">&lt;LastModified&gt;</span>2010-02-17T22:11:12.487Z<span class="nt">&lt;/LastModified&gt;</span>
    <span class="nt">&lt;ETag&gt;</span>"53fc311c15eda0a031809982ccf92aac"<span class="nt">&lt;/ETag&gt;</span>
    <span class="nt">&lt;Size&gt;</span>5061631<span class="nt">&lt;/Size&gt;</span>
    <span class="nt">&lt;StorageClass&gt;</span>STANDARD<span class="nt">&lt;/StorageClass&gt;</span>
<span class="nt">&lt;/Contents&gt;</span>
</code></pre></div></div>

<p>Существуют и другие форматы, но их используют значительно реже. В целом, HTTP никак не ограничивает формат, можно придумать и использовать свой собственный.</p>

<p>Кроме форматов, HTTP API отличаются тем как у них структурированы адреса. Например у <a href="https://ru.code-basics.com">code-basics</a> на каждый вид данных есть свой адрес:</p>

<ul>
  <li>https://code-basics.com/api/languages.json – список языков, по которым есть курсы</li>
  <li>https://code-basics.com/api/languages/12.json – информация о курсе</li>
  <li>https://code-basics.com/api/languages/12/lessons.json – список уроков курса по языку</li>
</ul>

<p>Подобное API часто называют REST API. Подробнее о нем в другой статье. Иногда API выглядит так, что адрес всегда один, но на него отправляются разные параметры запроса. У данного способа есть множество разновидностей, например, json-rpc, graphql и другое:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Все запросы идут только на этот адрес</span>
https://some-site.com/api/rpc
https://some-site.com/api/rpc?param<span class="o">=</span>value
</code></pre></div></div>

<p>Ну и наконец Websocket API, когда взаимодействие идет в режиме реального времени в обе стороны, в отличии от примеров выше, где клиент (тот кто использует API), должен запрашивать данные сам. С помощью Websocket делаются приложения реального времени, например чаты или игры. В этих приложениях данные измененные на сервере, должны максимально быстро уходить всем заинтересованным клиентам.</p>

<h2 id="не-http-api">Не HTTP API</h2>

<p>API бывает не только HTTP. Обычно, такие API встречаются внутри сервиса, для взаимодействия его компонентов, каждый из которых ведет себя как маленький сервис. Такие API могут использовать как другой протокол, например TCP, так и строиться вообще поверх других подходов, например с помощью систем очередей или потоков. Ключевые слова: grpc, rabbitmq, kafka.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/interpreter/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое интерпретатор</turbo:topic> -->
            <title>Что такое интерпретатор</title>
            <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
            <author>Марк Шевченко</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/interpreter/">Что такое интерпретатор</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/interpreter/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>В этом гайде разберемся, что такое интерпретатор, для чего он нужен и как работает. Этот материал поможет понять, как компьютер выполняет программы.</p>

<h2 id="зачем-нужен-интерпретатор">Зачем нужен интерпретатор</h2>

<p>В переводе с английского языка компьютер — <em>вычислитель</em>. Мы привыкли пользоваться компьютером для подготовки документы, чтения новостей и просмотра фильмов. В повседневной жизни производить вычисления приходится крайне редко, поэтому такое определение может показаться странным.</p>

<p>Вместе с тем, это название очень точно отражает природу компьютера. Мы этого не видим, но на самом деле компьютер умеет работать только с числами: документы, и новости, и фильмы выглядят для компьютера как наборы чисел. То же самое касается программ, которые он выполняет.</p>

<p>Каждая команда имеет свой числовой — машинный — код: благодаря ему компьютер без труда понимает, что нужно делать. Человеку трудно писать программы в машинных кодах, однако на заре компьютерной эры программисты писали именно так. Вот так выглядели их программы:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>102 184 0 0
102 185 100 0
102 1 200
102 73
102 131 249 0
117 245
</code></pre></div></div>

<!--
https://defuse.ca/online-x86-assembler.htm

0:  66 b8 00 00             mov    ax,0x0
4:  66 b9 64 00             mov    cx,100
00000008 <loop>:
8:  66 01 c8                add    ax,cx
b:  66 49                   dec    cx
d:  66 83 f9 00             cmp    cx,0
11: 75 f5     
-->

<p>Пытаясь облегчить себе работу, программисты придумали языки программирования: они понятнее человеку, поэтому писать программы на них проще. На этом этапе возникла проблема: если компьютер понимает команды только в виде чисел, как он будет выполнять команды, написанные на языке программирования?</p>

<p>Есть два вида программ, которые помогают решить эту проблему — <em>интерпретаторы</em> и <em>компиляторы</em>. Про компилятор <a href="/compiler/">можно почитать здесь</a>, в этом тексте мы остановимся только на интерпретаторах.</p>

<p>Вкратце, <em>интерпретатор</em> — это программа, которая выполняет команды, написанные на каком-то языке программирования. Например, интерпретатор Python понимает команды языка Python, а интерпретатор JavaScript — команды языка JavaScript.</p>

<h2 id="экскурс-в-историю">Экскурс в историю</h2>

<p>Lisp оказался удачным изобретением. За прошедшие годы люди изобрели множество языков, которые оказались никому не нужны. Этого нельзя сказать о Lisp, который развивается до сих пор. Уточню, что разработкой интерпретаторов Lisp занимались разные команды, поэтому у них получались разные версии языка. Такие версии языка называют <em>диалектами</em>. Кроме Emacs Lisp, вы могли слышать о <a href="https://ru.code-basics.com/languages/clojure">ClojureScript</a> — диалекте LISP, который иногда используют вместо JavaScript при разработке фронтенда</p>

<p>Рассмотрим пример программы на Lisp для понимания разницы между машинным кодом и «почти человеческим языком»:</p>

<div class="language-lisp highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="p">(</span><span class="nv">sum</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="nv">sum</span> <span class="mi">100</span><span class="p">)</span>
</code></pre></div></div>

<p>Необязательно знать Lisp, чтобы увидеть, что в программе есть структура, и понять отдельные ее части. Доступность для понимания — выгодное преимущество языков программирования перед машинным кодом.</p>

<p>Есть интерпретаторы для таких популярных языков программирования, как Python и JavaScript. Они хорошо подходят и для работы, и для изучения программирования. Важную роль в этом играет то, что для них существует интерпретаторы, и чуть позже мы узнаем, почему это так.</p>

<h2 id="пример-интерпретатора-python">Пример интерпретатора Python</h2>

<p>Разберем в деталях работу интерпретатора — для этого напишем несложную программу, которая будет вычислять суммы чисел от 1 до 100:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">i</span>
<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span> <span class="c1"># =&gt; 5050
</span></code></pre></div></div>

<p>Запустим интерпретатор <em>python</em> и построчно введем программу.</p>

<p><img src="/assets/images/interpreter/example.png" alt="Пример работы интерпретатора Python" /></p>

<p>Мы видим, что начале каждой строки интерпретатор выводит подсказку <code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>. Когда мы вводим команду <code class="language-plaintext highlighter-rouge">for</code>, состоящую из двух строк, подсказка меняется на троеточие <code class="language-plaintext highlighter-rouge">...</code>.</p>

<p>Выполняя команду <code class="language-plaintext highlighter-rouge">print(sum)</code>, интерпретатор печатает результат — число 5050. Если мы допустим ошибку, интерпретатор подскажет нам, где она находится.</p>

<p><img src="/assets/images/interpreter/error.png" alt="Пример ошибки в программе" /></p>

<p>В примере выше мы забыли поставить двоеточие после инструкции <code class="language-plaintext highlighter-rouge">for</code>, о чем интерпретатор и сообщает.</p>

<p>Немедленный отклик интерпретатора очень важен при изучении языка. Новички, видя сообщениях об ошибках и пробуя разные варианты, быстро осваивают незнакомый синтаксис. Именно поэтому Python и JavaScript часто используют для обучения.</p>

<p>Опытные программисты также ценят такой — <em>интерактивный</em> — способ разработки, потому что он помогает быстро проверять свои идеи.</p>

<p>Кроме того, интерпретируемые языки часто используют для разработки прототипов больших программ. В интерактивном режиме он постоянно выполняет одни и те же действия: читает команду программиста, выполняет ее и печатает результат. Такой режим называют <em>Циклом Чтения-Выполнения-Печати</em>, или, по-английски <em>Read-Evaluate-Print Loop</em>. Обычно это название сокращают до аббревиатуры REPL.</p>

<p><img src="/assets/images/interpreter/repl.png" alt="Цикл Чтения-Выполнения-Печати" /></p>

<h2 id="пример-интерпретатора-javascript">Пример интерпретатора JavaScript</h2>

<p>Интерпретатор JavaScript встроен прямо в браузер. Посмотрим, как он работает, на примере браузера Chrome.</p>

<p>В правом верхнем углу есть три вертикальные точки, которые вызывают меню браузера. Нажмите и выберите пункт меню <em>Дополнительные инструменты</em>, а затем <em>Инструменты разработчика</em>.</p>

<p><img src="/assets/images/interpreter/chrome-dev-tools.png" alt="Инструменты разработчика Chrome" /></p>

<p>Вы увидите новое окно, заполненное вкладками. Все эти инструменты полезны и их стоит освоить. Но сейчас нам нужна одна вкладка — <em>Console</em>. В консоли мы можем набирать команды языка JavaScript и сразу видеть отклик интерпретатора.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// =&gt; 1</span>
<span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// =&gt; 2</span>
<span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// =&gt; 9</span>
</code></pre></div></div>

<p>Интерпретатор сохранит переменные <code class="language-plaintext highlighter-rouge">a</code> и <code class="language-plaintext highlighter-rouge">b</code> со значениями 1 и 2, затем вычислит значение <code class="language-plaintext highlighter-rouge">3 * (a + b)</code> и напечатает результат 9.</p>

<p><img src="/assets/images/interpreter/chrome-console.png" alt="Консоль Chrome" /></p>

<h2 id="выполнение-программы">Выполнение программы</h2>

<p>Цикл REPL помогает разрабатывать программу, но вводить каждую команду по отдельности не удобно: куда быстрее ввести их один раз, а затем запустить готовую программу. Для этого создадим текстовый файл <em>sum<span>.</span>py</em> и запишем там команды:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">101</span><span class="p">):</span>
  <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">+</span> <span class="n">i</span>

<span class="k">print</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
</code></pre></div></div>

<p>Чтобы выполнить программу, достаточно запустить интерпретатор Python, указав имя файла в параметрах:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>&gt; python sum.py
5050
</code></pre></div></div>

<p>Интерпретатор выполняет команды одну за одной и в конце завершает свою работу. Такой режим работы интерпретатора называют <em>пакетным</em>.</p>

<p>Таким образом, интерпретатор может работать в двух режимах. Интерактивный режим (REPL) помогает нам проверять идеи и придумывать решение задач. Пакетный режим выполняет готовую программу.</p>

<h2 id="устройство-интерпретатора">Устройство интерпретатора</h2>

<p>Есть много способов написать интерпретатор. Не будем рассматривать все возможные варианты, а остановимся на устройстве интерпретаторов в целом. Обычный язык программирования содержит несколько десятков команд.</p>

<p>В программе на Python, которую мы обсуждали выше есть операторы присваивания, цикл <code class="language-plaintext highlighter-rouge">for</code> и вызов функции <code class="language-plaintext highlighter-rouge">print</code>. Все это — команды, которые понимает интерпретатор Python.
Для каждой команды в интерпретаторе есть блок кода, который умеет такую команду исполнять.</p>

<p>Вторая важная составляющая интерпретатора — анализатор текста. Когда программист вводит текст, анализатор разбирает его на составные части и понимает, о какой команде идет речь. После этого он передает управление блоку, отвечающему за выполнение этой команды.</p>

<p>Так — в цикле — интерпретатор и работает. Анализирует введенную команду, затем выполняет, снова анализирует и снова выполняет. Анализ текста это, конечно, не тривиальная задача, но и не слишком трудная, так что интерпретаторы на самом деле не такие сложные программы.</p>

<p><img src="/assets/images/interpreter/how-it-works.png" alt="Как работает интерпретатор" /></p>

<h2 id="достоинства-и-недостатки">Достоинства и недостатки</h2>

<p>Достоинства интерпретаторов:</p>

<ul>
  <li>
    <p><strong>Простота изучения.</strong> REPL помогает проверять, как работают незнакомые конструкции и быстро осваивать синтаксис языка.</p>
  </li>
  <li>
    <p><strong>Простота программирования.</strong> Как и компилятор, интерпретатор избавляет от необходимости писать программы в машинных кодах.</p>
  </li>
  <li>
    <p><strong>Кроссплатформенность.</strong> Интерпретаторы разработаны для разных платформ — Mac, Windows, Linux, поэтому написанная нами программа будет работать на всех платформах.</p>
  </li>
  <li>
    <p><strong>Улучшение программы за счет интерпретатора.</strong> Скорость программ зависит не только от качества кода, но и от того, насколько быстро работает интерпретатор. Например, программисты Google постоянно улучшают интерпретатор JavaScript, который работает в браузере Chrome. Если мы написали программу на JavaScript, с каждой новой версией Chrome она работает быстрее, даже если мы ничего в ней не меняем.</p>
  </li>
</ul>

<p>Недостатки интерпретаторов:</p>

<ul>
  <li>
    <p><strong>Низкая скорость.</strong> Интерпретируемые программы работают медленнее, чем программы в машинных кодах. Это происходит потому, что интерпретатор должен сначала проанализировать текст команды, и лишь потом выполнить ее. Программа в машинных кодах сразу понятна компьютеру.</p>
  </li>
  <li>
    <p><strong>Зависимость от интерпретатора.</strong> Интерпретируемой программе нужен интерпретатор. В Windows программы в машинных кодах имеют расширение <em>.exe</em>. Такую программу, скажем, архиватор 7-zip можно просто запустить. А для того, чтобы выполнить программу на языке Python, нужен интерпретатор <em>python</em>.</p>
  </li>
  <li>
    <p><strong>Доступность исходного кода.</strong> Исходный код на интерпретируемом языке доступен пользователю программы. Пользователь может подсмотреть в программе то, что ее автор хотел бы скрыть, например, способ шифрования пароля или уникальный алгоритм.</p>
  </li>
  <li>
    <p><strong>Позднее обнаружение ошибок.</strong> Интерпретаторы выполняют программы по одной команде. Если в синтаксисе команды допущена ошибка, интерпретатор не сможет об этом узнать, пока не приступит к ее анализу. В больших программах есть куски, которые выполняются реже других и, возможно, там есть ошибки, про которые программист не знает. Чтобы избежать ошибок, которые увидит пользователь программы, приходится тестировать её гораздо тщательней.</p>
  </li>
</ul>

<h2 id="выводы-и-рекомендации">Выводы и рекомендации</h2>

<p>Интерпретатор языка программирования — это программа, выполняющая команды, написанные на этом языке. Мы, например, говорим <em>интерпретатор Python</em> или <em>интерпретатор JavaScript</em>.</p>

<p>Интерактивный режим (REPL) помогает программистам изучать синтаксис языка и проверять свои идеи.</p>

<p>Интерпретатор состоит из анализатора текста и исполнителей отдельных команд языка, таких как цикл <code class="language-plaintext highlighter-rouge">for</code>, проверка <code class="language-plaintext highlighter-rouge">if</code>, вызов функции <code class="language-plaintext highlighter-rouge">print</code>, и других.</p>

<p>К достоинствам интерпретируемых языков относят простоту изучения. Именно поэтому программирование начинают изучать с таких языков, как Python и JavaScript.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/time/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое время</turbo:topic> -->
            <title>Что такое время</title>
            <pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate>
            <author>Александр Вериго</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/time/">Что такое время</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/time/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <h2 id="как-компьютер-определяет-человеческое-время">Как компьютер определяет человеческое время?</h2>

<p>Представим ситуацию: Вы нашли в кладовой старый компьютер и решили попробовать
его включить. Компьютер запускается, хотя стоял без дела 10 лет, но есть
проблема: система уверена, что сегодня 1 января 1970 года. Эта ситуация поможет
разобраться, как компьютеры хранят текущее время: ведь у них нет внутри пружин
или маятников, как в часах, которые могли бы отсчитывать секунды. Каким образом
они показывают верное время, если отключить их на несколько часов, и почему тот
же принцип не работает, если компьютер простоял в кладовке 10 лет?</p>

<h3 id="маятник-как-первый-секундомер">Маятник как первый секундомер</h3>

<p>Прежде, чем ответить на эти вопросы, разберемся, как измеряется точное время.
Это не такая простая задача, если под рукой нет часов.
Мы можем отсчитывать дни, месяцы и годы или приблизительно разбить день на часы.
Но найти ориентир, который подскажет количество прошедших секунд, гораздо сложнее.</p>

<p>Принято считать, что первым эту задачу в XVII веке решил итальянский ученый
<a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B0%D0%BB%D0%B8%D0%BB%D0%B5%D0%B9,_%D0%93%D0%B0%D0%BB%D0%B8%D0%BB%D0%B5%D0%BE">Галилео Галилей</a>.
Галилео нужно было точно знать, сколько длился тот или иной эксперимент. Его биографы
утверждают, что сначала он считал количество своих сердцебиений, но однажды
наблюдал за раскачивающимся канделябром в кафедральном соборе Пизы и заметил,
что каждое колебание канделябра занимает одинаковое количество сердцебиений.
Это число не меняется при затухании амплитуды движений. Так он понял, что
колебания маятника помогают точно измерять время.</p>

<h3 id="можно-ли-использовать-колебания-для-подсчета-времени-в-компьютере">Можно ли использовать колебания для подсчета времени в компьютере?</h3>

<p>Когда в 70-е-80-е годы инженеры впервые столкнулись с задачей отображения человеческого
времени в компьютере, они, как ни странно, обратились к трудам итальянского ученого,
но взглянули на них под другим углом. Маятник — не единственный возможный источник
колебаний. У любого современного персонального компьютера есть «сердце» — центральное
процессорное устройство (ЦПУ), или просто процессор. Он устроен очень сложно и выполняет
множество функций, но в данном случае интересно одно из составляющих его устройств.
Когда через него проходит ток, оно испускает равномерные электрические колебания
с одинаковой <a href="https://en.wikipedia.org/wiki/Clock_rate">частотой</a>. Частота этих
колебаний измеряется в герцах (Гц) и определяет количество операций, которое процессор
может выполнить за одну секунду. К сожалению, если мы будем использовать
единственную доступную нам операцию в секунду для увеличения счетчика колебаний,
то наш процессор будет совершенно непригоден для чего-то ещё: ему будет некогда
исполнять другие команды. Конечно, современные процессоры не такие медленные, их
частота измеряется в гигагерцах (ГГц), то есть в 1 000 000 000 операций в секунду.
Но даже при такой мощности для измерения времени пришлось бы считать каждое колебание
процессора. Для решения проблемы был придуман кварцевый генератор. Он представляет
собой тончайшую кремниевую пластину, которая под воздействием электрического
тока равномерно расширяется и сжимается, <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%8C%D0%B5%D0%B7%D0%BE%D1%8D%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82">генерируя слабый электрический заряд на
поверхности</a>.
Таким образом, механические колебания пластины сопровождаются синхронными, равномерными
колебаниями электрического заряда.</p>

<p><img src="/assets/images/time/oscillator.png" alt="oscillator" /></p>

<p>Полученные равномерные колебания принято называть таймером — они позволяют
процессору синхронизировать производимые им операции во времени. Таким образом,
у компьютера есть своё собственное понимание времени.</p>

<h3 id="от-компьютерного-времени-к-человеческому">От компьютерного времени к человеческому</h3>

<p>Получается, что внутри компьютера есть таймер, но он не измеряет человеческое
время — оно для него довольно бесполезно. Как правило, эту задачу на себя берут
операционные системы (ОС). Поскольку ОС знает, с какой частотой работает кварцевый
генератор, она может измерить время, которое проходит между срабатываниями таймера
(срабатывание таймера называют тик (tick) или джиффи (jiffy)). Если генератор
работает на частоте 100 Гц, то период между тиками равен 1/100 секунды или 10
миллисекундам. Операционная система создает в памяти переменную, которую обычно
называют jiffies, и увеличивает её на единицу каждый раз, когда процессор дает
сигнал о новом тике.</p>

<p>Соответственно, чтобы узнать, как долго включен компьютер, системе достаточно
умножить размер периода между тиками на количество этих самых тиков. А чтобы узнать
текущее время, нужно просто добавить прошедшее время к времени на момент старта
системы. Но как узнать человеческое время на момент старта системы?</p>

<h3 id="rtc-или-часы-реального-времени">RTC или часы реального времени</h3>

<p>Первые персональные компьютеры (например, <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer#Design_process">IBM PC</a>
или <a href="https://en.wikipedia.org/wiki/Apple_II">Apple II</a>), не умели следить за тем,
сколько прошло время после выключения, а <a href="https://www.youtube.com/watch?v=X3aqJQPQKhs">спрашивали его на старте</a>.
Для решения этой задачи снова пригодился кварцевый генератор. Устройству неважно,
из какого источника получать электрический ток, — это натолкнуло разработчиков на
мысль, что достаточно подключить генератор к обычной литиевой батарейке, чтобы
получать равномерные электрические колебания.</p>

<p>Если в эту схему добавить бинарный счетчик, который увеличивается на каждое колебание,
то мы получим устройство, которое может фиксировать человеческое время. Оно так
и называется — RTC (Real Time Clock), или часы реального времени. Частота колебаний
на выходе из RTC обычно 32 768 Гц или 2^15 Гц, что удобно использовать в бинарных
счетчиках.</p>

<p><img src="/assets/images/time/RTC.png" alt="RTC" /></p>

<p>Старый компьютер, о котором шла речь в начале, перепутал время именно из-за того,
что батарейка в его часах реального времени села: после запуска он не смог
считать время из RTC и выставил стандартное стартовое время — 1 января
1970 года.</p>

<h3 id="ntp-или-протокол-сетевого-времени">NTP или протокол сетевого времени</h3>

<p>RTC позволяет компьютеру отсчитывать миллисекунды, даже когда он выключен. Но
стандартные RTC имеют погрешность 1,7-8,6 секунд в день — то есть за год они могут
потерять целый час.</p>

<p>Иногда мы сталкиваемся с этой проблемой в реальной жизни: например, когда нам
приходится вручную настраивать время на наручных кварцевых часах или на микроволновке,
где тоже используют RTC. Но нам никогда не приходится делать этого на компьютере.
Да и на старте компьютер больше не спрашивает текущее время.
Современные компьютеры настраивают время через интернет — для этого используется
NTP (протокол сетевого времени). Этот протокол даже учитывает время передачи данных
между источником и компьютером и компенсирует его. В публичной сети погрешность
составляет всего 10 мс.</p>

<h3 id="как-протоколы-работают-вместе">Как протоколы работают вместе?</h3>

<p><img src="/assets/images/time/computer_time_keeping_system.png" alt="computer timekeeping" /></p>

<p>Когда наш компьютер выключен, RTC продолжает работу и отсчитывает время.
Когда мы нажимаем кнопку запуска, операционная система забирает время из RTC и
начинает отслеживать время самостоятельно, используя таймер процессора. Время от
времени операционная система получает точное время по NTP и поправляет свой
внутренний счетчик. Когда мы выключаем компьютер, за дело снова берется RTC.</p>

<h2 id="таймстампы-и-эпохи">Таймстампы и эпохи</h2>

<p>Как уже говорилось, для отслеживания человеческого времени операционная система
создает в памяти компьютера переменную jiffy, в которой хранит количество тиков
с момента старта системы. Но как с помощью неё показывать человеку календарь?</p>

<h3 id="unix-таймстамп-и-epoch">Unix-таймстамп и epoch</h3>

<p>В 70-е годы прошлого века эту проблему решили инженеры из Bell Labs при разработке
операционной системы Unix (она заложила фундамент для появления современных Linux
и MacOS). Они ввели в систему переменную, которая, начиная с заданной даты,
увеличивается на каждый тик генератора — её называли epoch.</p>

<p>Под эту переменную отводилось целое число со знаком (signed integer) размером в
32 бита (то есть от −2 147 483 648 (-2^31) до 2 147 483 647 (2^31−1)). Подавляющее
большинство генераторов на тот момент работали на частоте 60 Гц, то есть отсчитывали
60 тиков в секунду, поэтому в переменной хранилось 1/60 секунды и она могла
представлять временной промежуток не более 829 дней.</p>

<p>В <a href="http://man.cat-v.org/unix-1st/2/sys-time">версии Unix от 1971 года</a> отсчет начинался
с 1971-01-01 00:00:00. <a href="https://minnie.tuhs.org/cgi-bin/utree.pl?file=V3/man/man2/time.2">На следующий год</a>
с 1972-01-01 00:00:00. Переводить время каждый год было довольно неудобно, поэтому
в <a href="https://minnie.tuhs.org/cgi-bin/utree.pl?file=V4/man/man2/time.2">четвертой версии Unix</a>
в 1973 году за epoch была взята дата 1970-01-01 00:00:00, а в переменной стали
хранить не 1/60 секунды, а полную секунду. Позже этот принцип стал международным
стандартом и используется по сей день.</p>

<p>Если на Вашем компьютере установлена операционная система семейства Linux или MacOS,
Вы можете увидеть текущий Unix-timestamp, введя в терминале:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">date</span> +<span class="s2">"%s"</span>
</code></pre></div></div>

<p>Windows тоже считает время, отталкиваясь от конкретной даты, но использует для
этого не абстрактный 1970 год, а 1601 — первый год Григорианского календаря.</p>

<h3 id="проблема-2038-года">Проблема 2038 года</h3>

<p>Поскольку время хранится в целочисленной 32-битовой переменной и представляет
собой определенное количество секунд с определенного момента, то самое большое
количество секунд, которое мы можем использовать — это 2 147 483 647 (2^31−1).
Если прибавить это количество к epoch, то мы получим 19 января 2038 03:14. Что
произойдет с системой, когда наступит этот день и пройдет еще одна секунда?</p>

<p>Чтобы ответить на этот вопрос, рассмотрим особенность 32-битовых переменных:</p>

<p>2 147 483 647 в двоичной системе записывается как</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="mi">01111111111111111111111111111111</span> <span class="c1">// (1 ноль и 31 единица)</span>
</code></pre></div></div>

<p>Если это число увеличить на единицу, то оно превратится в</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="mi">10000000000000000000000000000000</span> <span class="c1">// (1 единица и 31 ноль)</span>
</code></pre></div></div>

<p>Первая цифра у таких чисел означает знак: <code class="language-plaintext highlighter-rouge">+</code> или <code class="language-plaintext highlighter-rouge">-</code>. А значит, что в десятичной
системе оно будет равно −2 147 483 648, то есть число перейдет от самого
большого положительного к самому маленькому отрицательному. И система начнет
показывать дату, равную разности epoch и двух млрд секунд, то есть 13 декабря 1901
года. Но не стоит волноваться, проблема уже решена — большинство систем используют
64 битовые числа для хранения времени. Этого хватит, чтобы не столкнуться с проблемой
до 15:40 4 декабря 292 277 026 596 года.</p>

<h3 id="проблема-2000-года-или-y2k-bug">Проблема 2000 года или Y2K bug</h3>

<blockquote>
  <p>«640 килобайт памяти должно хватить кому угодно», — Билл Гейтс.</p>
</blockquote>

<p>На самом деле в истории уже была такая ситуация. В 60-70-е годы прошлого столетия,
когда люди только начали писать программное обеспечение для компьютеров, платы
памяти стоили дорого и большинство компьютеров обходились несколькими килобайтами.
Ради экономии памяти программисты решили записывать даты в формате ДД.ММ.ГГ.</p>

<p>Какую проблему это порождало? Допустим, у нас есть человек по имени Боб, у
которого дата рождения записана как 01.11.19. Он родился в 1919 году, и ему чуть
больше 100 лет. Есть человек по имени Фред и он родился 02.11.19, но ему всего
два года, потому что он родился в 2019 году. Сталкиваясь с таким форматом дат,
человек может исходить из контекста, но компьютер на такое не способен.</p>

<p>Программисты, которые писали программы в 60-70-е годы даже не предполагали, что
их код может дожить до 2000 года, поэтому использование двух цифр вместо четырех
было нормальной оптимизацией. Но когда приближался 2000 год, а многие компании всё
ещё использовали тот же формат дат, началась паника: никто не понимал, что произойдёт,
когда 99 год сменится на 00. Тогда в мире ходили самого разного рода слухи:
например, что банкоматы в этот момент начнут плеваться деньгами, а самолёты начнут
падать. Баг был вовремя замечен и проблему в большинстве систем удалось исправить
вовремя.</p>

<h2 id="об-особенностях-работы-с-локальным-временем-и-часовыми-поясами">Об особенностях работы с локальным временем и часовыми поясами</h2>

<h3 id="почему-не-стоит-самостоятельно-писать-код-описывающий-время">Почему не стоит самостоятельно писать код, описывающий время</h3>

<p>Представим, что абстрактный программист пишет приложение, которое должно каждый
день в 12 часов дня отправлять пользователю уведомление, что наступил полдень.
Программист живет в Лондоне и оно будет использоваться только там.
Писать код он начал зимой, поэтому разницы с <a href="https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%BE%D0%B5_%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%B2%D1%80%D0%B5%D0%BC%D1%8F">UTC</a>
(Всемирным координированным временем) нет.</p>

<p>Приложение работало всю зиму, но в первый день апреля уведомление ушло на час
позже полудня. Дело в том, что разработчик просто прикрутил таймер, который
срабатывает раз в 24 часа, а в последний день марта в Великобритании перевели
время на час вперед — на летнее. Разработчик быстро исправил ситуацию, заменив
таймер на планировщик задач — последний срабатывает в соответствии с локальным
временем сервера, который находится в квартире разработчика.</p>

<p>Как ни странно, приложение пользуется популярностью.
Спустя некоторое время разработчик получает отзыв от разгневанного пользователя
из Нью-Йорка: тот пишет, что уведомления приходят вовсе не в полдень, а в 7 утра.
Нью-Йорк находится в часовом поясе ETC (Eastern Time Zone), то есть UTC -05:00.</p>

<p>Для разных часовых поясов нельзя просто ставить таймер, отталкиваясь от времени
на сервере. Разработчик добавил выбор часового пояса при регистрации и переписал
планировщик так, чтобы он стартовал для каждого пользователя раньше или позже на
несколько часов в зависимости от данных, которые человек ввёл при регистрации.</p>

<p>Кажется, теперь все работает хорошо — но в ноябре разработчику начали писать
пользователи из Москвы и жаловаться на уведомления, которые приходят в 11 утра.
Дело в том, что в Великобритании время переводится с зимнего на летнее, а в России
— нет. К тому моменту разработчик начал нервничать и решил просто записать в коде,
что если пользователь из России, то делать переход во времени для него не нужно.
Приложение тем временем только набирало популярность.</p>

<p>В марте, разработчику пишут из Сиднея — им уведомление приходит в два часа дня.
Все потому, что в южном полушарии в марте происходит переход не на летнее время,
а на зимнее. Разработчику не оставалось ничего иного, как дополнить свой код
информацией о том, что в южном полушарии надо переводить время наоборот. Приложение
уже стало популярным во всём мире и на разработчика посыпались претензии со всех
уголков света. Например, пользователи из Палестины писали жалобы каждый раз, как
их правительство переводило часы с летнего времени на зимнее, а случается это
каждый раз в разное время. А ещё дело было в 2011 году, и 29 декабря пользователи
из Самоа дружно пересекли <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D0%BD%D0%B8%D1%8F_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D1%8B_%D0%B4%D0%B0%D1%82%D1%8B">линию перемены даты</a>,
совершив скачок в будущее и очутившись 31 декабря 2011 года. Еще через год
разработчику позвонили из <a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D1%83%D0%B6%D0%B1%D0%B0_%D0%B2%D1%80%D0%B0%D1%89%D0%B5%D0%BD%D0%B8%D1%8F_%D0%97%D0%B5%D0%BC%D0%BB%D0%B8">Международной службы вращения Земли</a>
и сообщили, что ему надо поправить приложение, потому что в этом году будет на
одну секунду больше, чем в прошлом из-за добавления дополнительной секунды. Записывать
все это в код — совершенно безумная идея. Поэтому разработчик закрыл проект и
больше никогда не писал код.</p>

<h3 id="пара-советов-как-работать-с-локальным-временем">Пара советов, как работать с локальным временем</h3>

<p>Что бы мог сделать разработчик, чтобы избежать такого печального финала?
Все просто — достаточно было учесть опыт тех, кто уже решал эту проблему и
выкладывал решение в открытый доступ. В каждом языке программирования есть как
минимум одна библиотека, которая умеет работать с человеческим временем и часовыми
поясами. Более того, существует база данных, в которой хранится информация о
локальном времени, в том числе в исторической перспективе.</p>

<p>Что бы мог сделать разработчик:</p>

<ul>
  <li>Переложить ответственность за подсчет времени на библиотеки и базы данных;</li>
  <li>Хранить не разницу во времени с локальным временем пользователя, а его часовой
пояс в соответствии с <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">классификацией IANA</a>,
то есть не +3, а “Europe/Moscow”;</li>
  <li>Настроить планировщик так, чтобы он выбирал задачи из списка в соответствии с
часовым поясом.</li>
</ul>

<h3 id="пара-советов-как-не-работать-с-локальным-временем">Пара советов, как НЕ работать с локальным временем</h3>

<p>Существует много сценариев, при которых крайне важна последовательность событий,
на которую не могут повлиять ни изменения часовых поясов, ни переход на летнее время.</p>

<p>Предположим, нужно написать сервис, обслуживающий банковские транзакции. Его
функционал крайне простой: один пользователь отправляет другому деньги банковским
переводом, любой из них может получить информацию обо всех переводах. В данном
случае нужно хранить информацию о том, кто, кому, когда и сколько денег перевёл.
При этом показывать эту информацию нужно в локальном времени пользователя при
условии, что транзакции в любом часовом поясе идут одна за другой.</p>

<p>Учтём опыт разработчика из примера выше и не будем описывать время самостоятельно,
а используем библиотеку. Тут мы столкнемся с рядом вопросов:</p>

<ul>
  <li>В каком часовом поясе хранить транзакции, если клиенты живут в разных странах,
а база данных находится в третьей стране;</li>
  <li>Как учитывать переход на летнее и зимнее время;</li>
  <li>Как учитывать дополнительную секунду;</li>
  <li>Что делать, если пользователь переехал из одной страны в другую.</li>
</ul>

<p>И лучшим решением будет не делать ничего. Не нужно учитывать временные зоны клиентов,
не нужно учитывать переходы на летнее и зимнее время, не нужно учитывать переезды
пользователей. Когда нужно абсолютное время, достаточно использовать UTC.</p>

<p>Время в UTC поддерживается почти всеми библиотеками и почти всеми база и данных.
Используя UTC, мы можем получать транзакцию в локальном времени пользователя,
переводить это время в UTC и сохранять у себя. И транзакции всегда будут идти
одна за другой.</p>

<p>Правда, существует проблема: UTC учитывает дополнительные секунды, а значит, в
какой-то момент мы можем получить такие транзакции:</p>

<ul>
  <li>Маша Феде перевела 100 рублей 2016-12-31 в 23:59:58</li>
  <li>Федя Юре перевёл 100 рублей 2016-12-31 в 23:59:59</li>
  <li>Юра отправил Майклу 1$ 2016-12-31 в 23:59:60</li>
  <li>Майкл отправил Теду 99$ 2017-01-01 в 00:00:00</li>
</ul>

<p>Скорее всего программа, работающая с UTC, не сможет сказать, что произошло раньше
— вторая транзакция, третья или четвертая. Google, которой очень важна абсолютная
последовательность событий во времени, очень интересно решила эту проблему.
В своих серверах точного времени они добавляют дополнительную секунду не за раз,
а равномерно распределяют её в течение дня в начале года. Это называется
<a href="https://developers.google.com/time/smear">leap smear</a>. Таким образом, раз в год,
когда астрономы объявляют дополнительную секунду, в течение суток сервера точного
времени Google немного отстают от UTC, чтобы набрать дополнительную секунду.</p>

<h2 id="выводы">Выводы</h2>

<ul>
  <li>В любом современном ПК есть процессор, который умеет производить колебания с
равными интервалами.</li>
  <li>Зная период этих колебаний, операционная система компьютера может считать
человеческое время.</li>
  <li>С помощью протокола NTP операционная система может обращаться к серверам
точного времени для скорректировать своих часов.</li>
  <li>Когда компьютер выключен, время считает специальное устройство — RTC, которое
питается от батареи.</li>
  <li>Epoch — это некая дата, от которой принято отсчитывать время вперед или назад.
Разные операционные системы и языки программирования могут выбирать свой собственный
epoch.</li>
  <li>Unix-timestamp — это количество секунд, прошедших с unix-epoch, то есть
с 00:00 1 января 1970 года.</li>
  <li>Никогда не пишите самостоятельно код, который описывает человеческое время.</li>
  <li>Если вам нужна точная последовательность действий во времени, не используйте
часовые зоны. Храните время в UTC и по требованию конвертируйте его.</li>
</ul>

<h2 id="дополнительные-материалы">Дополнительные материалы</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=YuSgZ173Utg">Как компьютеры складывают числа</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/rest-api/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое REST API</turbo:topic> -->
            <title>Что такое REST API</title>
            <pubDate>Wed, 15 Sep 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/rest-api/">Что такое REST API</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/rest-api/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>REST API это HTTP API (иногда говорят WEB API) построенный по принципам REST-архитектуры. Впервые термин REST ввел Рой Филдинг в своей докторской диссертации “Architectural Styles and the Design of Network-based Software Architectures” в 2000 году. Многие обратили на нее серьезное внимание, потому что Рой был не случайным человеком в индустрии. Этот ученый был одним из ключевых разработчиков протокола HTTP/1.0 и автором HTTP/1.1. Он участвовал в разработке языка HTML и стандарта URI. Кроме того, он со-автор некогда самого популярного веб-сервера в мире Apache Web Server.</p>

<p><em>Небольшое отступление. Вокруг REST существует множество домыслов, за которыми потерялась суть и у немалого числа программистов осталось искаженное понимание REST. Во многом, это связано с самим процессом изучения программирования. Разработчики узнают о REST из документации фреймворков, в которых раскрывается лишь несколько деталей за которыми не видно всю картину. Оно и понятно, у фреймворков нет цели учить людей архитектуре, их задача дать инструмент и научить им пользоваться</em></p>

<h2 id="немного-истории">Немного истории</h2>

<p>Прежде чем обсуждать конкретно, что из себя представляют принципы REST, нужно немного поговорить о его истории. Глобально, REST это не про то как делать HTTP API. REST это, то по каким принципам должен был быть построен весь WEB.</p>

<blockquote>
  <p>Since 1994, the REST architectural style has been used to guide the design and development of the architecture for the modern Web. This work was done in conjunction with my authoring of the Internet standards for the Hypertext Transfer Protocol (HTTP) and Uniform Resource Identifiers (URI), the two specifications that define the generic interface used by all component interactions on the Web.<br /><br />— Roy Fielding, Architectural Styles and the Design of Network-based Software Architectures, p. 107.</p>
</blockquote>

<p>То есть не REST появился для того чтобы упорядочить WEB, а WEB стал таким чтобы соответствовать REST.</p>

<p>Термин “REST” был введён Роем Филдингом, одним из создателей протокола “HTTP”, лишь в 2000 году. В своей диссертации “Архитектурные стили и дизайн сетевых программных архитектур” (“Architectural Styles and the Design of Network-based Software Architectures”) в Калифорнийском университете в Ирвайне он подвёл теоретическую основу под способ взаимодействия клиентов и серверов во Всемирной паутине, абстрагировав его и назвав “передачей представительного состояния”.</p>

<p>Чтобы протокол взаимодействия соответствовал REST-стилю, необходимо соблюсти, как минимум, 5 требований. Если сервис соблюдает только часть из них, то про такой протокол говорят, что он REST-like. Если соблюдаются все требования, то протокол является RESTful. На практике, есть ситуации, в которых невозможно следовать REST требованиям, поэтому большинство протоколов являются REST-like, даже если они утверждают другое.</p>

<h2 id="единообразие-интерфейса">Единообразие интерфейса</h2>

<ol>
  <li>Идентификация. В отличие от RPC, в котором протоколы ориентированы на действия, в REST стиле подразумевается ориентация на ресурсы (существительное). Взаимодействие с каждым ресурсом происходит посредством представлений ресурса, запрашиваемых по URN, который идентифицирует конкретный ресурс. То есть, мы никогда не взаимодействуем с самим ресурсом напрямую, а получаем лишь его представления, которых может быть много. Сервер может отдать данные в формате json или html, хотя при этом ни один из них не является реальным типом хранения внутри сервера.</li>
  <li>Манипуляция ресурсами через представление. Если клиент хранит представление ресурса, включая метаданные - он имеет достаточно данных для модификации или удаления ресурса.</li>
  <li>“Самоописываемые” сообщения. Каждое сообщение содержит достаточно информации, чтобы описать, каким образом его обрабатывать. К примеру, какой парсер необходимо применить для извлечения данных, может быть описано в Internet медиа-типе, другими словами, посылая на сервер json в теле http запроса, REST диктует обязательную установку типа контента в заголовке. В общем случае для обработки сообщения должно быть достаточно информации из самого сообщения (всё, что может передаваться по http).</li>
</ol>

<p>По таблице ниже видно, что каждый URN является идентификатором либо одиночного ресурса, либо коллекции ресурсов (это тоже ресурс), а необходимые действия задаются посредством использования подходящего http метода. И всё это должно происходить в строгом соответствии семантике http, другими словами, REST использует то, что заложено в http, а не меняет это или добавляет свое.</p>

<table>
  <thead>
    <tr>
      <th>Метод</th>
      <th>Маршрут</th>
      <th>Описание</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GET</td>
      <td>/photos</td>
      <td>display a list of all photos</td>
    </tr>
    <tr>
      <td>GET</td>
      <td>/photos/new</td>
      <td>return an HTML form for creating a new photo</td>
    </tr>
    <tr>
      <td>POST</td>
      <td>/photos</td>
      <td>create a new photo</td>
    </tr>
    <tr>
      <td>GET</td>
      <td>/photos/:id</td>
      <td>display a specific photo</td>
    </tr>
    <tr>
      <td>GET</td>
      <td>/photos/:id/edit</td>
      <td>return an HTML form for editing a photo</td>
    </tr>
    <tr>
      <td>PATCH/PUT</td>
      <td>/photos/:id</td>
      <td>update a specific photo</td>
    </tr>
    <tr>
      <td>DELETE</td>
      <td>/photos/:id</td>
      <td>delete a specific photo</td>
    </tr>
  </tbody>
</table>

<h2 id="кэширование">Кэширование</h2>

<p>Как и во Всемирной паутине, каждый из клиентов, а также промежуточные узлы между сервером и клиентами могут кэшировать ответы сервера. В каждом запросе клиента должно явно содержаться указание о возможности кэширования ответа и получения ответа из существующего кэша. В свою очередь, ответы могут явно или неявно определяться как кэшируемые или некэшируемые для предотвращения повторного использования клиентами в последующих запросах сохранённой информации. Правильное использование кэширования в REST-архитектуре устраняет избыточные клиент-серверные взаимодействия, что улучшает скорость и расширяемость системы.</p>

<h2 id="отсутствие-состояния">Отсутствие состояния</h2>

<p>Протокол взаимодействия между клиентом и сервером не сохраняет какого-либо сессионного состояния после запроса и ответа (Stateless protocol). В случае необходимости, такое состояние должно сохраняться на клиенте. Только тогда пользователь отвязан от конкретного сервера, что, в свою очередь, позволяет масштабироваться и безболезненно переносить (балансировать) запросы между серверами.</p>

<p>Примером такого состояния является корзина в интернет магазине. Если она привязана к пользовательской сессии и хранится на конкретном сервере (а не в браузере клиента), то отправить запрос пользователя на другой сервер станет невозможно. Он просто не увидит своей корзины. Эту проблему можно решить двумя способами. Первый - хранить её на клиенте, используя, например, cookie. Вторая - изменением способа хранения корзины на сервере и помещением её в базу данных, которая доступна со всех серверов.</p>

<p>На практике сайты активно используют понятие “сессии”, при котором данные могут храниться на стороне сервера, что является нарушением REST.</p>

<h2 id="клиент-серверная-архитектура">Клиент-серверная архитектура</h2>

<p>Разграничение потребностей является принципом, лежащим в основе данного накладываемого ограничения. При отделении потребностей интерфейса клиента от потребностей сервера, хранящего данные, повышается переносимость кода клиентского интерфейса на другие платформы, а при упрощении серверной части улучшается масштабируемость.</p>

<h2 id="слои">Слои</h2>

<p>Клиент может взаимодействовать не напрямую с сервером, а через промежуточные узлы (слои). При этом клиент может не знать об их существовании, за исключением случаев передачи конфиденциальной информации. Промежуточные серверы выполняют балансировку нагрузки и могут использовать дополнительное кэширование.</p>

<h2 id="код-по-требованию-необязательное-ограничение">Код по требованию (необязательное ограничение)</h2>

<p>REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов или сценариев. Филдинг утверждает, что дополнительное ограничение позволяет проектировать архитектуру, поддерживающую желаемую функциональность в общем случае, но возможно за исключением некоторых контекстов.</p>

<h2 id="преимущества-rest">Преимущества REST</h2>

<p>Филдинг указывал, что приложения, не соответствующие приведённым условиям, не могут называться REST-приложениями. Если же все условия соблюдены, то, по его мнению, приложение получит следующие преимущества:</p>

<ul>
  <li>Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента, которая может быть утеряна)</li>
  <li>Производительность (за счёт использования кэша)</li>
  <li>Масштабируемость</li>
  <li>Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети)</li>
  <li>Простота интерфейсов</li>
  <li>Портативность компонентов</li>
  <li>Лёгкость внесения изменений</li>
  <li>Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной паутины)</li>
</ul>

<h2 id="по-простому">По-простому</h2>

<p>Грубо говоря, REST это набор рекомендаций о том, как лучше сделать для получения преимуществ, описанных абзацем выше. Чем больше рекомендаций вы выполните, тем более REST получается приложение. А поскольку жизнь сложна, то это нормально, что REST ориентированными сервисы являются только отчасти. Использования REST как догмы ни к чему хорошему не приведёт. И REST никоим образом не заменяет собой RPC. Выбор решения зависит от ситуации и предъявляемых требований.</p>

<h2 id="jsonapi">JSONAPI</h2>

<p>Хотя REST и выглядит хорошо, он всё же слишком далек от конкретных реализаций и описывает только фундаментальные аспекты взаимодействия. Конкретные способы организации урлов, передаваемые данные, поведение в случае ошибок и многое другое, придётся продумывать самостоятельно.</p>

<p>Есть и другой путь. В 2013 году появился стандарт под названием <a href="https://jsonapi.org">jsonapi</a>, в котором очень подробно описано как создавать <code class="language-plaintext highlighter-rouge">REST</code>-like сервисы. Для его реализации написано множество библиотек под все популярные языки программирования. Как минимум, я рекомендую с ним ознакомиться, а ещё лучше - взять на вооружение. Использование открытых стандартов в промышленном программировании делает нашу жизнь проще, бизнес богаче, а волосы шелковистее.</p>

<!--

## Уровни протоколов

## Семантика HTTP

## От SOAP к REST

## Принципы REST

-->

<h2 id="дополнительные-материалы">Дополнительные материалы</h2>

<ul>
  <li><a href="https://restapitutorial.ru/">Руководство по созданию RESTful-сервиса</a></li>
  <li><a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">Architectural Styles and the Design of Network-based Software Architectures</a></li>
  <li><a href="https://opensource.zalando.com/restful-api-guidelines/">Zalando RESTful API and Event Guidelines</a></li>
  <li><a href="https://habr.com/ru/company/hexlet/blog/595795/">Почему никто не понимает REST</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/deploy/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Deploy (деплой) - что значит «задеплоить на сервер» простыми словами
</turbo:topic> -->
            <title>Deploy (деплой) - что значит «задеплоить на сервер» простыми словами
</title>
            <pubDate>Fri, 11 Jun 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/deploy/">Deploy (деплой) - что значит «задеплоить на сервер» простыми словами
</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/deploy/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Деплой — процесс «разворачивания» веб-сервиса, например, сайта, в рабочем окружении. Рабочее окружение — место, где сайт запускается и доступен для запросов. Это может быть как готовый хостинг, так и своя собственная серверная инфраструктура.</p>

<p><em>Деплоятся не только веб-сервисы, но любые сервисы, доступные по сети. Даже если эта сеть внутренняя и не доступна для запросов через интернет.</em></p>

<p>Для понимания деплоя необходимо разобраться с жизненным циклом кода. Код приложения разрабатывается на рабочей машине разработчика, а запускается в другом месте, называемом продакшеном. Продакшен — это среда запуска (иногда говорят боевая среда). В случае простого приложения она может состоять из одного сервера, а может — из тысяч и десятков тысяч в случае по-настоящему сложных приложений.</p>

<p>Как это происходит. Разработчики добавляют код в репозиторий. В какой-то момент они решают, что пора доставить его до продакшена. Это может происходить как по регулярному расписанию, например раз в две недели, так и просто по необходимости, вплоть до выкатки после каждого изменения. Во многом количество деплоев зависит от уровня его автоматизации — того, насколько процесс легкий в проведении и откате в случае проблем. На Хекслете деплои выполняются практически после каждого изменения, около 3 деплоев в день.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Каждый раз, когда разработчики решили что все, пора, они создают релиз. Под релизом обычно понимают тег в Git, который фиксирует, что уйдет в деплой. То есть изменения, добавленные в мастер после создания тега, не повлияют на сам тег, а значит мы точно уверены в том, что деплоим.</p>

<!-- image -->

<p>Для статических сайтов или отдельного фронтенда (только HTML, CSS и статические файлы) деплой сводится к обновлению кода на сервере. В ситуации деплоя бэкенда, как минимум, подключается база данных. В общем случае деплой может быть сложной процедурой, занимающей приличное время. В распределенных системах, состоящих из множества независимых веб-сервисов, вообще не бывает общего деплоя — каждая часть приложения деплоится (выкатывается) независимо.</p>

<p><em>Стоит сказать, что PaaS-платформы, такие как Heroku, берут деплой полностью на себя. Там достаточно выполнить коммит, и дальше все произойдет само. Цена за это — стоимость самой платформы</em></p>

<h2 id="шаги-деплоя">Шаги деплоя</h2>

<h3 id="доставка-кода-на-сервер">Доставка кода на сервер</h3>

<p>Возможны разные варианты доставки кода на сервер в зависимости от способа его упаковки. Иногда код просто копируют на сервер как набор файлов, но такое встречается редко, чаще он обновляется через Git. Раньше был популярен способ деплоя через стандартные пакетные менеджеры Linux-дистрибутивов. Сейчас он тоже встречается, и для определенных ситуаций подходит лучше всего.</p>

<ul>
  <li>Git: <em>git checkout tag-name</em></li>
  <li>Docker: <em>docker pull image-name:tag-name</em></li>
  <li>Apt (Пакет): <em>apt-install application-package-name</em></li>
</ul>

<h3 id="обновление-базы-данных">Обновление базы данных</h3>

<p>Новая версия приложения, как правило, требует изменений в базе данных. Для этого во время (или до) деплоя запускают миграции — специальные скрипты, содержащие правила обновления базы данных. Например sql-скрипты:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">car</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">license_plate</span> <span class="nb">VARCHAR</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">color</span> <span class="nb">VARCHAR</span> <span class="k">NOT</span> <span class="k">NULL</span>
<span class="p">);</span>

<span class="k">ALTER</span> <span class="k">TABLE</span> <span class="k">owner</span> <span class="k">ADD</span> <span class="n">driver_license_id</span> <span class="nb">VARCHAR</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="запуск-и-остановка">Запуск и остановка</h3>

<p>Где-то в этом процессе происходит остановка старой версии и запуск новой. Если сначала остановить старую версию, а потом выполнить миграции и запустить новую, то мы получим простой (downtime) в работе сервиса. Так действительно работают многие, но это может быть болезненно для бизнеса и частых деплоев. Поэтому самые продвинутые проекты не останавливаются во время деплоя. О том, как это делать — ниже.</p>

<h2 id="автоматизация">Автоматизация</h2>

<p>Деплой нужно максимально автоматизировать, от этого зависит Time To Market, ключевая характеристика бизнес-ориентированных приложений. Чем быстрее и чаще мы доставляем изменения пользователю, тем лучше. Быстрее проверяем гипотезы, быстрее вносим исправления, быстрее оправдываем деньги, вложенные в разработку. Без автоматизации разработчики боятся выполнять деплой, он становится обузой, что приводит к снижению числа деплоев и регулярному стрессу для всей команды, с засиживанием на работе до позднего вечера.</p>

<p>Основных способа автоматизации три:</p>

<ol>
  <li>С помощью утилит, созданных для конкретных языков. Например в Ruby это Capistrano, одна из первых и наиболее известных утилит подобного рода, ставшая популярной далеко за пределами Ruby. Основная проблема с такими инструментами — сильная завязка на язык.</li>
  <li>С помощью Ansible, в который уже <a href="https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html">встроен модуль для деплоя</a>. Идеально подходит для большинства ситуаций деплоя на управляемые сервера.</li>
  <li>Системы оркестрации типа Kubernetes. Если они используются, то без автоматического деплоя никак.</li>
</ol>

<p>Но даже если автоматизация выполнена, все равно остается задача «запустить деплой». Запуск тоже автоматизируется. Существует целый подход, который называется <a href="https://ru.wikipedia.org/wiki/Непрерывная_доставка">Непрерывная доставка</a>(continuous delivery). Его сложно внедрить и он не везде подходит, но если получилось, то про деплой забывают. Он выполняется полностью сам без участия людей. Главное в таком варианте — хороший мониторинг и система оповещения (алертинг) для реакции на ошибки.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1"># https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html#examples</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Initialize the deploy root and gather facts</span>
  <span class="na">community.general.deploy_helper</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/path/to/root</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Clone the project to the new release folder</span>
  <span class="na">ansible.builtin.git</span><span class="pi">:</span>
    <span class="na">repo</span><span class="pi">:</span> <span class="s">ansible.builtin.git://foosball.example.org/path/to/repo.git</span>
    <span class="na">dest</span><span class="pi">:</span> <span class="s1">'</span><span class="s">'</span>
    <span class="na">version</span><span class="pi">:</span> <span class="s">v1.1.1</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Add an unfinished file, to allow cleanup on successful finalize</span>
  <span class="na">ansible.builtin.file</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s1">'</span><span class="s">/'</span>
    <span class="na">state</span><span class="pi">:</span> <span class="s">touch</span>
</code></pre></div></div>

<h2 id="zero-downtime-deployment">Zero Downtime Deployment</h2>

<p>Если не предпринимать специальных шагов, то каждый деплой будет приводить к остановке (возможно частичной) сервиса. В это время пользователи либо увидят ошибку, либо сообщение о происходящем обновлении. Но такого не происходит на большинстве крупных сервисов в интернете. Почему? Из-за реализации подхода «деплой без даунтайма» (downtime — простои в работе сервиса).</p>

<p>Zero Downtime Deployment выглядит так, как будто сервис никогда не останавливается, но при этом обновляется. Достигается это за счет одновременного запуска старой версии и новой кода. То есть когда деплоится приложение, то сначала поднимается новая версия рядом со старой. И только когда автоматика убеждается, что новая версия запустилась и работает, происходит остановка старой версии. Для выполнения этой процедуры понадобится следующее:</p>

<ol>
  <li>Инфраструктура. Нужен балансировщик, который может переключать трафик (входящие соединения от браузеров или других систем) между старой и новой версией кода. И желательно иметь как минимум два сервера, хотя это и не обязательно.</li>
  <li>Деплой. Процесс деплоя без простоя значительно сложнее, чем с остановкой. Проще всего такой деплой делается на системах оркестрации, например, Kubernetes.</li>
  <li>Культура кода. Обеспечить безостановочную работу невозможно без определенной культуры написания кода. Чтобы старая и новая версия могли работать одновременно, нужно следить за всеми интерфейсами. Важно соблюдение обратной совместимости (работа с api, базой, очередьми и, в целом, любыми хранилищами).</li>
  <li>База данных. Она должна быть обратна совместима между старой и новой версией. Все миграции только вперед (их нельзя откатывать!) и только на добавление. Нельзя удалять и обновлять (переименовывать, менять тип) колонки и таблицы</li>
</ol>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">extensions/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">tomcat-deployment-${TARGET_ROLE}</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">tomcat</span>
        <span class="na">role</span><span class="pi">:</span> <span class="s">${TARGET_ROLE}</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">tomcat-container</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">tomcat:${TOMCAT_VERSION}</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">8080</span>
        <span class="na">readinessProbe</span><span class="pi">:</span>
          <span class="na">httpGet</span><span class="pi">:</span>
            <span class="na">path</span><span class="pi">:</span> <span class="s">/</span>
            <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre></div></div>

<h2 id="дополнительная-литература">Дополнительная литература</h2>

<ul>
  <li><a href="https://twitter.com/mokevnin/status/1491429628854272002">Подробнее про Zero Downtime Deployment</a></li>
  <li><a href="https://bronevichok.ru/posts/engineering-at-booking.com.html">Инжиниринг в Booking</a></li>
  <li><a href="https://habr.com/ru/company/flant/blog/471620/">Стратегии деплоя</a></li>
  <li><a href="https://www.youtube.com/watch?v=WPCz_U7D8PI">Stateless vs Statefull</a></li>
  <li><a href="https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html">Ansible Deploy</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/environment">Среды разработки</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/usefull-twitter-threads/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Полезные треды в твиттере</turbo:topic> -->
            <title>Полезные треды в твиттере</title>
            <pubDate>Thu, 10 Jun 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/usefull-twitter-threads/">Полезные треды в твиттере</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/usefull-twitter-threads/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <h2 id="про-tdd">Про TDD</h2>

<blockquote>
  <p>Про TDD. Я часто пишу тесты до кода, но при этом не работаю по TDD. Почему? Небольшой тред</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1353796108594671617">Ссылка на тред</a></p>

<h2 id="мифы-вокруг-ооп">Мифы вокруг ООП</h2>

<blockquote>
  <p>Метатред по серии “Мифы В ООП”, в которой я постарался раскрыть тему со всех сторон, от разных людей/языков/эпох. Виды ооп, полиморфизм, паттерны и многое другое. #oopmyths</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1376234798465871874">Ссылка на тред</a></p>

<h2 id="автоматное-программирование">Автоматное программирование</h2>

<blockquote>
  <p>Метатред по серии “Автоматное программирование”. Рассказываю тут про флаговое программирование, явно выделенное состояние, автоматы на бекенде, автоматы на фронтенде и кидаюсь кучей полезнях #FSM</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1392160550113660935">Ссылка на тред</a></p>

<h2 id="о-функциях">О Функциях</h2>

<blockquote>
  <p>Поехали! Обычно, от функций ожидают сокращения дублирования кода. Да, функции устраняют дублирование, но лишь в дополнение к тому, зачем они нужны. Настоящий смысл функции – повышение уровня абстракции. Звучит немного абстрактно, поэтому раскроем подробнее =&gt;</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1396824737540722688">Ссылка на тред</a></p>

<h2 id="идемпотентность">Идемпотентность</h2>

<blockquote>
  <p>Идемпотентность – это свойство какой-либо операции, например, вызова функции или выполнения HTTP-запроса. Операция считается идемпотентной, если повторные выполнения приводят к тому же результату что и первое выполнение. Рассмотрим кучку примеров из самых разных направлений =&gt;</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1417041597041086465">Ссылка на тред</a></p>

<h2 id="полезные-концепции-в-языках-программирования">Полезные концепции в языках программирования</h2>

<blockquote>
  <p>тред про концепции в разных языках программирования, которые помогают лучше понять возможности кодинга как-такового. Многие из этих концепций сильно облегчают жизнь и кардинально меняют способы описания логики</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1429535061838372873">Ссылка на тред</a></p>

<h2 id="какая-часть-кода-должна-быть-всегда-чистой-а-где-допускается-грязь">Какая часть кода должна быть всегда чистой, а где допускается грязь</h2>

<blockquote>
  <p>Делаю тред про то как понимать критичность разных кусков кода при разработке и ревью. Что от чего зависит, где можно и нужно забить, а где нет</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1433474955036012547">Ссылка на тред</a></p>

<h2 id="куда-развиваться-фронтенд-инженеру">Куда развиваться фронтенд инженеру</h2>

<blockquote>
  <p>Ко мне переодически приходят ребята с вопросами “я пишу на реакте, но думаю куда развиваться, что делать дальше”. И хотя универсального ответа на этот вопрос нет, я таки попробую накинуть то, куда бы пошел сам и что может сделать из вас более лучших инженеров</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1427304920466825216">Ссылка на тред</a></p>

<h2 id="zero-downtime-deployment">Zero Downtime Deployment</h2>

<blockquote>
  <p>Небольшой ликбез. Деплой – процесс выкладки новой версии кода. В простом случае выглядит как: закрыли сайт с сообщением “мы обновляемся” &gt; накатили изменения в базу данных (миграции) &gt; обновили код на серверах &gt; рестартанули сервер &gt; открыли сайт. У кого так лайкаем)</p>
</blockquote>

<p><a href="https://twitter.com/mokevnin/status/1491429628854272002">Ссылка на тред</a></p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/configuration-management/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое «управление конфигурацией»</turbo:topic> -->
            <title>Что такое «управление конфигурацией»</title>
            <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/configuration-management/">Что такое «управление конфигурацией»</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/configuration-management/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Сайты это не только код, но и инфраструктура для их запуска. В первую очередь, в нее входят сервера, на которых крутится код, база данных и различные вспомогательные системы. Иногда все это помещается на один сервер, в более сложных ситуациях количество серверов измеряется тысячами, а для обслуживания таких систем привлекаются целые команды инженеров (разного рода администраторов). Независимо от размера сайта, проблемы обслуживания инфраструктуры у всех очень похожие. Поговорим об одной конкретной – настройке сервера.</p>

<p><em>Существуют подходы, которые позволяют избежать прямого взаимодействия с инфраструктурой. В рамках статьи они не рассматриваются, но знать про них полезно. К ним относятся: классические хостинги с предустановленным софтом, serverless, хостинги статических сайтов, PaaS решения и kubernetes (и его аналоги)</em></p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>В подавляющем большинстве случаев, сервера арендуются у хостинговых компаний, таких как <a href="https://m.do.co/c/e702f9a99145">DigitalOcean</a> или AWS. Делается это за 5 минут нажатием буквально нескольких кнопок. Нас попросят выбрать характеристики сервера, операционную систему и датацентр, в котором он будет развернут. В результате, мы получаем машину (виртуальную), с предустановленной операционной системой и ip-адресом для входа по ssh.</p>

<!-- image: DO -->

<p>Новая машина содержит только основную операционную систему с небольшим набором предустановленных программ. Перед тем как запустить на ней какой-то сервис, например, обычный сайт, понадобится установить дополнительные пакеты. Набор пакетов зависит от стека технологий, на котором он написан. Если сайт “завернут” в Docker, то настройка значительно упрощается и сводится к установке самого Docker. В остальных случаях придется потратить какое-то время на донастройку и конфигурирование. Помимо пакетов, часто требуется настраивать саму систему, менять конфигурационные файлы, права на файлы и директории, создавать пользователей и так далее:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Как это могло бы быть</span>
<span class="c"># Сервер на Ubuntu</span>

<span class="c"># Заходим на удаленную машину</span>
ssh root@ipaddress

<span class="c"># Создание пользователя для деплоя</span>
<span class="c"># Где-то здесь копируются ssh ключи</span>
<span class="nb">sudo </span>adduser deploy

<span class="nb">sudo </span>apt <span class="nb">install </span>curl
<span class="c"># установка Node.js</span>
curl <span class="nt">-fsSL</span> https://deb.nodesource.com/setup_16.x | <span class="nb">sudo</span> <span class="nt">-E</span> bash -
<span class="nb">sudo </span>apt <span class="nb">install </span>nodejs
<span class="c"># установка и настройка Nginx</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>nginx
vim /etc/nginx/default.conf

<span class="c"># Формирование структуры директорий для сервиса</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /opt/hexlet/versions/
</code></pre></div></div>

<p>Процесс первоначальной настройки занимает часы и даже дни. Постоянно придется что-то подкручивать, донастраивать и устанавливать. Цикл повториться снова, когда понадобится перейти на новые версии пакетов. Снова придется заходить на сервер, вспоминать что и где настраивалось и как мягко обновиться ничего не сломав. В чем проблема ручной настройки?</p>

<p>Сервера могут умирать и делать это внезапно. Сколько времени уйдет на “раскатку” нового сервера? Практически столько же времени, сколько было потрачено первый раз. Порядок действий и нужные настройки просто никто не вспомнит даже через неделю после настройки, что уже говорить если прошли месяцы. Более того, вдруг тот кто изначально это делал уже не работает в компании или находится в отпуске. Что тогда? Придется долго извиняться перед пользователями за длительный простой и хорошо если бизнес от этого пострадает не сильно.</p>

<p>Переустановка сервера не обязательно связана с какими-то форс-мажорными обстоятельствами. В компаниях с хорошей инженерной культурой, сервера меняются на регулярной основе. Как минимум это важно для безопасности. Операционные системы содержат уязвимости, которые закрываются новыми пакетами или версиями. Следить за этим довольно сложно, поэтому проще регулярно освежать инфраструктуру. С другой стороны, обновление сервера может легко сломать рабочее приложение и вызвать простой в работе. Единственный способ гарантировать беспрерывную работу во время обновления – поднимать рядом еще один сервер и настраивать его. Затем сервис просто выкатывается на новый сервер, а старый выключается.</p>

<h2 id="автоматизация">Автоматизация</h2>

<p>Хорошо бы было автоматизировать настройку сервера. Для этого существует несколько подходов, которые мы рассмотрим ниже.</p>

<h3 id="bash-скрипты">Bash-скрипты</h3>

<p>В простейшем случае для этого достаточно обычного Bash-скрипта, в который последовательно добавляются команды, которые ранее мы запускали руками. Затем все сводится к копированию скрипта на сервер и запуску:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Копирование на сервер с помощью scp</span>
scp mybashscript.sh root@ipaddress:~/

<span class="c"># Заходим на сервер и запускаем скрипт</span>
ssh root@ipaddress
sh ~/mybashscript.sh
</code></pre></div></div>

<p>Если перенести команды в bash-скрипт “как есть”, без модификации, то, скорее всего, нам придется постоянно следить за выводом и не забывать подтверждать установку пакетов, так как это поведение по умолчанию:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>➜  ~ apt <span class="nb">install </span>golang
The following additional packages will be installed:
  golang-1.13 golang-1.13-doc golang-1.13-go golang-1.13-race-detector-runtime golang-1.13-src golang-doc golang-go
Need to get 63.5 MB of archives.
After this operation, 329 MB of additional disk space will be used.
Do you want to <span class="k">continue</span>? <span class="o">[</span>Y/n] <span class="c"># Скрипт останавливается и ждет ответа</span>
</code></pre></div></div>

<p>Автоматическое “да” добавляется опцией <code class="language-plaintext highlighter-rouge">-y</code>. У других команд свои опции для подавления взаимодействия с пользователем. Придется их все учесть.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>apt <span class="nb">install</span> <span class="nt">-y</span> golang
</code></pre></div></div>

<p>Другая проблема серьезнее, она связана с понятием “идемпотентность”. Что будет если выполнить команду создания директории два раза?</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">mkdir</span> /hexlet
<span class="nb">mkdir</span> /hexlet <span class="c"># ?</span>
</code></pre></div></div>

<p>Команда завершится с ошибкой, она не идемпотентна. То есть последовательные вызовы одной и той же команды приводят к разному результату. Идемпотентность для настройки сервера <a href="https://ru.hexlet.io/blog/posts/pochemu-vazhna-idempotentnost-i-kak-pisat-idempotentnye-bash-skripty">очень важна</a>. Иначе повторный запуск скрипта настройки завершится с ошибкой. А повторные запуски нужны, например в случае отладки самого скрипта, когда мы его только пишем и проверяем как он работает. В случае с командой <code class="language-plaintext highlighter-rouge">mkdir</code> идемпотентности добиться легко, достаточно добавить флаг <code class="language-plaintext highlighter-rouge">-p</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">mkdir</span> <span class="nt">-p</span> /hexlet
<span class="nb">mkdir</span> <span class="nt">-p</span> /hexlet <span class="c"># ошибки не будет</span>
</code></pre></div></div>

<p>Но, к сожалению не все команды поддерживают такую возможность. Для многих ситуаций, идемпотентность нужно обеспечивать самостоятельно, что резко усложнит скрипт. Из простого набора команд он превратиться в реальный код с условными конструкциями. И в какой-то момент разбираться в нем станет крайне сложно. Через это проходили многие, особенно раньше, когда не было альтернативы.</p>

<p>Но дело не только в идемпотентности. Часть задач, которые легко делались руками, становятся сложными в автоматизации. Представьте, что для изменения конфигурации нужно поправить конкретную строчку внутри файла. Как это легко сделать с помощью bash? Никак, придется либо полностью заменять файл копируя всего содержимое в bash-скрипт (или рядом с ним), либо использовать, что-то вроде sed для точечной замены строки.</p>

<p>И последнее, но очень важное ограничение. Bash-скрипт нужно доставить на сервер самостоятельно. И если для одного сервера это еще как-то можно автоматизировать, то для нескольких “раскатка” скрипта становится проблемой. Становится важно делать это параллельно иначе настройка растягивается на часы даже в случае полной автоматизации. Добавьте сюда разные сервера со своими скриптами, которые отличаются от других.</p>

<p>На этом этапе bash-скрипты перестают помогать, нужно придумывать что-то еще. Так стали появляться специализированные инструменты для конфигурирования серверов. Одними из первых были проекты Chef и Puppet. Сейчас же, наибольшую популярность приобрел Ansible, который значительно проще в освоении и использовании.</p>

<h2 id="ansible">Ansible</h2>

<p>Система управления конфигурацией (серверов), которая решает все проблемы описанные выше и, даже больше, может использоваться не только для настройки, но и для деплоя, то есть установки и запуска сервиса. Для установки Ansible воспользуйтесь одним из <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html">предложенных способов</a></p>

<p>В минимальном виде, Ansible конфигурация выглядит как два файла, один – описание серверов, второй – команды, которые мы хотим выполнить. Ansible сам подключается к удаленным серверам и выполняет необходимые команды. Главное дать доступ к этим серверам, например с помощью ssh-ключей.</p>

<p>Описание серверов хранится в файле <em>inventory.ini</em>. Ansible использует его для определения машин, на которые нужно выполнить установку.</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c">; адрес машины, которую настраиваем
; для простоты говорим Ansible использовать локальный компьютер
</span><span class="err">127.0.0.1</span> <span class="py">ansible_connection</span><span class="p">=</span><span class="s">local</span>
</code></pre></div></div>

<p>Команды настройки сервера записываются в файлы называемые плейбуками. Плейбуки создаются в формате yaml под любым именем. Например playbook.yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1"># hosts – означает группу машин, на которой нужно выполниться</span>
<span class="c1"># all – означает все описанные в inventory.ini</span>
<span class="pi">-</span> <span class="na">hosts</span><span class="pi">:</span> <span class="s">all</span>
  <span class="na">tasks</span><span class="pi">:</span> <span class="c1"># набор команд которые нужно выполнить</span>
    <span class="pi">-</span> <span class="na">ansible.builtin.file</span><span class="pi">:</span> <span class="c1"># file – управляет файлами и директориями</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">/tmp/ansible_was_here</span>
        <span class="na">state</span><span class="pi">:</span> <span class="s">touch</span> <span class="c1"># выполнит команду touch если файла не существует. И – идемпотентность</span>
</code></pre></div></div>

<p>Файловая структура может выглядеть так:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>tree <span class="c"># вывод содержимого директории</span>
<span class="nb">.</span>
├── inventory.ini
└── playbook.yaml
</code></pre></div></div>

<p>Теперь запускаем:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Запуск Ansible идет на локальной машине!</span>
<span class="c"># Запускать нужно в той же директории, где созданы файлы</span>
<span class="c"># -i означает inventory.ini</span>
<span class="c"># https://github.com/hexlet-boilerplates/ansible</span>
ansible-playbook <span class="nt">-i</span> inventory.ini playbook.yaml

PLAY <span class="o">[</span>Server Setup] <span class="k">***********************************************************************************************************</span>

TASK <span class="o">[</span>Gathering Facts] <span class="k">********************************************************************************************************</span>
ok: <span class="o">[</span>127.0.0.1]

TASK <span class="o">[</span>file] <span class="k">*******************************************************************************************************************</span>
changed: <span class="o">[</span>127.0.0.1]

PLAY RECAP <span class="k">********************************************************************************************************************</span>
127.0.0.1                  : <span class="nv">ok</span><span class="o">=</span>2    <span class="nv">changed</span><span class="o">=</span>1    <span class="nv">unreachable</span><span class="o">=</span>0    <span class="nv">failed</span><span class="o">=</span>0    <span class="nv">skipped</span><span class="o">=</span>0    <span class="nv">rescued</span><span class="o">=</span>0    <span class="nv">ignored</span><span class="o">=</span>0

</code></pre></div></div>

<p>Вывод говорит о том, что плейбук успешно выполнен. В результате в директории <em>/tmp</em> окажется файл <em>ansible_was_here</em>. Повторный запуск плейбука тоже закончится успешно, но из вывода будет видно, что он не сделает никаких изменений, так как Ansible сам обеспечивает идемпотентность. В данном случае, он проверит наличие файла и пропустит команду если файл существует. Если в <em>inventory.ini</em> указать несколько ip-адресов, то Ansible выполнит плейбук на каждом из них, причем сделает это параллельно. Единственное о чем нужно не забыть – добавить ssh-ключи на эти машины, иначе Ansible не сможет до них достучаться.</p>

<p><img src="/assets/images/configuration-management/ansible.png" alt="Ansible" /></p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/ansible?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Курс по Ansible с практикой прямо в браузере</a>
</div>

<p>Что из себя представляет плейбук? Главное внутри него – набор задач (tasks), которые мы хотим выполнить. В отличии от bash-скрипта, задачи это не просто bash-команды. На каждую задачу в Ansible встроен модуль для работы с определенной частью системы. Например внутри Ansible есть модули для работы с git, пакетными менеджерами, файлами и тому подобным. Всего их сотни на все случаи жизни. Именно благодаря готовым интеграциям, Ansible знает как работают те или иные части системы, что позволяет добавить нужные проверки для обеспечения идемпотентности. Пара примеров:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="na">tasks</span><span class="pi">:</span>
  <span class="c1"># Установка postgresql</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Ensure postgresql is at the latest version</span>
    <span class="na">ansible.builtin.apt</span><span class="pi">:</span> <span class="c1"># модуль apt</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">postgresql</span>
      <span class="na">state</span><span class="pi">:</span> <span class="s">latest</span>

  <span class="c1"># Запуск postgresql</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Ensure that postgresql is started</span>
    <span class="na">ansible.builtin.service</span><span class="pi">:</span> <span class="c1"># модуль service</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">postgresql</span>
      <span class="na">state</span><span class="pi">:</span> <span class="s">started</span> <span class="c1"># запускаем если не запущен</span>
</code></pre></div></div>

<p>Как видите, Ansible достаточно прост для начала, при этом у него много возможностей, которые можно изучать по мере погружения и усложнения инфраструктуры.</p>

<h2 id="итого">Итого</h2>

<p>Управление конфигурацией, в современном мире, выполняется с помощью специализированных программ, которые умеют подключаться к удаленным серверам, параллельно настраивать их обеспечивая идемпотентность операций. При таком подходе важно перестать настраивать сервера напрямую. Любые изменения теперь должны делаться через инструмент автоматизации, иначе все вернется к изначальным проблемам. Управление конфигурацией через код повышает взаимозаменяемость людей, позволяет легко отслеживать изменения просто просматривая историю git, подключать других членов команды к управлению инфраструктурой.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li>https://github.com/hexlet-boilerplates/ansible</li>
  <li><a href="https://ru.hexlet.io/courses/ansible">Основы автоматизации в Ansible</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/logging/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое логирование</turbo:topic> -->
            <title>Что такое логирование</title>
            <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/logging/">Что такое логирование</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/logging/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Известно, что программисты проводят много времени, отлаживая свои программы, пытаясь разобраться, почему они не работают — или работают неправильно. Когда говорят про отладку, обычно подразумевают либо отладочную печать, либо использование специальных программ – дебагеров. С их помощью отслеживается выполнение кода по шагам, во время которого видно, как меняется содержимое переменных. Эти способы хорошо работают в небольших программах, но в реальных приложениях быстро становятся неэффективными.</p>

<p><img src="/assets/images/logging/debugger.png" alt="Дебагер JavaScript в WebStorm" /></p>

<h2 id="сложность-реальных-приложений">Сложность реальных приложений</h2>

<p>Возьмем для примера типичный сайт. Что он в себя включает?</p>

<ul>
  <li><a href="https://guides.hexlet.io/dns/">DNS</a>. Система трансляции имени сайта в ip-адрес сервера.</li>
  <li>Веб-сервер. Программа, обслуживающая входящие запросы, перенаправляет их в код приложения и забирает от приложения данные для пользователей.</li>
  <li>Физический сервер (или виртуальный) с его окружением. Включает в себя операционную систему, установленные и запущенные обслуживающие программы, например, мониторинг.</li>
  <li>База данных. Внешнее хранилище, с которым связывается код приложения и обменивается информацией.</li>
  <li>Само приложение. Помимо кода, который пишут программисты, приложение включает в себя сотни тысяч и миллионы строк кода сторонних библиотек. Кроме этого, код работает внутри фреймворка, у которого свои собственные правила обработки входящих запросов.</li>
  <li>Фронтенд часть. Код, который выполняется в браузере пользователя. И системы сборки для разработки, например, <a href="https://guides.hexlet.io/webpack/">Webpack</a>.</li>
</ul>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>И это только самый простой случай. Реальность же значительно сложнее: множество разноплановых серверов, системы кеширования (ускорения доступа), асинхронный код, очереди, внешние сервисы, облачные сервисы. Все это выглядит как многослойный пирог, внутри которого где-то работает написанный нами код. И этот код составляет лишь небольшую часть всего происходящего. Как в такой ситуации понять, на каком этапе был сбой, или все пошло не по плану? Для этого, как минимум, нужно определить, в каком слое произошла ошибка. Но даже это не самое сложное. Об ошибках в работающем приложении узнают не сразу, а уже потом, — когда ошибка случилась и, иногда, больше не воспроизводится.</p>

<h2 id="логирование">Логирование</h2>

<p>И для всего этого многообразия систем существует единое решение — логирование. В простейшем случае логирование сводится к файлу на диске, куда разные программы записывают (логируют) свои действия во время работы. Такой файл называют логом или журналом. Как правило, внутри лога одна строчка соответствует одному действию.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Формат: ip-address / date / HTTP-method / uri / response code / body size </span>
173.245.52.110 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /my HTTP/1.1"</span> 200 46018
108.162.219.13 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /sockjs-node/244/gdt1vvwa/websocket HTTP/1.1"</span> 0 0
162.158.62.12 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /packs/css/application.css HTTP/1.1"</span> 304 0
162.158.62.84 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /packs/js/runtime-eb0a99abbe8cf813f110.js HTTP/1.1"</span> 304 0
108.162.219.111 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /packs/js/application-2cba5619945c4e5946f1.js HTTP/1.1"</span> 304 0
108.162.219.21 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /packs/js/0564a7b5d773bab52e53.js HTTP/1.1"</span> 304 0
108.162.219.243 - <span class="o">[</span>19/Jan/2021:01:54:20 +0000] <span class="s2">"GET /packs/js/6fb7e908211839fac06e.js HTTP/1.1"</span> 304 0
</code></pre></div></div>

<p>Выше небольшой кусок лога веб-сервера Хекслета. Из него видно ip-адрес, с которого выполнялся запрос на страницу и какие ресурсы загружались, метод HTTP, ответ бекенда (кода) и размер тела ответа в HTTP. Очень важно наличие даты. Благодаря ей всегда можно найти лог за конкретный период, например на то время, когда возникла ошибка. Для этого логи <a href="https://ru.hexlet.io/courses/cli-basics/lessons/grep/theory_unit">грепают</a>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Выведет 4 минуты логов за 31 марта 2020 года с 19:31 по 19:35</span>
<span class="nb">grep</span> <span class="s2">"31/Mar/2020:19:3[1-5]"</span> access.log
</code></pre></div></div>

<p>Когда программисты только начинают свой путь, они, часто не зная причину ошибки, опускают руки и говорят «я не знаю, что случилось, и что делать». Опытный же разработчик всегда первым делом говорит «а что в логах?». Анализировать логи — один из базовых навыков в разработке. В любой непонятной ситуации нужно смотреть логи. Логи пишут все программы без исключения, но делают это по-разному и в разные места. Чтобы точно узнать, куда и как, нужно идти в документацию конкретной программы и читать соответствующий раздел документации. Вот несколько примеров:</p>

<ul>
  <li><a href="https://guides.rubyonrails.org/debugging_rails_applications.html#the-logger">Ruby On Rails (Ruby)</a></li>
  <li><a href="https://docs.djangoproject.com/en/3.1/topics/logging/">Django (Python)</a></li>
  <li><a href="https://laravel.com/docs/8.x/logging">Laravel (PHP)</a></li>
  <li><a href="https://docs.spring.io/spring-boot/docs/2.1.18.RELEASE/reference/html/boot-features-logging.html">Spring Boot (Java)</a></li>
  <li><a href="https://www.fastify.io/docs/v2.0.x/Logging/">Fastify (Node.js)</a></li>
</ul>

<p>Многие программы логируют прямо в консоль, например Webpack показывает процесс и результаты сборки:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Сюда же выводятся ошибки, если они были</span>
｢wds｣: Project is running at http://hexletdev4.com/
｢wds｣: webpack output is served from /packs/
｢wds｣: Content not from webpack is served from /root/hexlet/public/packs
｢wds｣: 404s will fallback to /index.html
｢wdm｣: assets by chunk 10.8 MiB <span class="o">(</span>auxiliary name: application<span class="o">)</span> 115 assets
sets by path js/ 13.8 MiB
assets by path js/<span class="k">*</span>.js 13.8 MiB 52 assets
assets by path js/pages/<span class="k">*</span>.js 5.1 KiB
  asset js/pages/da223d3affe56711f31f.js 2.6 KiB <span class="o">[</span>emitted] <span class="o">[</span>immutable] <span class="o">(</span>name: pages/my_learning<span class="o">)</span> 1 related asset
  asset js/pages/04adacfdd660803b19f1.js 2.5 KiB <span class="o">[</span>emitted] <span class="o">[</span>immutable] <span class="o">(</span>name: pages/referral<span class="o">)</span> 1 related asset
sets by chunk 9.14 KiB <span class="o">(</span>auxiliary <span class="nb">id </span>hint: vendors<span class="o">)</span>
</code></pre></div></div>

<p>Во фронтенде файлов нет, поэтому логируют либо прямо в консоль, либо к себе в бекенды (что сложно), либо в специализированные сервисы, такие как <a href="https://logrocket.com/">LogRocket</a>.</p>

<h2 id="уровни-логирования">Уровни логирования</h2>

<p>Чем больше информации выводится в логах, тем лучше и проще отладка, но когда данных слишком много, то в них тяжело искать нужное. В особо сложных случаях логи могут генерироваться с огромной скоростью и в гигантских размерах. Работать в такой ситуации нелегко. Чтобы как-то сгладить ситуацию, системы логирования вводят разные уровни. Обычно это:</p>

<ul>
  <li>debug</li>
  <li>info</li>
  <li>warning</li>
  <li>error</li>
</ul>

<p>Поддержка уровней осуществляется двумя способами. Во-первых, внутри самой программы расставляют вызовы библиотеки логирования в соответствии с уровнями. Если произошла ошибка, то логируем как <em>error</em>, если это отладочная информация, которая не нужна в обычной ситуации, то уровень <em>debug</em>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// Пример логирования внутри программы</span>
<span class="c1">// Логер: https://github.com/pinojs/pino</span>

<span class="k">import</span> <span class="nx">buildLogger</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">pino</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">buildLogger</span><span class="p">(</span><span class="cm">/* возможная конфигурация */</span><span class="p">);</span>
<span class="nx">logger</span><span class="p">.</span><span class="nx">info</span><span class="p">(</span><span class="dl">'</span><span class="s1">тут что то полезное</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>Во-вторых, во время запуска программы указывается уровень логирования, необходимый в конкретной ситуации. По умолчанию используется уровень <em>info</em>, который используется для описания каких-то ключевых и важных вещей. При таком уровне будут выводиться и <em>warning</em>, и <em>error</em>. Если поставить уровень <em>error</em>, то будут выводиться только ошибки. А если <em>debug</em>, то мы получим лог, максимально наполненный данными. Обычно <em>debug</em> приводит к многократному росту выводимой информации.</p>

<p>Уровни логирования, обычно, выставляются через переменную окружения во время запуска программы. Например, так:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># https://github.com/fastify/fastify-cli#options</span>
<span class="nv">FASTIFY_LOG_LEVEL</span><span class="o">=</span>debug fastify-server.js
</code></pre></div></div>

<p>Существует и другой подход, основанный не на уровнях, а на пространствах имен. Этот подход получил широкое распространение в JS-среде, и является там основным. Фактически, он построен вокруг одной единственной библиотеки <a href="https://github.com/visionmedia/debug">debug</a> для логирования, которой пронизаны практически все JavaScript-библиотеки как на фронтенде, так и на бекенде.</p>

<p><img src="/assets/images/logging/debug.png" alt="Библиотека debug в JavaScript" /></p>

<p>Принцип работы здесь такой. Под нужную ситуацию создается специализированная функция логирования с указанием пространства имен, которая затем используется для всех событий одного процесса. В итоге библиотека позволяет легко отфильтровать только нужные записи, соответствующие нужному пространству.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">import</span> <span class="nx">debug</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">debug</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// Пространство имен http</span>
<span class="kd">const</span> <span class="nx">logHttp</span> <span class="o">=</span> <span class="nx">debug</span><span class="p">(</span><span class="dl">'</span><span class="s1">http</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">logSomethingElse</span> <span class="o">=</span> <span class="nx">debug</span><span class="p">(</span><span class="dl">'</span><span class="s1">another-namespace</span><span class="dl">'</span><span class="p">);</span>

<span class="c1">// Где-то в коде</span>

<span class="nx">logHttp</span><span class="p">(</span><span class="cm">/* информация о http запросе */</span><span class="p">);</span>
</code></pre></div></div>

<p>Запуск с нужным пространством:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">DEBUG</span><span class="o">=</span>http server.js
</code></pre></div></div>

<p><img src="/assets/images/logging/debug-http.png" alt="Библиотека debug для логирования http в JavaScript" /></p>

<h2 id="ротация-логов">Ротация логов</h2>

<p>Со временем количество логов становится большим, и с ними нужно что-то делать. Для этого используется ротация логов. Иногда за это отвечает сама программа, но чаще — внешнее приложение, задачей которого является чистка. Эта программа по необходимости разбивает логи на более мелкие файлы, сжимает, перемещает и, если нужно, удаляет. Подобная система встроена в любую операционную систему для работы с логами самой системы и внешних программ, которые могут встраиваться в нее.</p>

<p>С веб-сайтами все еще сложнее. Даже на небольших проектах используется несколько серверов, на каждом из которых свои логи. А в крупных проектах тысячи серверов. Для управления такими системами созданы специализированные программы, которые следят за логами на всех машинах, скачивают их, складывают в заточенные под логи базы данных и предоставляют удобный способ поиска по ним.</p>

<p>Здесь тоже есть несколько путей. Можно воспользоваться готовыми решениями, такими как <a href="https://docs.datadoghq.com/logs/">DataDog Logging</a>, либо устанавливать и настраивать все самостоятельно через, например, <a href="https://www.elastic.co/elastic-stack">ELK Stack</a></p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/hosting/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое хостинг и домен сайта простыми словами</turbo:topic> -->
            <title>Что такое хостинг и домен сайта простыми словами</title>
            <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/hosting/">Что такое хостинг и домен сайта простыми словами</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/hosting/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <h2 id="доменное-имя-домен">Доменное имя (домен)</h2>

<p>Когда интернет только зарождался, у сайтов не было доменных имён. Для обращения к сайту использовались прямые IP-адреса машин (серверов), например, 10.132.234.4 (вместо понятного hexlet.io). Довольно быстро стало понятно, что это слишком сложно для запоминания. К тому же адреса могли меняться. Нужно было что-то вроде записной книжки для адресов.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Первым решением стал специальный файл <em>hosts</em>, расположенный на каждой машине, с которой происходил доступ к сайтам. Он содержит сопоставление между IP-адресом и именем, удобным для запоминания. Этот файл существует до сих пор и часто используется программистами во время разработки. Формат файла:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="syntax"><code># Формат файла: &lt;ip-адрес&gt; &lt;имена сайта&gt;
34.117.253.138 hexlet.io
172.10.11.200 facebook.com m.facebook.com
</code></pre></div></div>

<p>Когда происходит запрос по адресу, например, hexlet.io, то сначала проверяется файл <em>hosts</em>, и если домен найден (как в примере выше), то браузер устанавливает соединение с сервером. В нашем примере он пойдёт по адресу <code class="language-plaintext highlighter-rouge">34.117.253.138</code>.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Пример обращения к DNS с помощью утилиты host</span>
host hexlet.io
hexlet.io has address 34.117.253.138
hexlet.io mail is handled by 10 alt4.aspmx.l.google.com.
hexlet.io mail is handled by 1 aspmx.l.google.com.
hexlet.io mail is handled by 10 alt3.aspmx.l.google.com.
hexlet.io mail is handled by 5 alt1.aspmx.l.google.com.
hexlet.io mail is handled by 5 alt2.aspmx.l.google.com.
</code></pre></div></div>

<p>Такой подход оказался очень неэффективен. В каждой подсети использовался собственный файл hosts, который рассылался на все компьютеры, входящие в подсеть. Кроме того, если появляется новый сайт, то всех нужно оповестить. Да и самих сайтов становилось слишком много. Для решения этих проблем создали Domain Name System (DNS). Основное предназначение этой системы заключается в сопоставлении имени домена конкретному IP-адресу, на котором находится сайт. Другими словами, любой сервис может обратиться к DNS и спросить «какой IP-адрес у домена hexlet.io?».</p>

<p><img src="/assets/images/hosting/dns.png" alt="Как работает DNS" /></p>

<p>Важно понимать, что DNS — это именно служба, а не конкретный сервер. Так как весь интернет зависит от стабильности работы этой системы, то в неё входит множество серверов по всему миру. Кроме того, DNS устроена таким образом, что нет центральной организации, управляющей этими серверами. Подробнее о DNS прочитайте в <a href="https://guides.hexlet.io/dns/">нашем гайде</a>.</p>

<h2 id="хостинг">Хостинг</h2>

<p>Интернет — это глобальная сеть, объединяющая огромное число устройств. К устройствам относятся далеко не только стационарные компьютеры и ноутбуки, но также и мобильные устройства, камеры, различные электронные и бытовые приборы. Хотя все эти устройства совершенно разные, они без проблем общаются друг с другом с помощью единого языка. Таким языком в мире машин стал стек протоколов <a href="https://ru.wikipedia.org/wiki/TCP/IP">TCP/IP</a>. Не вдаваясь в детали, скажем, что протокол — это правила, по которым происходит общение. При этом природа общающихся устройств не важна.</p>

<p>Главным элементом в TCP/IP является IP-адрес. В версии IPv4 он выглядит так: <code class="language-plaintext highlighter-rouge">10.123.23.1</code>. Четыре числа, разделённые точкой. У всех устройств, подключенных к сети напрямую, этот адрес уникальный. Фактически, любой запрос в интернете всегда обращается к какому-то IP-адресу, даже если вы этого не видите.</p>

<p>Среди компьютеров, подключённых к интернету, выделяется класс машин, которые выполняют роль серверов. Эти сервера, как правило, располагаются у хостеров, и именно они обслуживают многочисленные интернет сайты.</p>

<p><img src="/assets/images/hosting/servers.png" alt="Серверные стойки" /></p>

<p>Хостер — это компания, предоставляющая услугу, называемую хостинг, то есть ресурсы для размещения и обслуживания сайта в интернете. Хостинг бывает очень разным, начиная от уже полностью готовой среды, в которую заливается код сайта, до железных серверов, которыми можно и нужно управлять самостоятельно.</p>

<p>Работает это обычно так: после регистрации на сайте хостера выбирается тариф, привязывается банковская карточка, и с вас списывается ежемесячная плата за обслуживание и дополнительные услуги. Взамен вы получаете доступ к вашим ресурсам, например, IP-адрес и пару логин/пароль для ssh- или ftp-доступа.</p>

<p>Однако есть и бесплатные хостинги, требующие только базовых знаний веб-разработки. Чтобы разместить свою страницу в интернете может быть достаточно возможностей бесплатного Github Pages и одной HTML-страницы. Там же можно получить домен третьего уровня или привязать собственный. Подробнее это рассматривается в наших профессиях в уроке <a href="https://ru.hexlet.io/courses/layout-designer-basics/lessons/publication/theory_unit">Публикация в интернете</a>.</p>

<h3 id="виды-хостингов-on-prem-iaas-paas-saas">Виды хостингов: On-Prem, IaaS, PaaS, SaaS</h3>

<p>Вы можете использовать старый компьютер, как собственный хостинг, но придётся самостоятельно обеспечивать его постоянную доступность в интернете, защиту от атак и обновление софта. Такое решение будет называться On-Premises. Вместо рукопашки можно воспользоваться решениями “as Service”:</p>
<ul>
  <li>IaaS — Infrastructure as a Service, инфраструктура как услуга;</li>
  <li>PaaS — Platform as a Service, платформа как услуга;</li>
  <li>SaaS — Software as a Service, программное обеспечение как услуга.</li>
</ul>

<p>Каждый термин означает разный уровень ответственности. В случае с <a href="https://pages.github.com/">Github Pages</a> от вас требуется только написать HTML и загрузить его в сервис, остальное решается через интерфейс (панель управления), а вся “магия” происходит на стороне сервиса. Это решение SaaS.</p>

<p>Одно из популярных решений PaaS является <a href="https://www.heroku.com/">Heroku</a>, предоставляющая множество удобных бесплатных инструментов. Практический навык работы с Heroku студенты получают при работе над 4-м проектом в наших профессиях.</p>

<p>А среди популярных решений IaaS — это <a href="https://aws.amazon.com/">Amazon Web Services</a>. Примечательно, что Heroku использует AWS для размещения ваших ресурсов, то есть выступает посредником, упрощая многие процедуры управления серверами.</p>

<p>Популярна визуализация этих решений на примере приготовления пиццы, где On-Prem требует наличия и ингредиентов, и инструментов, а SaaS представлен пиццерией, куда вы приходите чтобы съесть пиццу:</p>

<p><img src="/assets/images/hosting/pizza-as-service.png" alt="Пицца as service" /></p>

<h2 id="заключение">Заключение</h2>

<p>Итак, чтобы создать собственный сайт, вам понадобится домен, хостинг и курсы программирования. Выдачей доменов занимаются организации, именуемые регистраторами. На их сайте вы можете подобрать незанятый домен и оплатить его. После этого каждый год необходимо продление, иначе он вновь станет свободным, и его смогут купить другие. Затем, прямо там же у регистратора, вы можете настроить DNS, например, указать адрес вашего хостинга (в реальности все чуть сложнее, сначала надо указать NS-сервера), на котором находится сайт. Спустя примерно сутки ваш сайт начнёт открываться. Такой срок связан с тем, что информация о новой связке домен-адрес должна распространиться по всем DNS серверам по всему миру. Такая же история происходит и при изменении IP-адреса. Процесс может занять до суток.</p>

<p>Хостинг может быть простым и бесплатным, а может быть платным и требующим специальных знаний и навыков администрирования. Можно начать с размещения на бесплатном хостинге с бесплатным доменом. Но не следует путать регистраторов доменных имён и хостеров. Часто хостеры выступают как посредники и предлагают купить домены через себя, но, в общем случае, регистраторы — это отдельные компании, которые никак не связаны с хостингом.</p>

<p>А получить все необходимые навыки программирования и работы с веб-приложениями можно с нашими наставниками в одной из профессий: https://ru.hexlet.io/professions</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/error-tracking/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое трекинг ошибок</turbo:topic> -->
            <title>Что такое трекинг ошибок</title>
            <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/error-tracking/">Что такое трекинг ошибок</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/error-tracking/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Программ без ошибок не бывает. Их количество можно уменьшить с помощью системы типов, линтеров, тестов или даже целого отдела тестировщиков, но убрать совсем невозможно. Это реальность с которой мы живем и лучшее, что можно сделать, научиться эти ошибки отслеживать и быстро исправлять.</p>

<h2 id="как-не-надо-работать-с-ошибками">Как не надо работать с ошибками</h2>

<p>Как, часто, происходит в разработке. Программисты написали какой-то код, выпустили новую версию сайта/приложения и пошли дальше заниматься своими делами. В это время у некоторых пользователей обнаруживаются проблемы: что-то зависает, формы не отправляются, данные отображаются неправильно и так далее. Такое может продолжаться довольно долго, пока кто-то разгневанный не напишет письмо в службу поддержки. Затем по цепочке это долетает до программистов, которые пытаются понять у кого произошла ошибка, где она случилась, и при каких обстоятельствах. Начинаются выяснения всех подробностей с вероятным привлечением клиента, если тот согласится помочь. При таком подходе, большое количество ошибок остается незамеченным очень долго и, самое неприятное, пользователи уходят. Можно ли этого избежать? Оказывается можно.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<h2 id="как-надо-работать-с-ошибками">Как надо работать с ошибками</h2>

<p>Существует целый класс сервисов называемых Error Trackers. Они в реальном времени собирают информацию о возникающих ошибках и оповещают об этом команду разработки. Эти сервисы работают буквально со всеми существующими платформами начиная от телевизоров, заканчивая мобильными приложениями и сайтами (и фронтенд и бекенд).</p>

<p><img src="/assets/images/error-tracking/rollbar-dashboard.jpg" alt="Rollbar Dashboard" /></p>

<p>Выше пример дашборда сервиса <a href="https://rollbar.io/">rollbar.io</a>, который используется для всех проектов Хекслета. На дашборде выводится частота появления критичных ошибок за последние 24 часа по всем проектам. Этот график позволяет быстро оценить места, куда нужно внимательнее смотреть. А ниже вывод ошибок конкретного проекта. Судя по иконкам, большая часть ошибок прямо сейчас приходит из JavaScript.</p>

<p><img src="/assets/images/error-tracking/rollbar-project.jpg" alt="Rollbar Project" /></p>

<p>Каждый такой сервис сервис предоставляет библиотеки под разные языки и платформы, которые встраиваются в код и вызываются в случае возникновении ошибок. Эти библиотеки отправляют не только саму ошибку, но и информацию об окружении, которая может помочь. В нее могут входить данные о пользователе, о его браузере, о настройках приложения и так далее.</p>

<p>В идеальном случае такая библиотека сразу <a href="https://docs.rollbar.com/docs/rails">интегрирована</a> в какой-нибудь фреймворк, например Rails. Тогда не придется практически ничего настраивать, достаточно подключить библиотеку как плагин к фреймворку и дальше он начнет собирать ошибки сам, без дополнительного вмешательства. Если такой интеграции нет, то придется написать немного кода для связи своего приложения с библиотекой. Подробнее о том как это сделать, нужно смотреть в документации выбранного вами сервиса. <a href="https://docs.rollbar.com/docs/react">Вот</a> пример интеграции Rollbar в React. После того как все заработает, пойманная ошибка будет выглядеть примерно так:</p>

<p><img src="/assets/images/error-tracking/rollbar-error.jpg" alt="Rollbar Error" /></p>

<p>Обратите внимание на меню сверху. По названиям вкладок видно сколько полезного извлекается из ошибки.</p>

<p>Но поймать ошибку это только половина дела. Дальше нужно как-то оповестить команду, причем так, чтобы не завалить всех спамом. Дело в том, что ошибки обычно не происходят один раз. Если ошибка общая и количество пользователей большое, то можно легко поймать одну ошибку тысячи раз в минуту. И если бы на каждое возникновение уходила нотификация (на емейл или в слак), то такой сервис быстро бы отключили от источника питания.</p>

<p><img src="/assets/images/error-tracking/rollbar-notifications.jpg" alt="Rollbar Error" /></p>

<p>Поэтому подобные трекеры работают хитро. Когда ошибка произошла первый раз, то сервис высылает оповещение чтобы команда разработки могла оперативно среагировать на инцендент. Если ошибка возникает снова, то больше никаких оповещений. По крайней мере не на каждое возникновение. Оповещения например могут уходить на первое, десятое, сотое, тысячное и так далее возникновение. Это первая часть механизма. Дальше, когда выкатывается новая версия приложения, трекеры помечают ошибки как “поправленные”. Это позволяет легко отслеживать ошибки, которые либо забыли поправить, либо поправили неправильно. Поэтому обычно после деплоя начинают сыпаться оповещения) Для работы этого механизма нужно оповещать трекер о деплоях. Подробно об этом <a href="https://docs.rollbar.com/docs/deploy-tracking">написано в документации</a> соответствующего трекера.</p>

<h2 id="выводы">Выводы</h2>

<p>Трекеры ошибок не игрушка, а серьезный инструмент, без которого невозможно представить себе ни один продакшен. В качестве трекера, при этом, может выступать как один из многих сервисов, так и специализированный софт (например <a href="https://github.com/getsentry/sentry">Sentry</a>), установленный к себе на сервера в случае повышенных требований к безопасности.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/compiler/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое компилятор</turbo:topic> -->
            <title>Что такое компилятор</title>
            <pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate>
            <author>Татьяна Федорина</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/compiler/">Что такое компилятор</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/compiler/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>В этом гайде вы узнаете о том, что такое компилятор и как он работает. Мы разберем этапы компиляции и от чего зависит выбор подходящего компилятора. Этот материал поможет лучше понять, как компьютер выполняет программный код и почему иногда код не компилируется.</p>

<h2 id="зачем-нужен-компилятор">Зачем нужен компилятор?</h2>

<p>Процессор — самая важная часть компьютера. Он обрабатывает информацию, выполняет команды пользователя и следит за работой всех подключенных устройств. Но процессор может разобрать только машинный код — набор 0 и 1, которые записаны в определённом порядке.</p>

<p>Почему именно 0 и 1? В процессор поступают электрические сигналы. Сильный сигнал обозначается цифрой 1, а слабый — 0. Набор таких цифр обозначает какую-то команду. Процессор ее распознает и выполняет.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/java?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Профессия «Java-разработчик» с нуля и до трудоустройства
</a>
</div>

<p>Программы для первых компьютеров выглядели как огромные наборы 0 и 1. Чтобы записать такую программу, инженеры пользовались гибкими картонными карточками — перфокартами. Цифры на перфокарте записывались поочередно, в несколько строк. Чтобы записать 1, программист делал отверстие в карте. Места без отверстия обозначали 0.</p>

<p><img src="/assets/images/compiler/card.png" alt="Изображение перфокарты" /></p>

<p>Компьютер считывал перфокарту специальным устройством и выполнял записанную команду. Для одной программы составляли сотни перфокарт.</p>

<p>Писать их было долго и сложно, поэтому инженеры стали создавать языки программирования, обозначая команды словами и знаками. Для того, чтобы процессор понимал, какие команды записаны в программе, программисты создали <strong>компилятор</strong> — программу, которая преобразует программный код в машинный.</p>

<h2 id="как-работает-компилятор">Как работает компилятор?</h2>

<p>Преобразование программного кода в машинный называется <em>компиляцией</em>. Компиляция только преобразует код. Она не запускает его на исполнение. В этот момент он “статически” (то есть без запуска) транслируется в машинный код. Это сложный процесс, в котором сначала текст программы разбирается на части и анализируется, а затем генерируется код, понятный процессору.</p>

<p><img src="/assets/images/compiler/compilation_steps.jpg" alt="Этапы компиляции" /></p>

<p>Разберём этапы компиляции на примере вычисления периметра прямоугольника:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">a</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">P</span><span class="p">;</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Width of the rectangle - %4.1f"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span><span class="c1">// =&gt; Width of the rectangle - 2.5</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Length of the rectangle - %4.1f"</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span><span class="c1">// =&gt; Length of the rectangle - 5.0</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Perimeter of the rectangle is %4.1f"</span><span class="p">,</span> <span class="n">P</span><span class="p">);</span><span class="c1">// =&gt; Perimeter of the rectangle is 15.0</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>После запуска программы компилятору нужно определить, какие команды в ней записаны. Сначала компилятор разделяет программу на слова и знаки — <em>токены</em>, и записывает их в список. Такой процесс называется <strong>лексическим анализом</strong>. Его главная задача — получить токены.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code># include &lt;iostream&gt; int main ( ) { double a = 2.5 , b = 5 , P ;  P = 2 * ( a + b ) ; printf ( " Width of the rectangle - % 4.1 f " , a ) ; printf ( " \ n Length of the rectangle - % 4.1 f " , b ) ; printf ( " \ n Perimeter of the rectangle is % 4.1 f " ,   P ) ; return 0 ; }
</code></pre></div></div>

<p>Затем компилятор читает список и ищет токен-операторы. Это могут быть оператор присваивания(<code class="language-plaintext highlighter-rouge">=</code>), арифметические операторы(<code class="language-plaintext highlighter-rouge">+</code>,<code class="language-plaintext highlighter-rouge">-</code>,<code class="language-plaintext highlighter-rouge">*</code>,<code class="language-plaintext highlighter-rouge">/</code>), оператор вывода(<code class="language-plaintext highlighter-rouge">printf()</code>) и другие операторы языка программирования. Такие операторы работают с числами, текстом и переменными.</p>

<p>Компилятор должен понять, какие токены в списке связаны с токен-оператором. Чтобы сделать это правильно, для каждого оператора строится специальная структура — <strong>логическое дерево</strong> или <strong>дерево разбора</strong>.</p>

<p>Так операция <code class="language-plaintext highlighter-rouge">P = 2*(a + b)</code> будет преобразована в логическое дерево:</p>

<p><img src="/assets/images/compiler/parse_tree.jpg" alt="Дерево разбора" /></p>

<p>Теперь каждое дерево нужно разобрать на команды, и каждую команду преобразовать в <strong>машинный код</strong>.
Компилятор начинает читать дерево снизу вверх и составляет список команд:</p>

<ul>
  <li>Взять переменную <code class="language-plaintext highlighter-rouge">a</code>, взять переменную <code class="language-plaintext highlighter-rouge">b</code>, сложить их</li>
  <li>Взять результат сложения, взять число <code class="language-plaintext highlighter-rouge">2</code> и найти их произведение</li>
  <li>Результат произведения присвоить (записать) в переменную <code class="language-plaintext highlighter-rouge">P</code></li>
</ul>

<p>Компилятор еще раз проверяет команды, находит ошибки и старается улучшить код. При успешном завершении этого этапа, компилятор переводит каждую команду в набор 0 и 1. Наборы записываются в файл, который сможет прочитать и выполнить процессор.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>10111011 00010001 00000001 10111001 00001101 00000000 10110100 00001110 10001010 00000111 01000011 11001101 00010000 11100010 11111001 11001101 00100000 01001000 01100101 01101100 01101100 01101111 00101100 00100000 01010111 01101111 01110010 01101100 01100100 00100001
</code></pre></div></div>

<h2 id="на-чем-написан-компилятор">На чем написан компилятор?</h2>

<p>В 1950-е годы группа разработчиков IBM под руководством Джона Бэкуса разработала первый высокоуровневый язык программирования <a href="https://ru.wikipedia.org/wiki/Фортран">Fortran</a>, который позволил писать программы на понятном человеку языке. Помимо языка, инженеры работали и над компилятором. Он представлял собой программу с набором исполняемых команд, которая могла компилировать другие программы на Fortran, в том числе и улучшенную версию себя.</p>

<p>В дальнейшем язык Fortran и его компилятор использовали, чтобы написать компиляторы для новых языков программирования. Такой подход используют программисты и в настоящее время.
Писать машинный код долго и неудобно. К тому же, для современных процессоров он может отличаться. Придется писать несколько версий одного и того же компилятора для разных компьютеров. Быстрее и проще написать компилятор на существующем языке программирования. Для этого разработчики выбирают удобный язык и пишут на нем первую версию своего компилятора. Он будет более универсальным для компьютеров и легко скомпилирует улучшенную версию себя.
<img src="/assets/images/compiler/create_compiler.jpg" alt="Этапы создания компилятора" /></p>

<h2 id="какие-бывают-компиляторы">Какие бывают компиляторы?</h2>

<p>Ни один компилируемый язык программирования не обходится без компилятора. Некоторые компиляторы работают с несколькими языками программирования. Но программист должен учитывать еще и параметры компьютера, на котором программа будет запускаться.</p>

<p>Дело в том, что современные процессоры отличаются друг от друга устройством, поэтому машинный код для одного процессора будет понятен, а для другого нет. Это касается и операционных систем: одна и та же программа будет работать на Windows, но не запустится на Linux или MacOS. Поэтому нужно пользоваться тем компилятором, который работает с нужным процессором и операционной системой.</p>

<p>Если программа будет работать на нескольких операционных системах, то нужен кросс-компилятор — компилятор, который преобразует универсальный машинный код. Например, GNU Compiler Collection(сокращенно GCC) поддерживает C++, Objective-C, Java, Фортран, Ada, Go и поддерживает разную архитектуру процессоров.</p>

<p>Начинающие программисты даже не знают о наличии компилятора на компьютере. Они пишут программы в интегрированной среде разработки, в которую встроен компилятор, а иногда и не один. В этом случае, выбор компилятора делает среда, а не программист. Например, MS Visual Studio поддерживает компиляторы для операционных систем Windows, Linux, Android. Выбирая тип проекта, Visual Studio определяет процессор и операционную систему компьютера, и после этого выбирает подходящий компилятор.</p>

<h2 id="какие-ошибки-может-определить-компилятор">Какие ошибки может определить компилятор?</h2>

<p>Когда компилятор анализирует текст программы, он проверяет, соответствует ли запись оператора стандартам языка. Если найдено несоответствие, то компилятор выводит об этом информацию пользователю в виде <em>ошибки</em>. Когда вся программа разобрана, пользователь видит список ошибок, которые есть в коде, и может их исправить.
Пока программист не исправит ошибки, компилятор не перейдет к следующему этапу — генерации машинного кода для процессора.
Чаще всего компилятор показывает пользователю:</p>
<ul>
  <li>ошибки объявления переменных или отсутствие их начальных значений</li>
  <li>ошибки несоответствия типов</li>
  <li>ошибки неправильной записи операторов и функций</li>
</ul>

<p>Иногда компилятор определяет код, который при выполнении дает неправильный результат. Но преобразовать такую программу в машинный код все-таки можно. В этом случае компилятор показывает пользователю <em>предупреждение</em>. Такая реакция компилятора больше похожа на рекомендации, но на них стоит обратить внимание. Программист сам решает оставить код с предупреждением или изменить программу.
Анализируя текст программы, компилятор не только ищет ошибки, но еще и упрощает ее код. Такой процесс называется оптимизацией.
Во время оптимизации компилятор изменяет программный код, но функции, которые выполняла программа, остаются прежними.</p>

<h2 id="выводы-и-рекомендации">Выводы и рекомендации</h2>

<p>Компилятор — переводчик между программистом и процессором. Он преобразует текст программы в машинный код, определяет ряд ошибок в программе и оптимизирует ее работу.
Выбирая, где компилировать программу, важно помнить о том, что машинный код для процессоров и операционных систем будет разным, и подобрать правильный компилятор.
Чем точнее компилятор определит команды, тем корректнее и быстрее будет работать программа. Для этого следуйте простым рекомендациям:</p>
<ul>
  <li>использовать простые, понятные команды;</li>
  <li>помнить о соответствии типов данных;</li>
  <li>внимательно набирать код, избегая синтаксических ошибок;</li>
  <li>избегать повторяющихся действий и бесполезных переменных.</li>
</ul>

<h2 id="частые-вопросы">Частые вопросы</h2>

<h3 id="чем-компилятор-отличается-от-интерпретатора">Чем компилятор отличается от интерпретатора?</h3>

<p>Компилятор это программа, которая выполняет преобразование текста программы в другое представление, обычно машинный код, без его запуска, статически. Затем эта программа уже может быть запущена на выполнение. <a href="/interpreter/">Интерпретатор</a> сразу запускает код и выполняет его в процессе чтения. Промежуточного этапа как в компиляции нет.</p>

<h2 id="дополнительные-материалы">Дополнительные материалы</h2>

<ul>
  <li><a href="https://ru.wikipedia.org/wiki/Компилятор">Компилятор</a></li>
  <li><a href="https://habr.com/ru/company/droider/blog/519732/">ARM против x86: В чем разница между двумя архитектурами процессоров?</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/makefile-as-task-runner/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое Makefile и как начать его использовать</turbo:topic> -->
            <title>Что такое Makefile и как начать его использовать</title>
            <pubDate>Thu, 30 Jul 2020 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/makefile-as-task-runner/">Что такое Makefile и как начать его использовать</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/makefile-as-task-runner/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <h2 id="введение">Введение</h2>

<p>В жизни многих разработчиков найдётся история про первый рабочий день с новым проектом. После клонирования основного репозитория проекта наступает этап, когда приходится вводить множество команд с определёнными флагами и в заданной последовательности. Без описания команд, в большинстве случаев, невозможно понять что происходит, например:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
<span class="nb">touch</span> ~/.bash_history
ufw allow 3035/tcp <span class="o">||</span> <span class="nb">echo</span> <span class="s1">'cant configure ufw'</span>
ufw allow http <span class="o">||</span> <span class="nb">echo</span> <span class="s1">'cant configure ufw'</span>
docker run <span class="se">\</span>
  <span class="nt">-v</span> /root/:/root/ <span class="se">\</span>
  <span class="nt">-v</span> /etc:/etc <span class="se">\</span>
  <span class="nt">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="se">\</span>
  <span class="nt">-v</span> /var/tmp:/var/tmp <span class="se">\</span>
  <span class="nt">-v</span> /tmp:/tmp <span class="se">\</span>
  <span class="nt">-v</span> <span class="nv">$PWD</span>:/app <span class="se">\</span>
  <span class="nt">--network</span> host <span class="se">\</span>
  <span class="nt">-w</span> /app <span class="se">\</span>
  <span class="nt">--env-file</span> .env <span class="se">\</span>
  ansible ansible-playbook ansible/development.yml <span class="nt">-i</span> ansible/development <span class="nt">--limit</span><span class="o">=</span>localhost <span class="nt">-vv</span>
<span class="nb">grep</span> <span class="nt">-qxF</span> <span class="s1">'fs.inotify.max_user_watches=524288'</span> /etc/sysctl.conf <span class="o">||</span> <span class="nb">echo </span>fs.inotify.max_user_watches<span class="o">=</span>524288 | <span class="nb">tee</span> <span class="nt">-a</span> /etc/sysctl.conf <span class="o">||</span> <span class="nb">echo</span> <span class="s1">'cant set max_user_watches'</span> <span class="o">&amp;&amp;</span> sysctl <span class="nt">-p</span>
<span class="nb">sudo </span>systemctl daemon-reload <span class="o">&amp;&amp;</span> <span class="nb">sudo </span>systemctl restart docker
</code></pre></div></div>

<p>Эти команды являются лишь частью того, что необходимо выполнить при разворачивании проекта. В приведённом примере видно, что команды сами по себе длинные, содержат много флагов, а значит, их трудно не только запомнить, но и вводить вручную. Постоянно вести документацию становится сложнее с ростом проекта, она неизбежно устаревает, а порог входа для новичков становится выше, ведь уже никто не в состоянии вспомнить всех деталей проекта. Некоторые такие команды необходимо использовать каждый день, и даже не один раз в день.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Со временем становится понятно, что нужен инструмент, способный объединить в себе подобные команды, предоставить к ним удобные шорткаты (<em>более короткие и простые команды</em>) и обеспечить самодокументацию проекта. Именно таким инструментом стал <em>Makefile</em> и утилита <code class="language-plaintext highlighter-rouge">make</code>. Этот гайд расскажет, как использование этих инструментов позволит свести процесс разворачивания проекта к нескольким коротким и понятным командам:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
make setup
make start
make <span class="nb">test</span>
</code></pre></div></div>

<h2 id="что-такое-make-и-makefile">Что такое <code class="language-plaintext highlighter-rouge">make</code> и <em>Makefile</em></h2>

<p><em>Makefile</em> — это файл, который хранится вместе с кодом в репозитории. Его обычно помещают в корень проекта. Он выступает и как документация, и как исполняемый код. Мейкфайл скрывает за собой детали реализации и раскладывает “по полочкам” команды, а утилита <code class="language-plaintext highlighter-rouge">make</code> запускает их из того мейкфайла, который находится в текущей директории.</p>

<p>Изначально <code class="language-plaintext highlighter-rouge">make</code> предназначалась для автоматизации сборки исполняемых программ и библиотек из исходного кода. Она поставлялась по умолчанию в большинство *nix дистрибутивов, что и привело к её широкому распространению и повсеместному использованию. Позже оказалось что данный инструмент удобно использовать и при разработке любых других проектов, потому что процесс в большинстве своём сводится к тем же задачам — автоматизация и сборка приложений.</p>

<p>Применение мейка в проектах стало стандартом для многих разработчиков, включая крупные проекты. Примеры мейкфайла можно найти у таких проектов, как <a href="https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile">Kubernetes</a>, <a href="https://github.com/babel/babel/blob/main/Makefile">Babel</a>, <a href="https://github.com/ansible/ansible/blob/devel/Makefile">Ansible</a> и, конечно же, повсеместно на <a href="https://github.com/Hexlet">Хекслете</a>.</p>

<h3 id="синтаксис-makefile">Синтаксис <em>Makefile</em></h3>

<p><code class="language-plaintext highlighter-rouge">make</code> запускает цели из <em>Makefile</em>, которые состоят из команд:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">цель1</span><span class="o">:</span> <span class="c">#</span><span class="nf"> имя цели</span><span class="p">,</span><span class="nf"> поддерживается kebab-case и snake_case</span>
	команда1 <span class="c"># для отступа используется табуляция, это важная деталь </span>
	команда2 <span class="c"># команды будут выполняться последовательно и только в случае успеха предыдущей</span>
</code></pre></div></div>

<p>Но недостаточно просто начать использовать мейкфайл в проекте. Чтобы получить эффект от его внедрения, понадобится поработать над разделением команд на цели, а целям дать семантически подходящие имена. Поначалу, перенос команд в Makefile может привести к свалке всех команд в одну цель с «размытым» названием:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">up</span><span class="o">:</span> <span class="c">#</span><span class="nf"> разворачивание и запуск</span>
	<span class="nb">cp</span> <span class="nt">-n</span> .env.example .env
	<span class="nb">touch </span>database/database.sqlite
	composer <span class="nb">install</span>
	npm <span class="nb">install</span>
	php artisan key:generate
	php artisan migrate <span class="nt">--seed</span>
	heroku <span class="nb">local</span> <span class="nt">-f</span> Procfile.dev <span class="c"># запуск проекта</span>
</code></pre></div></div>

<p>Здесь происходит сразу несколько действий: создание файла с переменными окружения, подготовка базы данных, генерация ключей, установка зависимостей и запуск проекта. Это невозможно понять из комментариев и названия цели, поэтому будет правильно разделить эти независимые команды на разные цели:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">env-prepare</span><span class="o">:</span> <span class="c">#</span><span class="nf"> создать .env-файл для секретов</span>
	<span class="nb">cp</span> <span class="nt">-n</span> .env.example .env

<span class="nl">sqlite-prepare</span><span class="o">:</span> <span class="c">#</span><span class="nf"> подготовить локальную БД</span>
	<span class="nb">touch </span>database/database.sqlite

<span class="nl">install</span><span class="o">:</span> <span class="c">#</span><span class="nf"> установить зависимости</span>
	composer <span class="nb">install</span>
	npm <span class="nb">install</span>

<span class="nl">key</span><span class="o">:</span> <span class="c">#</span><span class="nf"> сгенерировать ключи</span>
	php artisan key:generate

<span class="nl">db-prepare</span><span class="o">:</span> <span class="c">#</span><span class="nf"> загрузить данные в БД</span>
	php artisan migrate <span class="nt">--seed</span>

<span class="nl">start</span><span class="o">:</span> <span class="c">#</span><span class="nf"> запустить приложение</span>
	heroku <span class="nb">local</span> <span class="nt">-f</span> Procfile.dev
</code></pre></div></div>

<p>Теперь, когда команды разбиты на цели, можно отдельно установить зависимости командой <code class="language-plaintext highlighter-rouge">make install</code> или запустить приложение через <code class="language-plaintext highlighter-rouge">make start</code>. Но остальные цели нужны только при первом разворачивании проекта и выполнять их нужно в определённой последовательности. Говоря языком мейкфайла, цель имеет пререквизиты:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">цель1</span><span class="o">:</span> <span class="nf">цель2 </span><span class="c">#</span><span class="nf"> такой синтаксис указывает на зависимость задач — цель1 зависит от цель2</span>
	команда2 <span class="c"># команда2 выполнится только в случае успеха команды из цель2</span>

<span class="nl">цель2</span><span class="o">:</span>
	команда1
</code></pre></div></div>

<p>Задачи будут выполняться только в указанной последовательности и только в случае успеха предыдущей задачи. Значит, можно добавить цель <code class="language-plaintext highlighter-rouge">setup</code>, чтобы объединить в себе все необходимые действия:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">setup</span><span class="o">:</span> <span class="nf">env-prepare sqlite-prepare install key db-prepare </span><span class="c">#</span><span class="nf"> можно ссылаться на цели</span><span class="p">,</span><span class="nf"> описанные ниже</span>

<span class="nl">env-prepare</span><span class="o">:</span>
	<span class="nb">cp</span> <span class="nt">-n</span> .env.example .env

<span class="nl">sqlite-prepare</span><span class="o">:</span>
	<span class="nb">touch </span>database/database.sqlite

<span class="nl">install</span><span class="o">:</span>
	composer <span class="nb">install</span>
	npm <span class="nb">install</span>

<span class="nl">key</span><span class="o">:</span>
	php artisan key:generate

<span class="nl">db-prepare</span><span class="o">:</span>
	php artisan migrate <span class="nt">--seed</span>

<span class="nl">start</span><span class="o">:</span>
	heroku <span class="nb">local</span> <span class="nt">-f</span> Procfile.dev
</code></pre></div></div>

<p>Теперь развернуть и запустить проект достаточно двумя командами:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
make setup <span class="c"># выполнит последовательно: env-prepare sqlite-prepare install key db-prepare</span>
make start
</code></pre></div></div>

<p>Благодаря проделанной работе <em>Makefile</em>, команды проекта вместе с флагами сведены в <em>Makefile</em>. Он обеспечивает правильный порядок выполнения и не важно, какие при этом задействованы языки и технологии.</p>

<h2 id="продвинутое-использование">Продвинутое использование</h2>

<h3 id="фальшивая-цель">Фальшивая цель</h3>

<p>Использование <code class="language-plaintext highlighter-rouge">make</code> в проекте однажды может привести к появлению ошибки <code class="language-plaintext highlighter-rouge">make: &lt;имя-цели&gt; is up to date.</code>, хотя всё написано правильно. Зачастую, её появление связано с наличием каталога или файла, совпадающего с именем цели. Например:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">test</span><span class="o">:</span> <span class="c">#</span><span class="nf"> цель в мейкфайле</span>
	php artisan <span class="nb">test</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
<span class="nv">$ </span><span class="nb">ls
</span>Makefile
<span class="nb">test</span> <span class="c"># в файловой системе находится каталог с именем, как у цели в мейкфайле</span>

<span class="nv">$ </span>make <span class="nb">test</span> <span class="c"># попытка запустить тесты</span>
make: <span class="sb">`</span><span class="nb">test</span><span class="sb">`</span> is up to date.
</code></pre></div></div>

<p>Как уже говорилось ранее, изначально <code class="language-plaintext highlighter-rouge">make</code> предназначалась для сборок из исходного кода. Поэтому она ищет каталог или файл с указанным именем, и пытается собрать из него проект. Чтобы изменить это поведение, необходимо в конце мейкфайла добавить <code class="language-plaintext highlighter-rouge">.PHONY</code> указатель на цель:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">test</span><span class="o">:</span>
	php artisan <span class="nb">test</span>

<span class="nl">.PHONY</span><span class="o">:</span> <span class="nf">test</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
<span class="nv">$ </span>make <span class="nb">test</span>
✓ All tests passed!
</code></pre></div></div>

<h3 id="последовательный-запуск-команд-и-игнорирование-ошибок">Последовательный запуск команд и игнорирование ошибок</h3>

<p>Запуск команд можно производить по одной: <code class="language-plaintext highlighter-rouge">make setup</code>, <code class="language-plaintext highlighter-rouge">make start</code>, <code class="language-plaintext highlighter-rouge">make test</code> или указывать цепочкой через пробел: <code class="language-plaintext highlighter-rouge">make setup start test</code>. Последний способ работает как зависимость между задачами, но без описания её в мейкфайле. Сложности могут возникнуть, если одна из команд возвращает ошибку, которую нужно игнорировать. В примерах ранее такой командой было создание .env-файла при разворачивании проекта:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">env-prepare</span><span class="o">:</span>
	<span class="nb">cp</span> <span class="nt">-n</span> .env.example .env <span class="c"># если файл уже создан, то повторный запуск этой команды вернёт ошибку</span>
</code></pre></div></div>

<p>Самый простой (<em>но не единственный</em>) способ «заглушить» ошибку — это сделать логическое ИЛИ прямо в мейкфайле:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">env-prepare</span><span class="o">:</span>
	<span class="nb">cp</span> <span class="nt">-n</span> .env.example .env <span class="o">||</span> <span class="nb">true</span> <span class="c"># теперь любой исход выполнения команды будет считаться успешным</span>
</code></pre></div></div>

<p>Добавлять такие хаки стоит с осторожностью, чтобы не «выстрелить себе в ногу» в более сложных случаях.</p>

<h3 id="переменные">Переменные</h3>

<p>Зачастую в команды подставляют параметры для конфигурации, указания путей, переменные окружения и <code class="language-plaintext highlighter-rouge">make</code> тоже позволяет этим управлять. Переменные можно прописать прямо в команде внутри мейкфайла и передавать их при вызове:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">say</span><span class="o">:</span>
	<span class="nb">echo</span> <span class="s2">"Hello, </span><span class="nv">$(HELLO)</span><span class="s2">!"</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
<span class="nv">$ </span>make say <span class="nv">HELLO</span><span class="o">=</span>World
<span class="nb">echo</span> <span class="s2">"Hello, World!"</span>
Hello, World!

<span class="nv">$ </span>make say <span class="nv">HELLO</span><span class="o">=</span>Kitty
<span class="nb">echo</span> <span class="s2">"Hello, Kitty!"</span>
Hello, Kitty!
</code></pre></div></div>

<p>Переменные могут быть необязательными и содержать значение по умолчанию. Обычно их объявляют в начале мейкфайла.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nv">HELLO</span><span class="o">?=</span>World <span class="c"># знак вопроса указывает, что переменная опциональна. Значение после присвоения можно не указывать.</span>

<span class="nl">say</span><span class="o">:</span>
	<span class="nb">echo</span> <span class="s2">"Hello, </span><span class="nv">$(HELLO)</span><span class="s2">!"</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Bash</span>
<span class="nv">$ </span>make say
<span class="nb">echo</span> <span class="s2">"Hello, World!"</span>
Hello, World!

<span class="nv">$ </span>make say <span class="nv">HELLO</span><span class="o">=</span>Kitty
<span class="nb">echo</span> <span class="s2">"Hello, Kitty!"</span>
Hello, Kitty!
</code></pre></div></div>

<p>Некоторые переменные в <em>Makefile</em> имеют названия отличные от системных. Например, <code class="language-plaintext highlighter-rouge">$PWD</code> называется <code class="language-plaintext highlighter-rouge">$CURDIR</code> в <a href="https://github.com/hexlet-basics/hexlet_basics/blob/3f4635bf629e2676efe547c9a01c22a2573eaebd/Makefile#L35-L39">мейкфайле</a>:</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Makefile
</span><span class="nl">project-env-generate</span><span class="o">:</span>
	docker run <span class="nt">--rm</span> <span class="nt">-e</span> <span class="nv">RUNNER_PLAYBOOK</span><span class="o">=</span>ansible/development.yml <span class="se">\</span>
		<span class="nt">-v</span> <span class="nv">$(CURDIR)</span>/ansible/development:/runner/inventory <span class="se">\ </span><span class="c"># </span><span class="nv">$(CURDIR)</span> - то же самое, что <span class="nv">$PWD</span> в терминале
		<span class="p">-</span>v <span class="nv">$(CURDIR)</span>:/runner/project <span class="se">\</span>
		ansible/ansible-runner
</code></pre></div></div>

<h2 id="заключение">Заключение</h2>

<p>В рамках данного гайда было рассказано об основных возможностях <em>Makefile</em> и утилиты <code class="language-plaintext highlighter-rouge">make</code>. Более плотное знакомство с данным инструментом откроет множество других его полезных возможностей: условия, циклы, подключение файлов. В компаниях, где имеется множество проектов, написанных разными командами в разное время, мейкфайл станет отличным подспорьем в стандартизации типовых команд: <code class="language-plaintext highlighter-rouge">setup start test deploy ...</code>.</p>

<p>Возможность описывать в мейкфале последовательно многострочные команды позволяет использовать его как «универсальный клей» между менеджерами языков и другими утилитами. Широкая распространённость этого инструмента и общая простота позволяют внедрить его в свой проект достаточно легко, без необходимости доработок. Но мейкфайл может быть по-настоящему большим и сложным, это можно увидеть на примере реальных проектов:</p>

<ul>
  <li><a href="https://github.com/hexlet-codebattle/codebattle/blob/master/Makefile">Codebattle</a></li>
  <li><a href="https://github.com/babel/babel/blob/main/Makefile">Babel</a></li>
  <li><a href="https://github.com/kubernetes/kubernetes/blob/master/build/root/Makefile">Kubernetes</a></li>
</ul>

<h3 id="дополнительные-материалы">Дополнительные материалы</h3>

<ul>
  <li><a href="https://ru.makefile.site/">Руководство по современному Make</a> — «выжимка» из документации на русском языке;</li>
  <li><a href="https://www.youtube.com/watch?v=pK9mF5aK05Q">Утилита make: полезный универсальный инструмент программиста</a> — видео-версия данного гайда.</li>
</ul>

<p>Мейкфайлы, использованные при составлении гайда:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexlet-sicp/blob/master/Makefile">Hexlet SICP</a></li>
  <li><a href="https://github.com/hexlet-basics/hexlet_basics/blob/master/Makefile">Hexlet Basics</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/version-managers/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое «Менеджер версий»</turbo:topic> -->
            <title>Что такое «Менеджер версий»</title>
            <pubDate>Sun, 28 Jun 2020 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/version-managers/">Что такое «Менеджер версий»</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/version-managers/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <h2 id="системная-установка">Системная установка</h2>

<p>Для запуска кода на любом языке, необходимо установить его интерпретатор (или компилятор). В разных операционных системах это делается по-разному: где-то используются пакетные менеджеры, например, <em>apt</em> или <em>yum</em>, где-то скачивается установщик. Некоторые языки бывают предустановленны сразу, например, Python. На него многое завязано в дистрибутивах линукса.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Ubuntu</span>
<span class="nb">sudo </span>apt <span class="nb">install </span>nodejs <span class="c"># установит не самую свежую версию</span>
</code></pre></div></div>

<p>Стандартный способ установки работает хорошо только в самом начале, когда происходит первичная настройка. Затем, с течением времени, начинают всплывать разные проблемы. Например, в какой-то момент выходит новая версия языка, которую нужно подключить к проекту. Обычно, должно пройти какое-то время, перед тем, как язык станет доступным для установки через пакетные менеджеры. И здесь либо придется ждать, что не всегда желательно, либо искать другой способ установки. Последнее нередко превращается в серьёзное испытание, с часами гугления и установкой дополнительных библиотек. Все это в конце концов засоряет систему и иногда ломает её.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Другая серьёзная проблема – установка сразу нескольких версий одного языка. Такое бывает нужно, когда разработчик переключается между разными проектами, требующими разные версии. Насколько часто такое происходит? Крайне часто. Чем дальше в разработку, тем больше вариантов: разные проекты в компании, свои проекты, опенсорс.</p>

<p><em>Здесь нужно упомянуть, что всё это мало касается тех, кто целиком ушел в Docker и Docker Compose. Однако даже в этом случае, нужны языки для работы с опенсорсом.</em></p>

<h2 id="менеджеры-версий">Менеджеры версий</h2>

<p>Для решения этих проблем разработчики придумали менеджеры версий. Менеджер версий – это специальная программа, предназначенная для управления версиями языка. С его помощью устанавливают нужные версии и производят переключение между ними. В отличие от пакетных менеджеров, входящих в операционные системы, менеджеры версий всегда позволяют ставить последние версии языков, как только они выходят (включая установку альфа- и бета-версий).</p>

<p>Например, для Node.js это <a href="https://github.com/nvm-sh/nvm">NVM</a> (Node Version Manager):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Установка NVM</span>
curl <span class="nt">-o-</span> https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash
<span class="c"># Установка не означает активацию. После установки активной останется та версия, что и была до установки</span>
nvm <span class="nb">install </span>node <span class="c"># Установка последней доступной версии ноды</span>
nvm <span class="nb">install </span>6.14.4 <span class="c"># или 10.10.0, 8.9.1, и т.п.</span>
nvm ls-remote <span class="c"># список доступных версий</span>
nvm use node <span class="c"># Активация последней установленной версии ноды</span>
nvm use node 17 <span class="c"># Активация нужной версии</span>
</code></pre></div></div>

<p>Для упрощения работы менеджеры версий обычно позволяют создать специальный файл внутри проекта, который зафиксирует нужную версию языка. В некоторых случаях менеджеры версий сами отслеживают этот файл и переключают версию автоматически.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">echo</span> <span class="s2">"17"</span> <span class="o">&gt;</span> .nvmrc
<span class="c"># Эта команда увидела файл .nvmrc и использовала указанную там версию</span>
<span class="nv">$ </span>nvm use
Found <span class="s1">'/path/to/project/.nvmrc'</span> with version &lt;17&gt;
Now using node v17
</code></pre></div></div>

<p>В современном мире сложно представить себе язык, у которого бы не было менеджера версий. Более того некоторые языки, такие как Ruby, имеют множество разных менеджеров версий, которые конкурируют между собой:</p>

<ul>
  <li>go: gvm, g</li>
  <li>java: jabba</li>
  <li>ruby: rbenv, rvm, chruby</li>
  <li>php: phpenv, phpbrew</li>
  <li>python: pyenv</li>
</ul>

<p>Менеджеры версий позволили решить ещё несколько важных задач. Как правило, когда программист взаимодействует с языком, установленным напрямую, то ему приходится использовать <em>sudo</em> при установке глобальных пакетов. Дело в том, что стандартная схема установки языка предназначена для всех пользователей сразу. Поэтому все нужные файлы, включая глобальные пакеты, попадают в общие директории для которых нужны права администратора. С точки зрения безопасности это довольно большая дыра, которой могут воспользоваться (и иногда пользуются) разработчики опенсорс библиотек. Менеджеры версий устанавливают всё в домашнюю директорию текущего пользователя, где у него и так полные права. С одной стороны это позволяет не запускать установку пакетов от имени администратора, а с другой — не засоряется система. Удалить язык и все его пакеты через менеджер версий невероятно просто. Достаточно стереть директорию (правда, лучше это делать средствами самого менеджера версий).</p>

<h2 id="универсальный-менеджер">Универсальный менеджер</h2>

<p>Решив одни проблемы, менеджеры версий добавили другие. Во-первых, их слишком много, и они иногда меняются, сначала популярен один, затем другой. Во-вторых, сам процесс установки менеджера версий может оказаться сложнее установки языка. Проблема в том, что им нужно быть универсальными и работать везде, что крайне проблематично, учитывая разнообразие современных экосистем. Достаточно посмотреть размер документации NVM, чтобы оценить масштаб катастрофы. В-третьих, все эти менеджеры работают по-разному и имеют разные команды. Из-за этого усложняется процесс переключения между ними при работе с разными языками.</p>

<p>Всё это привело к следующему логическому шагу. В конце концов появился универсальный менеджер <a href="https://asdf-vm.com/">asdf</a>, который, благодаря плагинам, способен работать с любыми языками. Неполный список его преимуществ:</p>

<ul>
  <li>Одна единственная утилита командной строки для работы со всеми языками</li>
  <li>Единый интерфейс взаимодействия для всех языков</li>
  <li>Автоматическое переключение на нужную версию языка внутри каждого проекта</li>
  <li>Простая система плагинов, позволяющая добавить любые языки</li>
</ul>

<p>Сейчас <em>asdf</em> набрал достаточно большую популярность и постепенно заменяет собой все остальные менеджеры версий (технически под капотом там часто используются менеджеры, специфические для конкретных языков). У него чуть более сложная система команд из-за необходимости поддерживать множество языков, но в остальном он резко упрощает весь процесс.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># У asdf прекрасная документация, где наглядно показано, как его установить,</span>
<span class="c"># и какие могут понадобится зависимости в разных системах</span>

<span class="c"># Установка</span>
git clone https://github.com/asdf-vm/asdf.git ~/.asdf <span class="nt">--branch</span> v0.9
<span class="c"># После этого нужно перезапустить терминал</span>
<span class="nb">echo</span> <span class="s1">'. $HOME/.asdf/asdf.sh'</span> <span class="o">&gt;&gt;</span> ~/.bashrc

<span class="c"># Для работы с конкретным языком, сначала нужно подключить соответствующий плагин</span>
<span class="c"># Список доступных плагинов есть на сайте проекта</span>
asdf plugin add nodejs

<span class="c"># Установка языка</span>
<span class="c"># Вместо nodejs нужно подставить название того плагина, с которым работаем</span>
asdf <span class="nb">install </span>nodejs latest <span class="c"># latest означает последнюю версию указанного языка</span>

<span class="c"># Установка указанной версии</span>
asdf <span class="nb">install </span>nodejs latest

<span class="c"># Установка нужной версии языка версией по умолчанию</span>
asdf global nodejs latest

<span class="c"># Показывает текущие версии для языков, установленных через asdf</span>
asdf current
elixir         1.10.1-otp-22 <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
erlang         22.2.7   <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
nodejs         17.0.0   <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
php            7.4.5    <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
python         3.8.2 2.7.16 <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
ruby           2.7.0    <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
yarn           1.22.4   <span class="o">(</span><span class="nb">set </span>by /Users/user/.tool-versions<span class="o">)</span>
</code></pre></div></div>

<h2 id="вывод">Вывод</h2>

<p>Работа с разными версиями языков – непростая задача, которую решают менеджеры версий и докер (для продвинутых). Среди всех менеджеров выделяется <em>asdf</em>, который становится универсальным инструментом для управления любыми языками и даже обычными программами.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/webpack/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Зачем нужно собирать фронтенд</turbo:topic> -->
            <title>Зачем нужно собирать фронтенд</title>
            <pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/webpack/">Зачем нужно собирать фронтенд</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/webpack/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>HTML поддерживает два способа работы с JavaScript. Первый – код добавляется прямо на страницу и второй – код загружается из файла указанного в теге <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>.</p>

<h2 id="инлайновые-скрипты">Инлайновые скрипты</h2>

<p>Первый способ:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nt">&lt;script&gt;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">demo</span><span class="dl">'</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Hello JavaScript!</span><span class="dl">'</span><span class="p">;</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>Он работает только в самых простых ситуациях. Иногда им пользуются для добавления небольших интерактивных элементов, таких как переключатели табов, автокомплиты и т.п.</p>

<h2 id="код-в-файлах">Код в файлах</h2>

<p>Современный фронтенд вышел далеко за пределы этих задач. Количество JavaScript кода во многих проектах достигает десяток и сотен тысяч строк кода. Такую массу кода физически невозможно поддерживать внутри HTML. Потому он располагается в отдельных файлах, которых может быть довольно много. Для их подключения используется второй способ:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c">&lt;!--
Когда браузер встречает тег `&lt;script&gt;` с указанием `src`,
он загружает указанный файл и исполняет его.
Так код получает доступ к содержимому страницы.
--&gt;</span>

<span class="c">&lt;!-- Все определения внутри становятся глобальны и доступны для всех остальных скриптов --&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/assets/script1.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;script </span><span class="na">src=</span><span class="s">"/assets/script2.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>Тег <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> был добавлен в HTML очень давно, задолго до появления современной версии языка с модулями. В те времена не существовало Node.js, пакетного менеджера и понятия “зависимости” (dependencies). Весь код писался в одном файле. Даже если файлов было несколько, они никак не были связаны друг с другом. Если попытаться использовать модули вместе с обычным тегом <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code>, то браузер выдаст ошибку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Uncaught SyntaxError: Cannot use import statement outside a module
</code></pre></div></div>

<p>В теории, код можно писать и без использования системы модулей, но этот способ невероятно трудозатратный и основывается на том, что все определения в коде глобальны (а значит, можно легко что-нибудь сломать, перетерев существующие определения). Придётся руками указывать все существующие файлы и загружать их в HTML, в строго определённом порядке. Подобное сейчас встречается только на сайтах, где фронтенд — это jquery с небольшим числом интерактивных элементов.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Отсутствие модулей делает нормальную разработку невозможной. Нельзя работать с зависимостями, нельзя написать тесты, статический анализ кода отсутствует (невозможны переходы по определениям, подсказки).</p>

<h2 id="модули-в-браузере">Модули в браузере</h2>

<p>Проблема отсутствия модулей в браузере настолько важная, что в HTML5 ввели поддержку JavaScript-модулей. Достаточно в теге <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> добавить <code class="language-plaintext highlighter-rouge">type="module"</code>, как браузер начинает их понимать и загружать. Модули понимают практически все современные браузеры.</p>

<p>В HTML:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span> <span class="na">src=</span><span class="s">"/assets/index.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>В JavaScript:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1">// index.js</span>

<span class="k">import</span> <span class="nx">app</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./app.js</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">app</span><span class="p">();</span>

<span class="c1">// app.js</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hello from module!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Модули в браузере кардинально всё меняют и позволяют работать с JavaScript так, как это нужно, если бы не одно серьёзное “но”. Система модулей в браузере не умеет работать с зависимостями. Если мы решим установить, например, lodash, то попытка его импортировать завершится с ошибкой. Решить эту проблему на уровне браузеров невозможно. Браузер ничего не знает про файловую систему и того, что там происходит.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Uncaught TypeError: Failed to resolve module specifier "lodash".
Relative references must start with either "/", "./", or "../".
</code></pre></div></div>

<h2 id="сборщики-фронтенда">Сборщики фронтенда</h2>

<p>Эти проблемы полностью решают системы сборки. Кроме загрузки файлов, они решают множество других не менее важных задач. Фронтенд-разработка сильно опирается на различные пре- и пост-процессоры. Например, для современного JavaScript (и TypeScript) и многих фреймворков нужен Babel, который получает на вход исходный код проекта, преобразует его в код понятный браузеру. Только после этого его можно отдавать клиенту.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Указываем исходную директорию src</span>
<span class="c"># И директорию, в которую положить готовый код</span>
babel src <span class="nt">-o</span> dist
</code></pre></div></div>

<p>То же самое касается CSS. Всё больше разработчиков используют SASS, который нужно транслировать в чистый CSS.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Указываем исходную директорию stylesheets</span>
<span class="c"># И директорию, в которую положить готовый CSS</span>
sass <span class="nt">--update</span> stylesheets dist/stylesheets
</code></pre></div></div>

<p>Кроме этих задач, сборщики занимаются следующим:</p>

<ul>
  <li>Предоставляют единую команду для полной сборки фронтенда включая все его части.</li>
  <li>Автоматически пересобирают фронтенд во время разработки. Делают это очень быстро благодаря использованию инкрементальной сборки (собирают только то, что поменялось).</li>
  <li>Обеспечивают производительность. Минифицируют и сжимают код (в том числе удаляя неиспользуемый). Разбивают его максимально удобным для кеширования способом.</li>
  <li>Выполняют любые преобразования, например, TypeScript =&gt; JavaScript. Позволяют подключать пре- и пост-процессоры, настроить порядок их применения к выбранным файлам.</li>
</ul>

<p>Если выполнять эти задачи вручную, то подготовка кода к запуску в браузере станет занимать больше времени, чем сама разработка.</p>

<h2 id="webpack">Webpack</h2>

<p>Одним из первых сборщиков фронтенда стал Webpack. Сейчас он стандарт де-факто в среде фронтенда, хотя существуют и другие решения. Общий принцип работы вебпака такой. В проекте устанавливается сам вебпак и описывается его конфигурация. Эта конфигурация содержит все правила сборки: какие файлы брать, какие обработчики к ним применять и куда складывать результат. На выходе вебпак формирует файл или набор файлов, готовых для загрузки в браузер. Дальше он не участвует, использование этих файлов – задача программиста.</p>

<p>Webpack поставляется как npm-библиотека и устанавливается в проект, обычно, в dev-зависимости, а для работы удобно использовать cli-утилиту:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nb">mkdir </span>webpack-demo
<span class="nb">cd </span>webpack-demo
npm init <span class="nt">-y</span>
npm i <span class="nt">-D</span> webpack webpack-cli
</code></pre></div></div>

<p>Теперь можно инициализировать новый вебпак-проект, который автоматически создаст все необходимые файлы и конфигурацию одной командой:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>npx webpack init <span class="nt">--force</span>
</code></pre></div></div>

<p>Она предложит перезаписать <em>package.json</em>, добавит в проект несколько зависимостей, создаст HTML и JS-файлы, а также создаст конфигурационный файл. Запуск этой же команды без флага <code class="language-plaintext highlighter-rouge">--force</code> откроет интерактивный режим, где можно более тонко настроить будущее приложение.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>npx webpack init
? Which of the following JS solutions <span class="k">do </span>you want to use? ES6
? Do you want to use webpack-dev-server? Yes
? Do you want to simplify the creation of HTML files <span class="k">for </span>your bundle? Yes
? Do you want to add PWA support? No
? Which of the following CSS solutions <span class="k">do </span>you want to use? none
? Do you like to <span class="nb">install </span>prettier to format generated configuration? No
? Pick a package manager: npm
<span class="o">[</span>webpack-cli] ℹ INFO  Initialising project...
 conflict package.json
? Overwrite package.json? overwrite
    force package.json
   create src/index.js
   create README.md
   create index.html
   create webpack.config.js
   create .babelrc

<span class="c"># вывод об установке библиотек</span>

<span class="o">[</span>webpack-cli] ⚠ Generated configuration may not be properly formatted as prettier is not installed.
<span class="o">[</span>webpack-cli] Project has been initialised with webpack!
</code></pre></div></div>

<p>Проект готов и теперь его можно запустить:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>npx webpack serve
</code></pre></div></div>

<p>Эта команда соберёт приложение в режиме разработки, откроет браузер и отобразит содержимое HTML-файла, а в консоль выведется сообщение из <em>src/index.js</em>.</p>

<p><img src="/assets/images/webpack/init-app.png" alt="Запущенное в браузере Webpack-приложение" /></p>

<p>Конфигурационный файл <em>webpack.config.js</em> будет содержать несколько плагинов, необходимых для работы с HTML. Всё готово, чтобы написать своё первое фронтенд-приложение, используя Webpack!</p>

<p>Лучший способ продолжить с ним работу — это читать <a href="https://webpack.js.org/guides/getting-started/#basic-setup">официальную документацию</a> и изучить <a href="https://github.com/hexlet-boilerplates/webpack-package">Webpack Boilerplate</a>, созданный Хекслетом.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/encoding/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое кодировки</turbo:topic> -->
            <title>Что такое кодировки</title>
            <pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate>
            <author>Ильнар Шафигуллин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/encoding/">Что такое кодировки</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/encoding/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <h2 id="почему-кодировки---это-важно">Почему кодировки - это важно?</h2>

<p>Компьютеры постоянно работают с текстами: это ленты новостных сайтов, фондовые биржи, сообщения в социальных сетях и мессенджерах, банковские приложения и многое другое. Сегодня мы не можем представить жизнь без передачи информации. Но так было не всегда. Компьютеры научились работать с текстом благодаря появлению кодировок. Кодировки прошли большой путь от таблиц символов, созданных отдельно для каждого компьютера, до единой кодировки, принятой во всём мире.</p>

<p>Сейчас Unicode — это основной стандарт кодирования символов, включающий в себя знаки почти всех письменных языков мира. Unicode применяется везде, где есть текст. Информация на страницах в социальных сетях, записи в базах данных, компьютерные программы и мобильные приложения — всё это работает с использованием Unicode.</p>

<p>В этом гайде мы рассмотрим, как появился Unicode и какие проблемы он решает. Узнаем, как хранилась и передавалась информация до введения единого стандарта кодирования символов, а также рассмотрим примеры кодировок, основанных на Unicode.</p>

<h2 id="предпосылки-появления-кодировок">Предпосылки появления кодировок</h2>

<p>Исторически компьютер создавался как машина для ускорения и автоматизации вычислений. Само слово computer с английского можно перевести как вычислитель, а в 20 веке в СССР, до распространения термина компьютер, использовалась аббревиатура ЭВМ — электронно вычислительная машина.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/operating_systems?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Курс: «Введение в операционные системы». Бесплатно
</a>
</div>

<p>Всё, чем компьютеры оперировали — числа. Основным заказчиком и драйвером появления первых моделей были оборонные предприятия. На компьютерах проводили расчёты параметров полёта баллистических ракет, самолётов, спутников. В 1950-е годы вычислительные мощности компьютеров стали использовать для:</p>
<ul>
  <li>прогноза погоды;</li>
  <li>вычислений экспериментальной и теоретической физики;</li>
  <li>расчета заработной платы сотрудников (например, компьютер LEO применялся для нужд компании, владеющей сетью чайных магазинов);</li>
  <li>прогнозирование результатов выборов президента США (1952 год, компьютер UNIVAC).</li>
</ul>

<h3 id="компьютеры-и-числа">Компьютеры и числа</h3>

<p>Цели, для которых разрабатывались компьютеры, привели к появлению архитектуры, предназначенной для работы с числами. Они хранятся в компьютере следующим образом:</p>
<ol>
  <li>Число из десятичной системы счисления переводится в двоичную, т.е. набор нулей и единиц. Например, 3 в двоичной системе счисления можно записать в виде 11, а 9 как 1001. Подробнее о системах счисления читайте в соответствующем гайде.</li>
  <li>Полученный набор нулей и единиц хранится в ячейках памяти компьютера. Например, наличие тока на элементе памяти означает единицу, его отсутствие — ноль.</li>
</ol>

<p><img src="/assets/images/encoding/enter-number.png" alt="картинка о записи чисел в память" /></p>

<p>В конце 1950-х годов происходит замена ламп накаливания на полупроводниковые элементы (транзисторы и диоды). Внедрение новой технологии позволило уменьшить размеры компьютеров, увеличить скорость работы и надёжность вычислений, а также повлияло на конечную стоимость. Если первые компьютеры были дорогостоящими штучными проектами, которые могли себе позволить только государства или крупные компании, то с применением полупроводников начали появляться серийные компьютеры, пусть даже и не персональные.</p>

<h3 id="компьютеры-и-символы">Компьютеры и символы</h3>

<p>Постепенно компьютеры начинают применяться для решения не только вычислительных или математических задач. Возникает необходимость обработки текстовой информации, но с буквами и другими символами ситуация обстоит сложнее, чем с числами. Символы — это визуальный объект. Даже одна и та же буква «а» может быть представлена двумя различными символами «а» и «А» в зависимости от регистра.</p>

<p>Также число «один» можно представить в виде различных символов. Это может быть арабская цифра 1 или римская цифра I. Значение числа не меняется, но символы используются разные.</p>

<p>Компьютеры создавались для работы с числами, они не могут хранить символы. При вводе информации в компьютер символы преобразуются в числа и хранятся в памяти компьютера как обычные числа, а при выводе информации происходит обратное преобразование из чисел в символы.</p>

<p>Правила преобразования символов и чисел хранились в виде таблицы символов (англ. charset). В соответствии с такой таблицей для каждого компьютера конструировали и своё уникальное устройство ввода/вывода информации (например, клавиатура и принтер).</p>

<p><img src="/assets/images/encoding/enter-symbol.png" alt="Картинка о записи символов в память" /></p>

<h3 id="распространение-компьютеров">Распространение компьютеров</h3>

<p>В начале 1960-х годов компьютеры были несовместимы друг с другом даже в рамках одной компании-производителя. Например, в компании IBM насчитывалось около 20 конструкторских бюро, и каждое разрабатывало свою собственную модель. Такие компьютеры не были универсальными, они создавались для решения конкретных задач. Для каждой решаемой задачи формировалась необходимая таблица символов, и проектировались устройства ввода/вывода информации.</p>

<p>В этот период начинают формироваться сети, соединяющие в себе несколько компьютеров. Так, в 1958 году создали систему SAGE (Semi-Automatic Ground Environment), объединившую радарные станций США и Канады в первую крупномасштабную компьютерную сеть. При этом, чтобы результаты вычислений одних компьютеров можно было использовать на других компьютерах сети, они должны были обладать одинаковыми таблицами символов.</p>

<p>В 1962 году компания IBM формирует два главных принципа для развития собственной линейки компьютеров:</p>
<ol>
  <li>Компьютеры должны стать универсальными. Это означало переход от производства узкоспециализированных компьютеров к машинам, которые могут решать разные задачи.</li>
  <li>Компьютеры должны стать совместимыми друг с другом, то есть должна быть возможность использовать данные с одного компьютера на другом.</li>
</ol>

<p>Так в 1965 году появились компьютеры IBM System/360. Это была линейка из шести моделей, состоящих из совместимых модулей. Модели различались по производительности и стоимости, что позволило заказчикам гибко подходить к выбору компьютера. Модульность систем привела к появлению новой отрасли — производству совместимых с System/360 вычислительных модулей. У компаний не было необходимости производить компьютер целиком, они могли выходить на рынок с отдельными совместимыми модулями. Всё это привело к ещё большему распространению компьютеров.</p>

<h2 id="ascii-как-первый-стандарт-кодирования-информации">ASCII как первый стандарт кодирования информации</h2>

<h3 id="телетайп-и-терминал">Телетайп и терминал</h3>

<p>Параллельно с этим развивались телетайпы. Телетайп — это система передачи текстовой информации на расстоянии. Два принтера и две клавиатуры (на самом деле электромеханические печатные машинки) попарно соединялись друг с другом проводами. Текст, набранный на клавиатуре у первого пользователя, печатается на принтере у второго пользователя и наоборот. Таким образом, например, была организована «горячая линия» между президентом США и руководством СССР вплоть до начала 1970-х годов.</p>

<p>Телетайпы также преобразуют текстовую информацию в некоторые сигналы, которые передаются по проводам. При этом не всегда используется бинарный код, например, в азбуке Морзе используются 3 символа — точка, тире и пауза. Для телетайпов необходимы таблицы символов, соответствие в которых строится между символами и сигналами в проводах. При этом для каждого телетайпа (пары, соединённых телетайпов) таблицы символов могли быть свои, исходя из задач, которые они решали. Отличаться, например, мог язык, а значит и сам набор символов, который отправлялся с помощью устройства. Для оптимизации работы телетайпа самые популярные (часто встречающиеся) символы кодировались наиболее коротким набором сигналов, а значит и в рамках одного языка, набор символов мог быть разным.</p>

<p>На основе телетайпов разработали терминалы доступа к компьютерам. Такой телетайп отправлял сообщения не второму пользователю, а информация вводилась на некоторый удалённый компьютер, который после обработки указанных команд, возвращал результат в виде ответного сообщения. Это нововведение позволило использовать тогда ещё очень дорогие вычислительные мощности компьютеров, не имея физического доступа к самому компьютеру. Например, компьютер мог размещаться в отдельном вычислительном центре корпорации или института, а сотрудники из других филиалов или городов получали доступ к вычислительным мощностями компьютера посредством установленных у них терминалов.</p>

<h3 id="ascii">ASCII</h3>

<p>Повсеместное распространение компьютеров и средств обмена текстовой информацией потребовало разработки единого стандарта кодирования для передачи и хранения информации. Такой стандарт разработали в США в 1963 году. Таблицу из 128 символов назвали ASCII — American standard code for information interchange (Американский стандарт кодов для обмена информацией).</p>

<p><img src="/assets/images/encoding/ASCII_Code_Chart.png" alt="ASCII image" /></p>

<p>Первые 32 символа в ASCII являются управляющими. Они использовались для того, чтобы, например, управлять печатающим устройством телетайпа и получать некоторые составные символы. Например:</p>

<ol>
  <li>символ Ø можно было получить так: печатаем O, затем с помощью управляющего кода BS (BackSpace) передвигаем печатную головку на один символ назад и печатаем символ /,</li>
  <li>символ à получался как a BS `</li>
  <li>символ Ç получался как C BS ,</li>
</ol>

<p>Введение управляющих символов позволяло получать новые символы как комбинацию существующих, не вводя дополнительные таблицы символов.</p>

<p>Однако введение стандарта ASCII решило вопрос только в англоговорящих странах. В странах с другой письменностью, например, с кириллической в СССР, проблема оставалась.</p>

<h3 id="кодировки-для-других-языков">Кодировки для других языков</h3>

<p>В течение более чем 20 лет вопрос решали введением собственных локальных стандартов, например, в СССР на основе таблицы ASCII разработали собственные варианты кодировок КОИ 7 и КОИ 8, где 7 и 8 указывают на количество бит, необходимых для кодирования одного символа, а КОИ расшифровывается как Коды Обмена Информацией.</p>

<p>С дальнейшим развитием систем начали использовать восьмибитные кодировки. Это позволило использовать наборы, содержащие по 256 символов. Достаточно распространён был подход, при котором первые 128 символов брали из стандарта ASCII, а оставшиеся 128 дополнялись собственными символами. Такое решение, в частности, было использовано в кодировке KOI 8.</p>

<p>Однако единым стандартом указанные кодировки так и не стали. Например, в MS-DOS для русских локализаций использовалась кодировка cp866, а далее в среде MS Windows стали использоваться кодировки cp1251. Для греческого языка применялись кодировки cp851 и cp1253. В результате документы, подготовленные с использованием старой кодировки, становились нечитаемыми на новых.</p>

<p>Свои кодировки необходимы и для других стран с уникальным набором символов. Это приводило к путанице и сложностям в обмене информацией. Ниже приведён пример текста, который написали в кодировке KOI8-R, а читают в cp851.</p>

<table>
  <thead>
    <tr>
      <th>KOI8-R</th>
      <th>cp851</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>English text.</td>
      <td>English text.</td>
    </tr>
    <tr>
      <td>Это - русский текст :-).</td>
      <td>ΰΨΣ - ΦΩΧΧ╦╔╩ Ψ┼╦ΧΨ :-).</td>
    </tr>
  </tbody>
</table>

<p><img src="/assets/images/encoding/forward-information.png" alt="Картинка для кодировок" /></p>

<p>Обе кодировки основаны на стандарте ASCII, поэтому знаки препинания и буквы английского алфавита в обеих кодировках выглядят одинаково. Кириллический текст при этом становится совершенно нечитаемым.</p>

<p>При этом компьютерная память была дорогой, а связь между компьютерами медленной. Поэтому выгоднее было использовать кодировки, в которых размер в битах каждого символа был небольшим. Таблица символов состоит из 256 символов. Это значит, что нам достаточно 8 бит для кодирования любого из них (2^8 = 256).</p>

<h2 id="переход-к-unicode">Переход к Unicode</h2>

<p>Развитие интернета, увеличение количества компьютеров и удешевление памяти привели к тому, что проблемы, которые доставляла путаница в кодировках, стали перевешивать некоторую экономию памяти. Особенно ярко это проявлялось в интернете, когда текст написанный на одном компьютере должен был корректно отображаться на многих других устройствах. Это доставляло огромные проблемы как программистам, которые должны были решать какую кодировку использовать, так и конечным пользователям, которые не могли получить доступ к интересующим их текстам.</p>

<p>В результате в октябре 1991 года появилась первая версия одной общей таблицы символов, названной Unicode. Она включала в себя на тот момент 7161 различный символ из 24 письменностей мира.</p>

<p>В Unicode постепенно добавлялись новые языки и символы. Например, в версию 1.0.1 в середине 1992 года добавили более 20 000 идеограмм китайского, японского и корейского языков. В актуальной на текущий момент версии содержится уже более 143 000 символов.</p>

<h2 id="кодировки-на-основе-unicode">Кодировки на основе Unicode</h2>

<p>Unicode можно себе представить как огромную таблицу символов. В памяти компьютера записываются не сами символы, а номера из таблицы. Записывать их можно разными способами. Именно для этого на основе Unicode разработаны несколько кодировок, которые отличаются способом записи номера символа Unicode в виде набора байт. Они называются UTF — Unicode Transformation Format. Есть кодировки постоянной длины, например, UTF-32, в которой номер любого символа из таблицы Unicode занимает ровно 4 байта. Однако наибольшую популярность получила UTF-8 — кодировка с переменным числом байт. Она позволяет кодировать символы так, что наиболее распространённые символы занимают 1-2 байта, и только редко встречающиеся символы могут использовать по 4 байта. Например, все символы таблицы ASCII занимают ровно по одному байту, поэтому текст, написанный на английском языке с использованием кодировки UTF-8, будет занимать столько же места, как и текст, написанный с использованием таблицы символов ASCII.</p>

<p>На сегодняшний день Unicode является основной кодировкой, которую используют в работе все, кто связан с компьютерами и текстами. Unicode позволяет использовать сотни тысяч различных символов и отображать их одинаково на всех устройствах от мобильных телефонов до компьютеров на космических станциях.</p>

<h2 id="резюме">Резюме</h2>

<ul>
  <li>Кодировка — это соответствие между визуальными символами и числами.</li>
  <li>Кодировки необходимы, так как компьютеры созданы для работы с числами и не понимают текст.</li>
  <li>До 1990-х годов не существовало единой кодировки, это приводило к тому, что текст, написанный в одной кодировке, становится совершенно нечитаемым на других.</li>
  <li>Unicode — единый стандарт кодирования символов. Развитие интернета и необходимость обмена большим количеством текстовой информации приводило к тому, что сейчас все пользуются этим стандартом.</li>
  <li>UTF-8, UTF-16, UTF-32 и т.п. — это варианты кодировок, основанные на Unicode. Отличаются они тем, что по-разному хранят информацию.</li>
  <li>UTF-8 — самая популярная кодировка. Особенность её в том, что самые популярные символы кодируются 1-2 байтами, а редко встречающиеся занимают 3-4 байта. Это приводит к существенной экономии памяти, например, при работе с английским текстом.</li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/https-yandex-guide/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое протокол HTTPS, и как он защищает вас в интернете</turbo:topic> -->
            <title>Что такое протокол HTTPS, и как он защищает вас в интернете</title>
            <pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/https-yandex-guide/">Что такое протокол HTTPS, и как он защищает вас в интернете</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/https-yandex-guide/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Это руководство перепечатано из <a href="https://yandex.ru/blog/company/77455">блога «Яндекса»</a> для удобства пользователей. В нём идет речь о протоколе HTTPS, его актуальности, сферах применения и распространении.</p>

<p>Любое действие в интернете — это обмен данными. Каждый раз, когда вы запускаете видеоролик, посылаете сообщение в социальной сети или открываете любимый сайт, ваш компьютер отправляет запрос к нужному серверу и получает от него ответ. Как правило, обмен данными происходит по протоколу HTTP. Этот протокол не только устанавливает правила обмена информацией, но и служит транспортом для передачи данных — с его помощью браузер загружает содержимое сайта на ваш компьютер или смартфон.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/http_protocol?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Курс по HTTP с практикой в браузере
</a>
</div>

<p>При всём удобстве и популярности HTTP у него есть один недостаток: данные передаются в открытом виде и никак не защищены. На пути из точки А в точку Б информация в интернете проходит через десятки промежуточных узлов, и, если хоть один из них находится под контролем злоумышленника, данные могут перехватить. То же самое может произойти, когда вы пользуетесь незащищённой сетью Wi-Fi, например, в кафе. Для установки безопасного соединения используется протокол <a href="https://ru.wikipedia.org/wiki/HTTPS">HTTPS</a> с поддержкой шифрования.</p>

<p><img src="/assets/images/https/1.png" alt="http и https" /></p>

<h2 id="применение-https">Применение HTTPS</h2>
<p>В некоторых сервисах, например, в электронных платёжных системах, защита данных исключительно важна, поэтому в них используется только HTTPS. Этот протокол также очень часто применяется и в других сервисах, которые обрабатывают приватную информацию, в том числе любые персональные данные. Многие сервисы Яндекса работают только по протоколу HTTPS: Паспорт, Почта, Директ, Метрика, Такси, Яндекс.Деньги, а также все формы обратной связи, имеющие дело с персональными данными пользователей.</p>

<p>Все современные браузеры поддерживают протокол HTTPS. Его не нужно специально настраивать — он автоматически включается в процесс, когда это необходимо и возможно.</p>

<h2 id="почему-https-безопасен">Почему HTTPS безопасен</h2>
<p>Защиту данных в HTTPS обеспечивает криптографический протокол SSL/TLS, который шифрует передаваемую информацию. По сути этот протокол является обёрткой для HTTP. Он обеспечивает шифрование данных и делает их недоступными для просмотра посторонними. Протокол SSL/TLS хорош тем, что позволяет двум незнакомым между собой участникам сети установить защищённое соединение через незащищённый канал.</p>

<p>Предположим, сегодня последний день месяца, и вы вспомнили, что нужно заплатить за интернет. На сайте провайдера вы находите нужную ссылку и переходите в личный кабинет. Всю передаваемую информацию вы наверняка хотите сохранить в секрете, поэтому она должна быть зашифрована: это и ваш пароль, и сумма платежа и номер кредитной карты. Проблема в том, что изначально ваш компьютер обменивался данными с сервером провайдера по открытому каналу, то есть по HTTP. Как в таких условиях можно установить безопасное соединение по HTTPS, если предположить, что канал всё время прослушивается? Сделать это позволяет простая математическая уловка.</p>

<h2 id="как-работает-безопасное-соединение">Как работает безопасное соединение</h2>
<p>Представьте, что вы хотите передать какую-то вещь другому человеку. Вы кладёте её в ящик и отправляете по почте. А чтобы курьер — или кто угодно другой — не украл её, вы запираете ящик на замок. Курьер доставляет ящик, но ваш адресат не может его открыть — у него нет ключа. Тогда он вешает на ящик свой замок и отправляет обратно вам. Вы получаете ящик под двумя замками, снимаете свой — теперь это безопасно — и отправляете снова. Адресат получает, наконец, ящик, на котором висит только его замок, открывает его и достаёт то, что вы ему послали.</p>

<p><img src="/assets/images/https/2.png" alt="схема работы" /></p>

<p>Это было нужно, чтобы обменяться с собеседником зашифрованными сообщениями. В ящике вы послали ему ключ от шифра, и теперь он известен вам обоим. Теперь вы можете открыто обмениваться зашифрованными сообщениями, не опасаясь, что их кто-то перехватит — всё равно их невозможно понять без ключа. Зачем такие сложности и почему нельзя было передать посылку отдельно, а ключ от замка отдельно? Конечно, можно было, но в таком случае нет гарантии, что ключ не перехватят и посылку не откроет кто-то другой.</p>

<p>На похожем принципе основана работа протокола SSL/TLS. При установке безопасного соединения по HTTPS ваш компьютер и сервер сначала выбирают общий секретный ключ, а затем обмениваются информацией, шифруя её с помощью этого ключа. Общий секретный ключ генерируется заново для каждого сеанса связи. Его нельзя перехватить и практически невозможно подобрать — обычно это число длиной более 100 знаков. Этот одноразовый секретный ключ и используется для шифрования всего общения браузера и сервера. Казалось бы, идеальная система, гарантирующая абсолютную безопасность соединения. Однако для полной надёжности ей кое-чего не хватает: гарантии того, что ваш собеседник именно тот, за кого себя выдаёт.</p>

<h2 id="зачем-нужны-цифровые-сертификаты">Зачем нужны цифровые сертификаты</h2>
<p>Представьте, что ваша посылка не дошла до адресата — её перехватил кто-то другой. Этот человек вешает на неё свой замок, подделывает адрес отправителя и отправляет вам. Когда он таким образом узнаёт секретный ключ к шифру, он сообщает его вашему настоящему адресату от вашего имени. В результате вы и ваш собеседник уверены, что ключ к шифру был передан безопасно и его можно использовать для обмена зашифрованными сообщениями. Однако все эти сообщения легко сможет прочитать и перехватить третье лицо, о существовании которого вы никак не можете догадаться. Не очень-то безопасно.</p>

<p>Таким же образом в соединение между двумя устройствами в интернете может незаметно вклиниться третий участник — и расшифровать все сообщения. Например, вы заплатили за интернет по безопасному соединению, и платёж был получен. Но злоумышленник перехватил номер и код проверки подлинности вашей кредитки. Вы об этом ещё не знаете, а когда узнаете, будет уже поздно. Избежать такой ситуации помогает цифровой сертификат — электронный документ, который используется для идентификации сервера.</p>

<p><img src="/assets/images/https/3.png" alt="процесс получения цифрового сертификата" /></p>

<p>Вам как пользователю сертификат не нужен, но любой сервер (сайт), который хочет установить безопасное соединение с вами, должен его иметь. Сертификат подтверждает две вещи: 1) Лицо, которому он выдан, действительно существует и 2) Оно управляет сервером, который указан в сертификате. Выдачей сертификатов занимаются центры сертификации — что-то вроде паспортных столов. Как и в паспорте, в сертификате содержатся данные о его владельце, в том числе имя (или название организации), а также подпись, удостоверяющая подлинность сертификата. Проверка подлинности сертификата — первое, что делает браузер при установке безопасного HTTPS-соединения. Обмен данными начинается только в том случае, если проверка прошла успешно.</p>

<p>Если вернуться к аналогии с ящиком и замками, цифровой сертификат позволяет убедиться в том, что замок вашего собеседника на ящике принадлежит именно ему. Что это уникальный замок, который невозможно подделать. Таким образом, если кто-то посторонний попытается вас обмануть и пришлёт ящик со своим замком, вы легко это поймёте, ведь замок будет другой.</p>

<h2 id="распространение-https">Распространение HTTPS</h2>
<p>Одна из самых популярных рекомендаций любых интернет-сервисов — всегда использовать последние версии программного обеспечения. Если вы никогда не задумывались о том, зачем это нужно, то вот вам одна из причин — поддержка последних разработок в области безопасности.</p>

<p>Распространение HTTPS и вообще новых технологий в интернете во многом зависит от того, насколько быстро появляется инфраструктура для их использования. К примеру, если бы у половины пользователей интернета браузеры не поддерживали HTTPS, многие сайты просто не смогли бы его использовать. Это привело бы к тому, что сайт какого-нибудь банка, полностью перешедший на HTTPS, был бы недоступен у половины клиентов.</p>

<p>Кроме того, в криптографических протоколах, в том числе и в SSL/TLS, время от времени находят уязвимости, которые позволяют перехватывать даже зашифрованную информацию. Для устранения этих уязвимостей протоколы регулярно обновляют, и каждая следующая версия, как правило, надёжнее предыдущей. Поэтому чем больше людей устанавливают современные версии браузеров и других важных программ, тем надёжнее они будут защищены.</p>

<h2 id="где-ещё-применяется-шифрование">Где ещё применяется шифрование</h2>
<p>В интернете немало протоколов обмена данными, помимо HTTP и HTTPS, и они тоже должны обеспечивать защиту. Например, Яндекс.Почта поддерживает шифрование входящих и исходящих писем, о чём можно прочитать в <a href="https://habr.com/ru/company/yandex/blog/203882/">технологическом блоге на Хабрахабре</a>. Мы заботимся о безопасности наших пользователей и стараемся защитить их данные везде, где это представляется возможным.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/git-guide/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое Git и для чего он нужен</turbo:topic> -->
            <title>Что такое Git и для чего он нужен</title>
            <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/git-guide/">Что такое Git и для чего он нужен</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/git-guide/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>В этом руководстве пойдёт речь об основах Git. Вы узнаете, зачем нужен контроль версий, как работают системы контроля версий. В дальнейшем информация позволит успешно освоить практическую работу с Git.</p>

<h2 id="какие-задачи-решает-контроль-версий">Какие задачи решает контроль версий</h2>

<p>Независимо от выбранного языка или направления разработки, код, который пишет программист, остаётся обычным текстом, записанным в множестве файлов на диске. Эти файлы регулярно добавляются, удаляются и изменяются. Некоторые из них могут содержать сотни строчек кода, а другие тысячи. Файлы в тысячу строк кода — вполне нормальное явление в программировании.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/intro_to_git?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Бесплатный курс «Основы Git» с практикой в браузере
</a>
</div>

<p>Пока проект состоит из пары-тройки файлов, его разработка не создаёт никаких сложностей. Программист пишет код, запускает его и радуется жизни. Клиент доволен, заказчик тоже. С ростом кодовой базы появляются определённые неудобства, которые затем превращаются в реальные проблемы:</p>

<ul>
  <li>Как не потерять файлы с исходным кодом?</li>
  <li>Как защититься от случайных исправлений и удалений?</li>
  <li>Как отменить изменения, если они оказались некорректными?</li>
  <li>Как одновременно поддерживать рабочую версию и разработку новой?</li>
</ul>

<p>Представьте, что ваш проект состоит из сотни файлов и десятков тысяч строк кода. Вы делаете какую-то задачу, в процессе меняете 15 файлов и 300 строк кода и вдруг становится понятно, что эта задача больше не актуальна. На этом моменте нужно вернуться к состоянию исходного кода, которое было до изменений. И это только один из множества вариантов событий. Другой вариант — в процессе работы над кодом стало понятно, что нужно срочно внести исправление в рабочий проект (сайт). Новую задачу в нерабочем состоянии выкладывать на сайт нельзя, а это значит, что исправление нужно вносить в ту версию кода, которая была до начала реализации новой задачи.</p>

<p>Самый простой вариант решения, указанных выше проблем — копирование директорий. К сожалению, такой подход обладает только недостатками. Перенос изменений из одной директории в другую возможен только полной перезаписью, так как точечные изменения отследить невозможно (только по памяти). Как только папок станет две, вы сразу начнёте путаться в них. И всё равно этот способ никак не поможет работать над кодом одновременно двум людям.</p>

<p>Совместная разработка — это отдельная головная боль. Если два программиста работают над задачами, требующими исправления кода в одних и тех же файлах, то как они выполнят эту работу так, чтобы не повредить или перезаписать изменения другого разработчика?</p>

<p>К счастью, эту задачу решили ещё в 80-х годах. С тех пор инструментарий сильно развился и стал использоваться повсеместно не только для кода, но и, например, для написания и перевода книг. Решением является <strong>контроль версий</strong>. Выполняется он с помощью специальных программ, которые умеют отслеживать изменения кода. Вот некоторые из многочисленных возможностей данных систем:</p>

<ul>
  <li>Возврат к любой версии кода из прошлого.</li>
  <li>Просмотр истории изменений.</li>
  <li>Совместная работа без боязни потерять данные или затереть чужую работу.</li>
</ul>

<p>В этом руководстве мы разберём общие принципы работы подобных программ.</p>

<h2 id="как-работает-контроль-версий">Как работает контроль версий</h2>

<p>Системы контроля версий (СКВ или VCS — Version Control System) часто встроены в инструменты, привычные даже далёким от программирования людям. Именно с них мы и начнём своё знакомство, а заодно погрузимся в соответствующую терминологию.</p>

<p>Сервисы синхронизации файлов между устройствами, такие как Dropbox, используются практически всеми. И все они отслеживают версии файлов, с которыми работают. Происходит это так: периодически программа синхронизирует локальные файлы с теми, которые находятся в хранилище сервиса. Если локальный файл отличается, и время его изменения — позже файла, находящегося на сервере, то файл на сервере становится частью истории изменений, а текущим становится последний изменённый файл.</p>

<p><img src="/assets/images/git/1.png" alt="dropbox, история версий" /></p>

<p>На картинке выше текущая версия файла обозначена как current. Всё остальное — это предыдущие версии текущего файла. Как видно, Dropbox позволяет восстановить любую версию файла.</p>

<p>Обратите внимание на эту фразу:</p>

<p>Dropbox keeps a snapshot every time you save a file. (Дропбокс сохраняет снимок каждый раз, когда вы сохраняете файл)</p>

<p>Снимок (snapshot; разг. снепшот) — очень важное понятие, которое будет встречаться нам в будущем. Его ещё называют снимком состояния или даже мгновенным снимком (буквальный перевод), но для простоты будем называть его просто «снимок».</p>

<p>В данном случае, снимок — это сам файл после изменения. И чтобы лучше понять этот термин, посмотрим на альтернативу — дельту изменения (diff). Представьте, что вместо сохранения новой версии файла Dropbox бы вычислял разницу между новым и старым файлом (а это не сложно сделать для текстовых файлов) и сохранял только её. Зачем так делать, спросите вы? Такой подход позволяет сэкономить место на диске, хотя и вносит дополнительную сложность при работе с файлами.</p>

<p>В дальнейшем мы увидим, что разные инструменты используют разные подходы: некоторые работают с дельтой изменений, другие — со снимками. Кстати, термин «снимок» часто применяют к дискам. Например, можно сделать снимок диска и потом восстанавливаться с этой точки (прямо как в играх).</p>

<p>Другим хорошим примером использования контроля версий являются текстовые редакторы, в первую очередь онлайновые.</p>

<p><img src="/assets/images/git/2.png" alt="google docs, история версий" /></p>

<p>Сервис Google Docs автоматически делает снимки после каждого автосохранения (примерно раз в 5 секунд). Если документ за это время не изменился, то, естественно, новая версия не появляется. Множество таких версий образуют историю изменений.</p>

<p>На картинке выше история версий называется «Revision history». Ревизия — базовое понятие систем контроля версий. Любое зафиксированное изменение в системе контроля версий называется ревизией.</p>

<p>Обратите внимание на то, что ревизия и снимок — это не одно и то же. Фиксация изменений создаёт ревизию, но сама ревизия может содержать внутри себя либо дельту изменений, либо снимок.</p>

<p>Кстати, процесс переключения между ревизиями также имеет своё название. Когда мы загружаем конкретную ревизию, то говорят, что переключаемся на неё (checkout).</p>

<p><img src="/assets/images/git/3.png" alt="редактор, схема ревизий" /></p>

<p>Между ревизиями можно выявлять различия в случае, если СКВ использует снимки, что демонстрирует нам Microsoft Word на картинке выше. Эту функциональность невозможно переоценить,поскольку посмотреть «а что же изменилось» требуется постоянно не только при работе с кодом. Приведу пример из собственной практики: согласование разных юридических документов (договоров) происходит сквозь череду правок. После того, как юристы поправили договор, хочется увидеть, а что же там изменилось.</p>

<p>Более того, в системах Linux есть команда diff, с помощью которой можно выяснить различия между любыми файлами даже без использования СКВ. Эти изменения можно сохранить в файл, а затем, используя программу patch, применить к исходному файлу.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>diff index.js index2.js <span class="o">&gt;</span> index.patch

1c1

&lt; const a <span class="o">=</span> 5<span class="p">;</span>

<span class="nt">---</span>

<span class="o">&gt;</span> const a <span class="o">=</span> 8<span class="p">;</span>

3a4

<span class="o">&gt;</span> console.log<span class="o">(</span>a - b<span class="o">)</span><span class="p">;</span>

patch index.js <span class="nt">-i</span> index.patch <span class="nt">-o</span> index2.js
</code></pre></div></div>

<p>В программах, разобранных выше, создание ревизии привязано к автосохранению, но это не единственная стратегия. Всего используется три способа:</p>

<ul>
  <li>Сохранение.</li>
  <li>Автосохранение.</li>
  <li>По кнопке (команде).</li>
</ul>

<p>Последнее используется уже при работе с кодом.</p>

<h2 id="какие-бывают-системы-контроля-версий">Какие бывают системы контроля версий</h2>

<p>Во всех предыдущих примерах мы рассматривали СКВ, встроенные прямо в программы, в частности, в текстовые редакторы. А СКВ для исходного кода отделены от используемых средств разработки (хотя могут быть дополнительно интегрированы с ними).</p>

<p>Это связано с тем что, исходный код, по сути, является набором текстовых (и бинарных) файлов. Кто, как и где будет их редактировать, заранее знать невозможно. Кроме того, автоматическое создание ревизий становится крайне неудобным.</p>

<p>В СКВ для кода процесс создания ревизии называется фиксацией (commit; разг. коммит). На работе вы будете часто слышать фразу «закоммитишь?» или «я закоммитил». Более того, обычно, вместо слова «ревизия» употребляют слово «коммит». И мы тоже так будем делать.</p>

<p>При работе с кодом важно, чтобы изменения в рамках одного коммита подчинялись определённым правилам. Только в таком случае можно будет воспользоваться всеми преимуществами СКВ. К таким требованиям относятся:</p>

<ul>
  <li>Хорошее описание. Как правило, оно начинается кратким однострочным заголовком не более 50 символов, после которого, через пустую строку, следует более детальный поясняющий текст, если он требуется. Обратите внимание, что хорошим тоном является использование повелительного наклонения в заголовке: «Fix scrolling» (Исправить прокрутку), а не «Fixed scrolling» (Исправлена прокрутка) или «Fixes scrolling» (Исправляет прокрутку).</li>
  <li>Атомарность. Коммит должен решать одну задачу и желательно от начала до конца. Это позволит построить такую историю проекта, которую легко читать и понимать. А в случае необходимости можно легко откатить изменение или перенести его в другую версию программы.</li>
</ul>

<p>Кроме этих базовых, существует и множество других рекомендаций входящих в понятие «хороший коммит».</p>

<p>Какие бы вы не использовали СКВ, базовый рабочий процесс один. Выглядит он так:</p>

<ol>
  <li>Инициализация (создание) репозитория.</li>
  <li>Добавление новых файлов.</li>
  <li>Коммит.</li>
  <li>Любые операции с файлами (добавление, удаление или изменение).</li>
  <li>Коммит.</li>
  <li>…</li>
</ol>

<p>Под репозиторием понимается набор файлов и директорий, которые находятся под контролем версий.</p>

<p>СКВ принято делить на поколения, каждое из которых сильно изменяло подходы к работе.</p>

<h2 id="первое-поколение">Первое поколение</h2>

<p>RCS, SCCS</p>

<ul>
  <li>Работали с каждым файлом индивидуально.</li>
  <li>Только локальная работа.</li>
</ul>

<p><img src="/assets/images/git/4.png" alt="системы контроля версий, первое поколение" /></p>

<h2 id="второе-поколение">Второе поколение</h2>

<p>CVS, SourceSafe, Subversion</p>

<ul>
  <li>Многофайловые.</li>
  <li>Централизованные.</li>
  <li>Требуют наличия сервера.</li>
</ul>

<p>Работать в этих системах без доступа к серверу нельзя. Вы не сможете буквально ничего. Посмотреть историю, сделать коммит, откатиться на другую версию, всё это становится невозможно сделать без доступа к сети.</p>

<p><img src="/assets/images/git/5.png" alt="системы контроля версий, второе поколение" /></p>

<h2 id="третье-поколение">Третье поколение</h2>

<p>Git, Bazaar, Mercurial</p>

<ul>
  <li>Распределённые.</li>
  <li>У каждого участника свой полноценный локальный репозиторий.</li>
</ul>

<p>Если и используется сервер, то только лишь для хранения эталонного репозитория. На самом деле все копии репозитория равноправны и могут обмениваться информацией в любых направлениях.</p>

<p><img src="/assets/images/git/6.png" alt="системы контроля версий, третье поколение" /></p>

<h2 id="заключение">Заключение</h2>

<p>Вы узнали, для чего используют Git, а также принципы работы систем контроля версий. Эта информация поможет вам осваивать практическую работу с Git в рамках <a href="https://ru.hexlet.io/professions">выбранной профессии</a>. Вопросы задавайте в комментариях.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li><a href="https://ru.hexlet.io/courses/intro_to_git">Введение в Git</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/dns/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое DNS-сервер простыми словами</turbo:topic> -->
            <title>Что такое DNS-сервер простыми словами</title>
            <pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate>
            <author>Никита Михайлов</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/dns/">Что такое DNS-сервер простыми словами</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/dns/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Вы когда-нибудь задавались вопросом, как браузер понимает, какую именно страницу открыть, когда вы вводите в строку адрес сайта? На самом деле, это глубокий вопрос, решать который стоит не непосредственно с перехода на сайты, а со связи компьютеров между собой.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>В 70-х — 90-х годах 20 века существовала сеть под названием ARPANET. Это была попытка объединить множество компьютеров министерством обороны США для возможности передачи информации во время войны. Важность такого подхода заключалась в быстрой передаче информации на дальние расстояния. Впоследствии принципы работы ARPANET легли в основу современного интернета.</p>

<p>Изначально вся сеть объединяла компьютеры в четырёх различных институтах США:</p>

<ul>
  <li>Калифорнийский университет в Лос-Анджелесе;</li>
  <li>Стэнфордский исследовательский центр;</li>
  <li>Университет Юты;</li>
  <li>Калифорнийский университет в Санта-Барбаре.</li>
</ul>

<p>Учёные этих институтов быстро пришли к единому мнению, что передавать друг другу информацию об исследованиях удобнее при помощи новой сети. Для этого было достаточно знать идентификатор того компьютера, на который передаётся сообщение. Сейчас такие идентификаторы называются IP-адресами. У каждого устройства в интернете есть такой идентификатор и именно по нему обращаются устройства друг к другу.</p>

<p>В самом начале компьютеров, подключённых к сети, было несколько десятков, и их идентификаторы было легко запомнить. Можно было записать эти адреса в блокнот и использовать его так же, как и телефонные книги.</p>

<p>Время шло, и уже к середине 80-х годов вместо нескольких десятков компьютеров сеть стала насчитывать несколько тысяч. И каждый из них имел уникальный идентификатор, который становилось всё сложнее учитывать вручную или запоминать. Необходима была система, которая позволит очеловечить имена компьютеров и хранить все адреса в одном месте, чтобы каждый компьютер в сети имел один и тот же набор всех идентификаторов.</p>

<h2 id="файл-hosts--как-первый-шаг-к-созданию-dns">Файл hosts — как первый шаг к созданию DNS</h2>

<p>Для решения задачи разработчики решили использовать словарь, который связывал уникальное имя и IP-адрес каждого компьютера в сети. Таким словарём стал файл hosts.txt, который и отвечал за привязку IP-адреса к имени компьютера. Файл лежал на сервере Стэнфордского исследовательского института, и пользователи сети регулярно вручную скачивали этот файл на свои компьютеры, чтобы сохранять актуальность словаря, ведь новые компьютеры появлялись в сети почти каждый день.</p>

<p>Выглядел hosts.txt тогда (да и сейчас) таким образом:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>192.168.10.36         MIKE-STRATE-PC
Сетевой (IP) адрес    Имя компьютера
</code></pre></div></div>

<p>При наличии такого файла на компьютере пользователя для связи с компьютером Майка, можно было не запоминать цифры, а использовать понятное латинское имя «MIKE-STRATE-PC».</p>

<p>Посмотрим, как выглядит файл и попробуем добавить туда новое имя, чтобы подключиться к компьютеру с использованием данного имени. Для этого отредактируем файл hosts. Вы можете найти его на своём компьютере по следующему адресу:</p>

<ul>
  <li>В Unix-системах: <code class="language-plaintext highlighter-rouge">/etc/hosts</code></li>
  <li>В Windows-системах: <code class="language-plaintext highlighter-rouge">%Путь до папки Windows%/system32/drivers/etc/hosts</code></li>
</ul>

<p><a href="https://asciinema.org/a/FOqRvmFFMQPtruCnr59HEGAY3"><img src="https://asciinema.org/a/FOqRvmFFMQPtruCnr59HEGAY3.svg" alt="asciicast" /></a>
<!-- <script id="asciicast-FOqRvmFFMQPtruCnr59HEGAY3" src="https://asciinema.org/a/FOqRvmFFMQPtruCnr59HEGAY3.js" data-cols="200" data-rows="25" data-size="small" data-preload="1" async></script> --></p>

<p>Компьютеру с IP-адресом 192.168.10.36, который находится внутри локальной сети мы указали имя «MIKE-STRATE-PC». После чего можно воспользоваться командой ping, которая пошлёт специальный запрос на компьютер Майка и будет ждать от него ответа. Похоже на то, как вы стучитесь в дверь или звоните в звонок, чтобы узнать, «есть ли кто дома?» Такой запрос можно послать на любой компьютер.</p>

<p><a href="https://asciinema.org/a/8H3jKqFsVUNyoxtzn7AWPJ1GH"><img src="https://asciinema.org/a/8H3jKqFsVUNyoxtzn7AWPJ1GH.svg" alt="asciicast" /></a>
<!-- <script id="asciicast-8H3jKqFsVUNyoxtzn7AWPJ1GH" src="https://asciinema.org/a/8H3jKqFsVUNyoxtzn7AWPJ1GH.js" data-cols="80" data-rows="15" data-size="medium" data-preload="1" async></script> --></p>

<p>По мере развития сети и «обрастания» её новыми клиентами, такой способ становился неудобным. Всем пользователям компьютеров было необходимо всё чаще скачивать свежую версию файла с сервера Стэнфордского исследовательского института, который обновлялся вручную несколько раз в неделю. Для добавлений же новых версий было необходимо связываться с институтом и просить их внести в файл новые значения.</p>

<p>В 1984 году Пол Мокапетрис (Paul Mockapetris) описал новую систему под названием DNS (Domain Name System / Система доменных имён), которая была призвана автоматизировать процессы соотнесения IP-адресов и имён компьютеров, а также процессы обновления имён у пользователей без необходимости ручного скачивания файла со стороннего сервера.</p>

<h2 id="работа-dns-в-сети-интернет">Работа DNS в сети интернет</h2>

<p>В настоящее время интернет окружает нас повсюду — мы используем его в мобильных и настольных устройствах. Системы видеонаблюдения и даже чайники взаимодействуют друг с другом с помощью интернета, и для корректной связи с ними нужна система, с помощью которой пользователи смогут одним запросом в адресной строке подключиться к нужному сервису. Всё это ложится на плечи системы DNS, которая внутри себя хранит намного больше информации, чем просто IP-адрес и название устройств. Записи в DNS также отвечают за корректную отправку электронных писем, связывают друг с другом разные домены и доменные зоны.</p>

<p>DNS является <a href="https://ru.wikipedia.org/wiki/Распределённая_система">распределённой системой</a>, а значит она имеет множество узлов, каждый из которых ответственен за свою зону. Такое возможно благодаря тому, что сама по себе структура DNS является иерархической, то есть выделяет зоны ответственности, где каждый родитель знает о расположении своего дочернего сервера, и знает зону его ответственности.</p>

<p><img src="/assets/images/dns/hierarchy.jpg" alt="dns, hierarchy" /></p>

<p>Рассмотрим работу DNS и её составных частей поближе.</p>

<h3 id="терминология">Терминология</h3>

<p>Основными компонентами DNS являются:</p>

<p><strong>Домен (доменное имя)</strong> — символьное имя для обозначения сервера в сети интернет. Доменные имена являются иерархической структурой, в которой каждый уровень отделяется точкой. Основными уровнями являются:</p>

<ul>
  <li>Корневой домен. В урле он не используется, но всегда подразумевается. От него начинается построение всех урлов в сети интернет</li>
  <li>Домены верхнего уровня. К ним относятся домены .ru, .com, .net, .su и так далее. Также этот домен называют доменом первого уровня.</li>
  <li>Домен второго уровня (или основной домен). Это основное имя вашего сайта</li>
  <li>Поддомены (домены третьего, четвёртого, пятого и т.д. уровня). Сюда входят все поддомены основного домена.</li>
</ul>

<p><strong>DNS-сервер</strong> — система, ответственная за хранение и поддержание в актуальном состоянии записей о своих дочерних доменах. Каждый DNS-сервер ответственен только за свою зону, то есть DNS-сервер домена .io знает о том, где расположен домен hexlet, DNS-сервер которого знает о расположении своих поддоменов.</p>

<p><strong>Корневой DNS-сервер</strong> — система, знающая расположение (IP-адреса) DNS-серверов доменов верхнего уровня.</p>

<p><strong>Ресурсная запись</strong> — единица информации DNS-сервера. Каждая ресурсная запись имеет несколько полей:</p>

<ul>
  <li>Имя (домен, к которому относится запись)</li>
  <li>Тип</li>
  <li>Параметры</li>
  <li>Значение</li>
</ul>

<h3 id="подключение">Подключение</h3>

<p>Необходимо понимать, что доменное имя — это всего лишь абстракция для людей. Сам компьютер и приложения (например, браузер) обращается к сервисам внутри сети интернет только по IP-адресам.</p>

<p>Рассмотрим процесс получения IP-адреса по доменному имени на примере домена <code class="language-plaintext highlighter-rouge">ru.hexlet.io</code>.</p>

<p>Возможны два варианта событий:</p>

<ol>
  <li>
    <p>Компьютер посылает запрос на известный ему DNS-сервер. Чаще всего им является DNS-сервер поставщика интернет-услуг (провайдера): <em>какой IP-адрес у домена ru.hexlet.io?</em>. DNS-сервер провайдера находит в своей базе информацию о том, что домен <code class="language-plaintext highlighter-rouge">ru.hexlet.io</code> расположен по IP-адресу 104.25.238.104 и возвращает значение нашему компьютеру. Этот процесс похож на то, как использовался файл <code class="language-plaintext highlighter-rouge">hosts.txt</code>.</p>
  </li>
  <li>
    <p>Ближайший известный DNS-сервер не имеет записи о том, по какому IP-адресу располагается домен <code class="language-plaintext highlighter-rouge">ru.hexlet.io</code>. В таком случае запускается цепочка процессов, благодаря которым наш компьютер получит IP-адрес домена:</p>

    <ul>
      <li>
        <p>Так как домен является иерархической структурой, и все DNS-сервера знают IP-адреса корневых DNS-серверов, то к ним и происходит запрос на получение IP-адреса домена.</p>
      </li>
      <li>
        <p>Корневые DNS-сервера, в соответствии со своей зоной ответственности знают о том, где располагаются DNS-сервера доменов верхнего уровня. Эти адреса возвращаются DNS-серверу нашего провайдера, после чего на нужный DNS-сервер (в нашем случае на DNS-сервер домена .io) посылается запрос на получение IP-адреса домена ru.hexlet.</p>
      </li>
      <li>
        <p>В соответствии со своей зоной ответственности DNS-сервер домена верхнего уровня возвращает IP-адрес DNS-сервера домена hexlet, на который посылается запрос на получение IP-адреса поддомена ru.</p>
      </li>
      <li>
        <p>DNS-сервер возвращает IP-адреса поддомена ru, после чего DNS-сервер нашего провайдера возвращает полученный адрес на наш компьютер, который уже может обратиться к домену ru.hexlet.io по его IP-адресу.</p>
      </li>
    </ul>
  </li>
</ol>

<h3 id="рекурсия-в-dns">Рекурсия в DNS</h3>

<p>Можно заметить, что оба описанных выше варианта сильно различаются: в первом случае мы просто послали запрос и получили ответ, а во втором — возникла необходимость идти от самого корневого домена в процессе поиска нужной нам записи. Такой процесс является рекурсивным, потому что ближайший DNS-сервер непрерывно посылает запросы к другим DNS-серверам до тех пор, пока не получит необходимые ресурсные записи. Данный процесс можно визуализировать следующим образом:</p>

<p><img src="/assets/images/dns/structure.jpg" alt="dns, structure" />
<small>При запросах 1 и 2 ближайший сервер будет получать информацию о местонахождении DNS-серверов, которые входят в зону ответственности того сервера, на который был послан запрос. При запросе 3 будут получены необходимые ресурсные записи домена hexlet и его поддоменов.</small></p>

<p>Рекурсивный поиск — это достаточно долгая операция, которая к тому же сильно нагружает сеть и сами DNS-сервера. Именно для того, чтобы избавиться от рекурсии каждый DNS-сервер <a href="https://ru.wikipedia.org/wiki/Кэш">кеширует</a> информацию о записях, которые получает, для быстрой отдачи этой информации пользователю.</p>

<p>Как видно, рекурсивный поиск предполагает нахождение конечного ответа на наш запрос путём поиска записи по всем необходимым DNS-серверам, начиная с корневого. В противовес такому способу также существует итеративный запрос, который в отличие от рекурсивного выполняет всего лишь одну итерацию — это запрос ближайшему DNS-серверу, от которого мы можем получить как закешированный ответ, так и данные той зоны, за которую он ответственен. Важно отметить, что итеративный запрос предполагает всего один такой запрос.</p>

<p>Чаще всего в интернете DNS-сервера умеют посылать рекурсивные запросы, потому что в таком случае ответ можно закешировать, что в дальнейшем позволит снизить нагрузку как на сам сервер, так и на другие DNS-сервера. Время, на которое DNS-сервер кеширует информацию, указывается в ресурсной записи DNS, о которой сейчас пойдёт речь.</p>

<h2 id="ресурсные-записи-dns">Ресурсные записи DNS</h2>

<p>Современный интернет подразумевает не только получение IP-адреса по доменному имени, но и пересылку электронной почты, подключение дополнительных сервисов аналитики к сайту, настройку защищённого протокола HTTPS. Это чаще всего делается с помощью ресурсных записей DNS.</p>

<p>Рассмотрим, какие ресурсные записи используются, и на что они указывают. Основными ресурсными записями DNS являются:</p>

<p><strong>A-запись</strong> — одна из самых важных записей. Именно эта запись указывает на IP-адрес сервера, который привязан к доменному имени.</p>

<p><strong>MX-запись</strong> — указывает на сервер, который будет использован при отсылке доменной электронной почты.</p>

<p><strong>NS-запись</strong> — указывает на DNS-сервер домена.</p>

<p><strong>CNAME-запись</strong> — позволяет одному из поддоменов дублировать DNS-записи своего родителя. Делается это для того, чтобы перенаправить запрос с одного домена на другой (чаще всего для перенаправления домена с поддоменом www на домен без такого поддомена).</p>

<p><strong>TXT-запись</strong> — в этой записи хранится текстовая информация о домене. Часто используется для подтверждения прав на владение доменом, посредством добавления определённой строки, которую присылает нам интернет-сервис.</p>

<p>Ресурсные записи почти всегда одинаковые, но для некоторых записей могут появляться другие поля, например в MX-записях также присутствует значение приоритета. В основном ресурсные записи имеют следующую структуру:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Имя записи   TTL   Класс   Тип записи  Значение
</code></pre></div></div>

<p>Разберём подробнее:</p>

<p><strong>Имя записи</strong> — указывается домен, которому принадлежит данная ресурсная запись.</p>

<p><strong>TTL</strong> <em>(time to live / время жизни)</em> — время в секундах, на которое будет закешировано значение ресурсной записи. Это необходимо для разгрузки DNS-серверов. Благодаря кешированию и возможна ситуация, что ближайший DNS-сервер знает IP-адрес запрашиваемого домена.</p>

<p><strong>Класс</strong> — предполагалось, что DNS может работать не только в сети интернет, поэтому в записи указывается и её класс. На сегодняшний день поддерживается только одно значение — IN (Internet).</p>

<p><strong>Тип</strong> — указывает тип ресурсной записи, основные из которых были разобраны выше.</p>

<p><strong>Значение</strong> — непосредственно значение ресурсной записи. В зависимости от типа ресурсной записи значения могут быть представлены в разном виде.</p>

<p>Посмотрим, в каком виде эти записи хранятся на DNS-серверах на примере домена ya.ru. Для этого воспользуемся утилитой dig, которая получает все доступные ресурсные DNS-записи от DNS-сервера и выводит их пользователю.</p>

<p>Утилита dig является DNS-клиентом и входит в состав одного из самых распространённых DNS-серверов BIND.</p>

<p><a href="https://asciinema.org/a/wWl4mvdWBI30szBYw56uzQGrd"><img src="https://asciinema.org/a/wWl4mvdWBI30szBYw56uzQGrd.svg" alt="asciicast" /></a>
<!-- <script id="asciicast-wWl4mvdWBI30szBYw56uzQGrd" src="https://asciinema.org/a/wWl4mvdWBI30szBYw56uzQGrd.js" data-cols="200" data-rows="25" data-size="small" data-preload="1" async></script> --></p>

<h2 id="пример-реальных-записей-dns">Пример реальных записей DNS</h2>

<p><img src="/assets/images/dns/output.png" alt="dns, output" /></p>

<p>Не пугайтесь такого длинного вывода. Уже сейчас можно понять почти всё, что тут указано. Разберём вывод каждой секции более детально.</p>

<p>Вывод состоит из нескольких частей:</p>

<ul>
  <li>Шапка</li>
  <li>Секция запроса</li>
  <li>Секция ответа</li>
  <li>Служебная информация</li>
</ul>

<p><strong>Шапка запроса</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>; &lt;&lt;&gt;&gt; Net::DNS::Dig 0.12 &lt;&lt;&gt;&gt; -t any ya.ru.
;;
;; Got answer.
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 52109
;; flags: qr rd ra; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 0
</code></pre></div></div>
<p>Здесь указывается проставленные флаги нашего запроса, количество запросов и ответов, а также другая служебная информация.</p>

<p><strong>Секция запроса</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>;; QUESTION SECTION:
;ya.ru.   IN    ANY
</code></pre></div></div>

<p>В секции запроса указывается домен, к которому происходит обращение, класс записи и те записи, которые мы хотим получить. ANY указывает на то, что нужно вывести все доступные ресурсные записи, но если вы хотите поэкспериментировать с утилитой сами, то можете с помощью специального ключа получить вывод только конкретных записей, которые интересуют в настоящий момент.</p>

<p><strong>Секция ответа</strong></p>

<p>Секция ответа достаточно большая, поэтому для удобства разобьём её по типам ресурсных записей.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>;; ANSWER SECTION:
ya.ru. 	7199	IN	NS	 ns1.yandex.ru.
ya.ru. 	7199	IN	NS	 ns2.yandex.ru.

ya.ru.	599	IN	A	 87.250.250.242
ya.ru.	599	IN	AAAA	 2A02:6B8:0:0:0:0:2:242
</code></pre></div></div>

<p>Как запись A, так и AAAA-запись указывают на IP-адрес, который привязан к нашему домену. A-запись указывает IP в формате IPv4, а запись AAAA — в формате IPv6.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ya.ru.	7199	IN	MX	 10 mx.yandex.ru.
</code></pre></div></div>

<p>MX-запись также имеет параметр приоритета. Так как серверов для отправки почты может быть несколько, то и записей может быть много, поэтому для определения основного сервера указывается приоритет записи. Чем меньше число, тем выше приоритет.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ya.ru.	3599	IN	SOA	 ns1.yandex.ru. sysadmin.yandex.ru. 2019021800 900 600 2592000 900
</code></pre></div></div>

<p><strong>Запись SOA</strong> <em>(Start of Authority)</em> указывает на несколько различных параметров:</p>

<ol>
  <li>Сервер с эталонной информацией о текущем домене</li>
  <li>Контактную информацию ответственного лица</li>
  <li>Различные параметры кеширования записей</li>
</ol>

<p>Бывают и некоторые более специфичные ресурсные записи, о которых здесь не было речи, но это не значит, что они бесполезны. Полный перечень таких записей всегда можно найти в документации (например по DNS-серверу BIND).</p>

<h2 id="выводы">Выводы</h2>

<p>DNS-сервера сейчас составляют основу всего интернета и используются почти в каждом действии пользователя в сети, будь то переход на сайт, отправка электронной почты, работы с интернет-приложением на телефоне и так далее. Поэтому знания о принципах работы DNS-серверов и основных ресурсных записях, благодаря которым и возможно перемещение по сети интернет, являются важными для разработчика.</p>

<h2 id="дополнительные-материалы">Дополнительные материалы</h2>

<ul>
  <li><a href="https://howdns.works">Весёлый комикс про то, как работает DNS</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/how-to-pass-the-interview/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как проходить интервью</turbo:topic> -->
            <title>Как проходить интервью</title>
            <pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/how-to-pass-the-interview/">Как проходить интервью</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/how-to-pass-the-interview/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Для успешного прохождения интервью, недостаточно что-то знать. Важно уметь показать свои знания, способности и, в конце концов, произвести приятное впечатление на тех кто вас собеседует. В этом гайде мы подробно разберем процесс интервью, поговорим о том как себя вести, что говорить и какие задавать вопросы если спрашивают.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/employment?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Курс, помогающий новичкам эффективно составить резюме, попасть на собеседование и пройти его
</a>
</div>

<p>Оценка вас как кандидата, начинается еще до того как вы зайдете в офис компании. Бывает такое, что кандидат опаздывает на встречу и не предупреждает заранее или вообще не приходит. Вряд ли что с таким человеком захотят иметь дело. Ответственность за происходящее вокруг - базовое требование к любому кандидату. Причем никто не будет произносить это вслух, ответственность подразумевается по умолчанию в любом деле.</p>

<p>Будьте пунктуальны, звоните заранее, договаривайтесь, извиняйтесь если нужно. Ситуации бывают разные, никто не застрахован от форс-мажоров. Позвоните и предупредите, так вы покажете свою заботу о других, люди это ценят.</p>

<p>Опрятность (чистоплотность!) имеет большое значение. Говорят что внутренне, симпатия к человеку рождается в течение первых 20 секунд контакта (прим. автора: я специально отслеживал в себе связь между симпатией и результатом собеседования, корреляция высокая, в редких случаях симпатия пропадала и еще реже происходило обратное).</p>

<p>Одежда тоже важна, хоть и в меньшей степени. Главное соответствовать. Приходить в костюме с галстуком точно не нужно, вас скорее всего не поймут. Одевайтесь так, как вы делаете это в обычной жизни.</p>

<p>И последняя общая рекомендация. Всем нравится уместный юмор, он разряжает обстановку и располагает к себе. Пока вы заходите в офис, ждете, здороваетесь и проходите в переговорку, можно перекинуться парой слов и дать понять что вы открытый человек.</p>

<h2 id="рассказ-о-себе">Рассказ о себе</h2>

<p>В начале собеседования часто спрашивают о себе, о последнем месте работы, о полученном опыте, о проектах в которых вы участвовали. То что вы скажете на этом этапе, скорее всего станет основой для дальнейшего разговора. Собеседующим больше всего интересен ваш реальный опыт, какие задачи вы решали, с какими сложностями сталкивались и как их преодолевали. Если такой опыт есть то прекрасно, если нет, то ничего страшного, говорите про учебные проекты.</p>

<p>Рассказывая о себе не увлекайтесь. Интервьюеру вряд ли хочется услышать всю вашу историю начиная от школы и до сегодняшних дней.</p>

<h2 id="закрытые-вопросы">Закрытые вопросы</h2>

<p>Закрытые вопросы предполагают однозначный ответ или ответ «да» или «нет». Частый вопрос “работали ли вы с X?”. Этими вопросами невозможно проверить способности кандидата и то как он решает задачи, но можно быстро узнать на каком этапе освоения технологий он находится.</p>

<p>Вариантов действий здесь немного. Если вы совсем не работали с тем о чем спрашивают, то говорите нет. Если хотя бы знаете что это, то так и скажите: “знаю что эта штука решает такую проблему, но с X не работал”. Возможно у вас есть опыт работы с чем-то похожим, об этом тоже можно сказать: “с X не работал, для той же задачи я использовал Y”. Любой такой ответ, дает собеседующему зацепку о чем можно поговорить.</p>

<h2 id="открытые-вопросы">Открытые вопросы</h2>

<p>Вопросы предполагающие развернутый ответ. Главное - не отвечать на такие вопросы “я не знаю”, кроме случаев когда вы вообще не имеете ни малейшего представления о чем идет речь. В такой ситуации обязательно уточните, где про это лучше прочитать или посмотреть. Для собеседующего это хороший знак, он видит что вам интересно.</p>

<p>Большинство открытых вопросов задают не с целью получить от вас исчерпывающий ответ, а с целью поговорить с вами, увидеть ход мыслей, умение анализировать, способность задавать правильные вопросы, выдвигать гипотезы и находить ответы. Открытый вопрос - почти всегда диалог. Задавайте уточняющие вопросы, предполагайте, говорите в слух, приводите доводы за и доводы против. Пример диалога:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>```
интервьюер (и): Каким образом можно перевернуть строку в языке X?
собеседующийся (с): Можно использовать стандартную библиотеку?
и: Допустим
c: Тогда я бы воспользовался встроенной функцией reverse
и: Хорошо, а если стоит задача реализовать переворот самостоятельно?
с: Важна эффективность решения или, в первую очередь простота и понятность?
и: Предложите любое решение
с: Так как в первую очередь важна читаемость, я бы разбил строку на массив символов и соединил этот массив в строку в обратном порядке.
```
</code></pre></div></div>

<p>Основная часть собеседования, обычно, крутится вокруг открытых вопросов. От вашего умения рассуждать в слух зависит многое.</p>

<h2 id="решение-задач">Решение задач</h2>

<p>Разные собеседующие по разному относятся к решению задач. Некоторые их никогда не дают, другие (прим. автора: отношу себя к таким) считают что без реального кодирования нельзя сделать правильных выводов об уровне. В любом случае вы должны быть готовы в режиме собеседования решать задачки подобные <a href="https://ru.hexlet.io/challenges/intro_to_programming_fizzbuzz_exercise">FizzBuzz</a>. Причем как и за компьютером, так и на листочке бумаги.</p>

<h2 id="вопросы-собеседующим">Вопросы собеседующим</h2>

<p>В конце интервью вас попросят задать вопросы о компании, процессе трудоустройства и тому подобное. Начните с вопросов по самому интервью. Попросите рекомендации о том что и где почитать, с чем разобраться. Любой программист с удовольствием поделится с вами этим, а про себя добавит плюсик вам в карму.</p>

<p>Обязательно узнайте чем придется заниматься: свой продукт или заказная разработка, какой проект, можно ли его увидеть в интернете, какие текущие задачи стоят перед разработкой, кто входит в команду проекта.</p>

<p>Уточните про инженерную культуру: пишутся ли тесты, есть ли код ревью, менторинг.</p>

<p>Но будьте аккуратны. Если вопросов будет слишком много, вас посчитают дотошным и могут не захотеть связываться.</p>

<h2 id="после-собеседования">После собеседования</h2>

<p>Это продвинутая практика, которая может изменить решение о вашем найме в положительную сторону. Обязательно разберите все вопросы, ответьте на них и составьте список с ними. Отправьте список на почту компании с пояснением что вы разобрали все вопросы. Интервьюеры могут быть впечатлены настолько, что решат вас взять за гипермотивацию (прим. автора: в моей практике такое было не раз).</p>

<h2 id="послесловие">Послесловие</h2>

<p>Даже если вы не прошли интервью - ничего страшного не случилось. Вы получили колоссальный опыт, узнали о своих слабых местах. В следующий раз будет значительно проще и понятнее. Более того, если вы показали недостаточно знаний, но при этом понравились как человек, вас легко могут позвать на интервью снова. Обычно в компаниях есть правило, о том что в следующий раз зовем кандидата через 3-6 месяцев. Обязательно уточните у них эту информацию и готовьтесь к новой встрече.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=M4WW8-9GwRA">Вебинар: Собеседования. Взгляд со стороны работодателя</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/how-to-prepare-for-interview/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как проходит собеседование у программистов, что спрашивают</turbo:topic> -->
            <title>Как проходит собеседование у программистов, что спрашивают</title>
            <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/how-to-prepare-for-interview/">Как проходит собеседование у программистов, что спрашивают</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/how-to-prepare-for-interview/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Конкретные знания и способность показать их на интервью – две совершенно разные вещи. Первое собеседование на должность программиста – источник постоянного стресса независимо от возраста. Во время собеседования начинают забываться элементарные вещи, а некоторые вопросы ставят в тупик.</p>

<p>Совсем убрать волнение невозможно, но подготовка к интервью может его уменьшить. В этом гайде мы разберем как лучше готовиться к собеседованию.</p>

<p><em>Учтите, что само интервью может длиться не один час. В некоторые компании нужно пройти 2 и более раундов. Иногда они идут подряд, превращаясь в многочасовой марафон, иногда разбиты на несколько дней.</em></p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/employment?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Курс, помогающий новичкам эффективно составить резюме, попасть на собеседование и пройти его
</a>
</div>

<p>Двух одинаковых интервью не бывает. Одни и те же люди, проводят каждое собеседование немного по разному. Очень многое зависит от того, в какую сторону пойдет диалог, какие ошибки совершит собеседующийся и куда приведут его размышления. Более того, даже в рамках одной специализации, разные компании могут спрашивать абсолютно разные вещи. Чем сильнее компания, тем больше фундаментальных вопросов и меньше прикладных. И наоборот. В совсем простых ситуациях, интересуются исключительно прикладными навыками, которые нужны конкретно на этой должности.</p>

<p>Процесс собеседования зависит от вашего предыдущего опыта. Если с вами можно поговорить о прошлых проектах, то, скорее всего, вас начнут расспрашивать про них. Если нет, то тогда пойдут в ход тесты на общую сообразительность.</p>

<h2 id="ключевые-темы">Ключевые темы</h2>

<h3 id="о-себе-прошлый-опыт">О себе. Прошлый опыт.</h3>

<p>Обычно собеседование начинается со знакомства. На этом этапе к вам присматриваются, оценивают общую адекватность и ищут зацепки для дальнейшего разговора. В идеале нужно иметь за плечами реальные проекты с вашим участием. Подойдут и учебные проекты, код которых выложен на гитхабе.</p>

<p>На этом этапе будьте готовы ответить на следующие вопросы:</p>

<ul>
  <li>Какую последнюю книгу по программированию вы прочитали?</li>
  <li>Чем вы больше всего гордитесь как программист?</li>
  <li>Какая самая сложная (интересная) задача, которую вы решали в прошлом проекте или в учебном проекте?</li>
  <li>Как вы тестировали работоспособность кода? (Идеально если вы умеете писать автоматические тесты)</li>
  <li>Как был построен процесс разработки на прошлом месте? (для тех у кого было такое место)</li>
  <li>Почему Вы ушли с предыдущего рабочего места?</li>
  <li>Кем вы видите себя через пять лет?</li>
</ul>

<p>Рекомендации</p>

<ul>
  <li>Создайте несколько проектов на гитхабе</li>
  <li>Ответьте для себя на вопросы описанные выше</li>
  <li>Познакомьтесь с идеями <a href="https://ru.wikipedia.org/wiki/Экстремальное_программирование">экстремального программирования</a></li>
</ul>

<p>Ссылки</p>

<ul>
  <li><a href="https://ru.hexlet.io/pages/recommended-books">Книги, которые стоит читать любому программисту</a></li>
  <li><a href="https://github.com/Hexlet/ru-test-assignments">Список тестовых заданий от разных компаний</a></li>
  <li><a href="https://ru.hexlet.io/projects">Проекты Хекслета</a></li>
</ul>

<h3 id="задачи">Задачи</h3>

<h4 id="задачки-на-эврику-или-воображение">Задачки на эврику или воображение</h4>

<p>Существует категория задач, которые было модным задавать на собеседованиях раньше. Первыми, такое стали спрашивать в Microsoft, затем подтянулись и многие другие. Вот несколько примеров:</p>

<ul>
  <li>Почему люки круглые?</li>
  <li>Сколько теннисных мячей поместится в автобус?</li>
  <li>Сколько настройщиков пианино в мире?</li>
  <li>Как сдвинуть гору Фудзи?</li>
  <li>Если бикфордов шнур горит один час, то как сделать так чтобы он сгорел за полчаса?</li>
</ul>

<p>Сами по себе вопросы интересные. Над ними стоит поломать голову в кругу друзей. Проблема в том, что они слабо коррелируют с уровнем разработчика. Эти вопросы не являются логическими в строгом смысле, они больше опираются на воображение и “эврику”, такое состояние, когда вы внезапно догадались до ответа. Правда ответов обычно больше чем один.</p>

<p>Считается что сам процесс рассуждения над этими вопросами, показывает как у человека работает мозг. С одной стороны показывает, но с другой, состояние стресса и внезапность таких вопросов обескураживает. Более того, интервьюируемый скорее всего не поймет что от него хотят услышать.</p>

<p>Крупные компании отказались от этих вопросов, но никто не застрахован. Всегда есть вероятность, что вас спросят про люки. Поэтому имеет смысл подготовиться заранее. Посмотреть список наиболее распространенных и порассуждать над ними в домашнем кругу или, например, в сообществе <a href="https://slack-ru.hexlet.io">Хекслета</a>.</p>

<p>Рекомендации</p>

<ul>
  <li>Прочитайте книгу “Как сдвинуть гору фудзи?”</li>
  <li>Найдите списки подобных вопросов и попробуйте ответить на них</li>
</ul>

<p>Ссылки</p>

<ul>
  <li><a href="https://habr.com/ru/post/87239/">Примеры задач</a></li>
</ul>

<h4 id="задачки-на-логику">Задачки на логику</h4>

<p>Это другой тип задач. Они имеют вполне конкретные ответы и опираются на формальную логику. Например:</p>

<ul>
  <li>Сколько раз в день пересекаются стрелки часов?</li>
  <li>Какой угол между часовой и минутной стрелкой если на часах 15:15?</li>
  <li>У Мегамозга есть два одинаковых стеклянных шарика. За какое минимальное число бросков можно гарантированно определить, начиная с какого этажа 100-этажного здания шарики разбиваются?</li>
</ul>

<p>Последняя задачка очень сильная и ее часто задают. Хотя она и выглядит мультяшно, внутри нее классная алгоритмическая задача.</p>

<p>Периодическое решение таких задач прокачивает алгоритмические навыки, работу с системами счисления, логическими операциями и математикой.</p>

<p>Рекомендации</p>

<ul>
  <li>Научитесь решать логические задачи</li>
</ul>

<p>Ссылки</p>

<ul>
  <li><a href="https://www.braingames.ru/">braingames</a> - сайт и сообщество по решению подобных задач.</li>
</ul>

<h4 id="алгоритмы-и-структуры-данных">Алгоритмы и структуры данных</h4>

<p>На этом этапе могут попросить реализовать переворот односвязного списка или выполнить сортировку пузырьком. Более сложные вещи писать не просят, их могут спросить устно. Например:</p>

<ul>
  <li>Как найти пропущенное число в отсортированном массиве содержащем значения от 1 до 100?</li>
  <li>Чем отличается O(1) от O(n)?</li>
  <li>Какая алгоритмическая сложность у бинарного поиска?</li>
  <li>Как определить наличие цикла в односвязном списке?</li>
  <li>Как эффективно объединить два отсортированных массива?</li>
</ul>

<p>Этого раздела не стоит пугаться, никто не требует от вас глубокого знания алгоритмов и всего прочитанного Кнута. Достаточно прочитать одну книгу и немного попрактиковаться. В любом случае этот опыт не будет лишним, правильно выбранная структура данных в коде, сделает вашу жизнь значительно легче.</p>

<p>Рекомендации</p>

<ul>
  <li>Вспомните логарифмы. Они нужны для оценки сложности. Это единственная обязательная математика для книг по алгоритмам.</li>
  <li>Изучите основные алгоритмы (есть в книге из ссылок).</li>
  <li>Изучите основные структуры данных (есть в книге из ссылок).</li>
  <li>Напишите сортировку пузырьком.</li>
  <li>Познакомьтесь с хеш-таблицами.</li>
  <li>Научитесь выполнять бинарный поиск.</li>
  <li>Изучите сбалансированные деревья.</li>
  <li>Выучите нотацию Big O, научитесь определять сложность простых алгоритмов.</li>
</ul>

<p>Ссылки</p>

<ul>
  <li><a href="https://habr.com/ru/company/piter/blog/323310/">Грокаем алгоритмы</a></li>
</ul>

<h4 id="операционные-системы-и-сети">Операционные системы и сети</h4>

<p>Сюда входит огромный перечень тем, например, владение командной строкой, понимание tcp/ip, http, dns, event loop и многое другое.</p>

<p>Как правило, эти вопросы не задают напрямую. В основном придумывают различные истории или ситуации. Примеры вопросов:</p>

<ul>
  <li>Может ли существовать такой ip адрес: 283.12.30.111?</li>
  <li><a href="https://habr.com/ru/company/htmlacademy/blog/254825/">Что происходит, когда пользователь вбивает в браузер адрес google.com?</a></li>
  <li>Можно ли в HTTP запросы указывать одновременно query и post параметры?</li>
</ul>

<p>Рекомендации</p>

<ul>
  <li>Прочитайте книгу по операционным системам</li>
  <li>Перейдите на Linux (например Ubuntu)</li>
  <li>Изучите сети на базовом уровне: tcp/ip, dns, http</li>
</ul>

<h4 id="операции-с-числами">Операции с числами</h4>

<p>Популярные задачи на системы счисления и битовые операции.</p>

<ul>
  <li>Как определить четность числа не выполняя деления?</li>
  <li>Как поменять две переменные местами не используя третью переменную?</li>
</ul>

<p>Рекомендации</p>

<ul>
  <li>Изучите системы счисления</li>
  <li>Изучите битовые операции</li>
</ul>

<h4 id="problem-solving-задачи">Problem-Solving задачи</h4>

<p>Самый интересный тип задач. В этих задача моделируется реальная ситуация. Вам предстоит придумать способ решения в рамках каких-то ограничений. Например:</p>

<ul>
  <li>Как реализовать редактор так, чтобы он открывал с одинаковой скоростью файлы любых размеров</li>
</ul>

<h3 id="написание-кода">Написание кода</h3>

<p>Чем меньше у вас опыта, тем выше вероятность того, что вас попросят написать код. Обычно просят написать его на листочке или в среде подобной <a href="https://repl.it/">repl.it</a>. На задачу дают 10-20 минут. Пара примеров:</p>

<ul>
  <li>Напишите программу, которая выводит на экран числа от 1 до 100. При этом вместо чисел, кратных трем, программа должна выводить слово «Fizz», а вместо чисел, кратных пяти — слово «Buzz». Если число кратно и 3, и 5, то программа должна выводить слово «FizzBuzz».</li>
  <li>Напишите программу, которая переворачивает строку. Предложите несколько способов.</li>
  <li>Напишите программу, которая проверяет сбалансированность скобок в строке.</li>
  <li>Реализуйте программу, которая удаляет директорию со всеми вложенными файлами и директориями (задача на рекурсию)</li>
</ul>

<p>Во время решения могут попросить рассуждать над задачей вслух. Собеседующий хочет проследить за вашим ходом мыслей.</p>

<p>Эти задачи показывают насколько у интервьюируемого хорошо с логикой, алгоритмическим мышлением, как он владеет базовыми конструкциями языка. Они позволяют отсеять слабых кандидатов, но не помогают определить сильных.</p>

<p>В интернете созданы десятки сервисов, специализирующихся на подобных задачах. Обязательно включите их в свой список для подготовки. Научитесь проходить задачи уровня easy с закрытыми глазами. Этот навык поможет не только для прохождения собеседований, но и в реальном программировании.</p>

<p>Рекомендации</p>

<ul>
  <li>Потренируйтесь писать код на листочке</li>
  <li>Попробуйте рассуждать вслух во время решения алгоритмических задач</li>
  <li>Найдите удобную платформу и оттачивайте мастерство</li>
</ul>

<p>Ссылки</p>

<ul>
  <li><a href="https://habr.com/ru/post/298134/">FizzBuzz, или почему программисты не умеют программировать</a></li>
  <li><a href="https://habr.com/ru/company/hexlet/blog/434786/">7 платформ для прокачки</a></li>
</ul>

<h3 id="прикладные-знания">Прикладные знания</h3>

<p>Сюда входит большая группа вопросов, по тем технологиям с которыми вам придется работать.</p>

<h4 id="общие">Общие</h4>

<ul>
  <li>Базы данных. SQL. Могут попросить составить запрос. Чаще всего интересует знание соединений (joins).</li>
  <li>ООП. На базовом уровне имеется ввиду умение создавать классы и умение моделировать.</li>
  <li>Веб-разработчиков могут спросить про DOM Api.</li>
</ul>

<h4 id="специфичные">Специфичные</h4>

<p>Здесь проверяется знание библиотек, фреймворков, каких-то особенностей языков. В интернете, особенно на гитхабе, созданы списки по каждому возможному стеку.</p>

<ul>
  <li><a href="https://github.com/enhorse/java-interview">java</a></li>
  <li><a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions/tree/master/src/translations/russian">frontend</a></li>
  <li><a href="https://grishaev.me/interview/">python</a></li>
  <li><a href="https://habr.com/ru/post/231071/">javascript</a></li>
</ul>

<h3 id="полезные-ссылки">Полезные ссылки</h3>

<ul>
  <li><a href="https://bit.ly/2Gwc2gt">Искусство проведения интервью (Джоэль Спольски)</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/chego-vy-zhdyote-ot-dzhuniora-otvechayut-rukovoditeli-i-opytnye-razrabotchiki">Что руководители и опытные программисты ожидают от джуниора</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/chto-trebuyut-ot-dzhuniorov-rabotodateli-analiz-vakansiy-dlya-mladshih-programmistov">Что требуют от джуниоров работодатели: анализ вакансий</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/how-to-be-a-helpful-for-the-hexlet-community/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как участвовать в жизни Хекслета</turbo:topic> -->
            <title>Как участвовать в жизни Хекслета</title>
            <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/how-to-be-a-helpful-for-the-hexlet-community/">Как участвовать в жизни Хекслета</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/how-to-be-a-helpful-for-the-hexlet-community/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Хекслет — не просто школа программирования. Это большое и <a href="https://slack-ru.hexlet.io">дружелюбное комьюнити</a> в котором более 30 тысяч участников. Многих мы знаем лично, встречаемся, ходим на скалодром и вместе разрабатываем открытые проекты.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/intro_to_git?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Бесплатный курс «Основы Git» с практикой в браузере
</a>
</div>

<p>Самые активные ребята часто спрашивают, как поучаствовать в жизни проекта, принести пользу сообществу и тем, кто учится? А сделать можно многое. Ниже полный список тех активностей, которым нужны руки и голова. Если вам что-то придется по душе, то пишите либо на почту в support@hexlet.io, либо в комьюнити в канал <a href="https://hexlet-ru.slack.com/archives/C0LN151B4">#hexlet-volunteers</a>.</p>

<h2 id="открытые-проекты-github">Открытые проекты (Github)</h2>

<h3 id="локальные-сообщества">Локальные сообщества</h3>

<p><a href="https://github.com/Hexlet/ru-local-communities">Список локальных русскоязычных сообществ</a>. Он нуждается в пополнении и обновлении.</p>

<p>Задачи:</p>

<ul>
  <li>Добавление новых сообществ</li>
  <li>Обновление устаревшей информации</li>
</ul>

<h3 id="тестовые-задания">Тестовые задания</h3>

<p><a href="https://github.com/Hexlet/ru-test-assignments">Список тестовых заданий от разных компаний</a>. У репозитория более 1000 звезд на гитхабе, его много где советуют.</p>

<p>Задачи:</p>

<ul>
  <li>Добавление новых заданий</li>
  <li>Обновление устаревшей информации</li>
</ul>

<h3 id="hexlet-guides">Hexlet Guides</h3>

<p><a href="https://guides.hexlet.io/">Сайт с гайдами для новичков</a>. Эта статья тоже находится на нем. Мы начали делать его, когда поняли, что по многим темам нет хороших руководств для новичков. Тематика гайдов практически любая, они не только про программирование.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexletguides.github.io">Исходный код</a>, включая контент.</li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Улучшение текущих гайдов. Исправление ошибок</li>
  <li>Обновление устаревшей информации</li>
  <li>Добавление новых гайдов. Темы можно посмотреть в <a href="https://github.com/Hexlet/hexletguides.github.io/issues">issues</a></li>
  <li>Обновление движка для гайдов</li>
</ul>

<h3 id="code-basics">Code Basics</h3>

<p><a href="https://ru.code-basics.com/">Code Basics</a> — сайд-проект Хекслета с открытым исходным кодом. Причем открыт как код сайта, так и весь контент. Его цель — дать основы языков программирования с практикой прямо в браузере. Сайт абсолютно бесплатен и останется таким навсегда. В перспективе планируется англоязычная версия. Она есть уже сейчас, но контент переведен лишь частями.</p>

<p>Создавая сайт, мы хотели покрыть две ситуации: первый язык и второй язык.</p>

<ul>
  <li>«Первый язык» — это программа обучения, построенная для полных новичков в программировании.  PHP, JavaScript, Python, Java, Clang. Прямо сейчас на сайте готовы PHP, JavaScript и Python.</li>
  <li>Ко вторым языкам мы относим Racket, Haskell, Go, Ruby, Swift, Kotlin, Clojure, TypeScript, Rust, Shell. Эти языки, обычно, изучают уже зная что-то другое, поэтому их программа отличается от первых языков.</li>
</ul>

<p>PHP и JavaScript мы написали самостоятельно, но уже приняли десятки пулреквестов на самые разные темы: исправление опечаток, ошибки в заданиях, улучшение подачи, переводы на английский. Python почти целиком был написан человеком из сообщества, который стал мейнтейнером этого языка на сайте. Он уже принял несколько пулреквестов.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/hexlet-basics">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Улучшение существующих уроков. Список уроков и языков есть на гитхабе.</li>
  <li>Улучшения самого сайта. Задачи по улучшению появляются в <a href="https://github.com/hexlet-basics/hexlet_basics/issues">issues</a>.</li>
  <li>Создание уроков для новых языков. Прямо сейчас делаются попытки добавить java и ruby.</li>
  <li>Переводы уроков на английский язык.</li>
  <li>Популяризация проекта среди населения)</li>
</ul>

<h3 id="codebattle">Codebattle</h3>

<p><a href="https://codebattle.hexlet.io/">codebattle.hexlet.io</a> — еще один сайд-проект с открытым исходным кодом. Текущая версия разрабатывается целиком и полностью силами комьюнити. В проекте за несколько лет поучаствовали десятки разработчиков.</p>

<p>Кодбатл — игра, в которой два программиста одновременно выполняют одну задачу на разных языках программирования. Кто выполнил быстрее, тот побеждает. Игра затягивает и заставляет попотеть, так как во время набора кода вы видите, как это делает ваш соперник.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/hexlet-codebattle">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li><a href="https://github.com/hexlet-codebattle/codebattle">Участие в разработке сайта</a></li>
  <li><a href="https://github.com/hexlet-codebattle/battle_asserts">Добавление новых соревновательных задач</a></li>
  <li><a href="https://github.com/hexlet-codebattle/chrome_extension">Участие в разработке Chrome расширения</a></li>
</ul>

<p>Общение по проекту происходит в канале #codebattle внутри слак-комьюнити</p>

<h3 id="hexlet-резюме">Hexlet Резюме</h3>

<p><a href="https://cv.hexlet.io/">cv.hexlet.io</a> — опенсорс-проект для соискателей и HR-специалистов. Кандидаты публикуют на сайте резюме, а опытные эйчары рекомендуют, как улучшить эти документы. В проекте используется Ruby on Rails.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexlet-cv">Исходный код</a></li>
</ul>

<p>Задачи можно обсудить в канале #hexlet-volunteers в <a href="https://slack-ru.hexlet.io/">Slack-сообществе</a>.</p>

<h3 id="hexlet-sicp">Hexlet SICP</h3>

<p><a href="https://sicp.hexlet.io/">hexlet-sicp</a> — трекер прохождения <a href="/how-to-learn-sicp/">SICP</a>. Участники отмечают пройденные материалы, отслеживают прогресс других пользователей. Проект работает на Laravel.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexlet-sicp">Исходный код</a></li>
</ul>

<p>Обсудить задачи можно в канале #hexlet-volunteers в <a href="https://slack-ru.hexlet.io/">Slack-сообществе</a>.</p>

<h3 id="hexlet-correction">Hexlet Correction</h3>

<p><a href="https://github.com/Hexlet/hexlet-correction">hexlet-correction</a> — сервис уведомления владельцев сайтов об ошибках и опечатках. После интеграции с сайтом посетители получают возможность выделить ошибку или опечатку и сообщить о ней администратору. Проект работает на Java.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexlet-correction">Исходный код</a></li>
</ul>

<p>Подробности можно узнать в канале #hexlet-volunteers в <a href="https://slack-ru.hexlet.io/">Slack-сообществе</a>.</p>

<h3 id="hexlet-friends">Hexlet Friends</h3>

<p><a href="https://friends.hexlet.io">hexlet-friends</a> — проект с открытым исходным кодом на Python. Сервис отслеживает опенсорсные проекты «Хекслета». Анализируется количество коммитов, пулл-реквестов, issue. Сервис автоматически строит рейтинг участников с «ачивками».</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexlet-friends">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Участие в разработке сервиса</li>
</ul>

<p>Обсуждение в канале #hexlet-volunteers в <a href="https://slack-ru.hexlet.io/">Slack-сообществе</a>.</p>

<h3 id="hexlet-editor">Hexlet Editor</h3>

<p><a href="https://github.com/hexlet/hexlet-editor">hexlet-editor</a> — среда для написания и исполнения кода, которую будем активно использовать на всех платформах Хекслета. Ближайший аналог — сервис repl.it. Бэкенд разрабатывается на NestJS и TypeScript, на фронтенде используется React.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/hexlet/hexlet-editor">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Участие в разработке сервиса</li>
</ul>

<p>Обсудить можно в канале #hexlet-volunteers в <a href="https://slack-ru.hexlet.io/">Slack-сообществе</a>.</p>

<h3 id="hexlet-comparator">Hexlet Comparator</h3>

<p><a href="https://schools.hexlet.io">schools.hexlet.io</a> — сервис для объективного сравнения онлайн-школ программирования. Стек — NextJS, React.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/hexlet-comparator">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Участие в разработке сервиса</li>
  <li>Заполнение информации о школах</li>
</ul>

<h3 id="jsbrowser">JSBrowser</h3>

<p><a href="https://jsbrowser.herokuapp.com/">jsbrowser</a> — браузер внутри браузера. Поддерживает асинхронную работу, вкладки. Ведёт себя как обычный браузер. Технологии — React, Redux.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/jsbrowser">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Участие в разработке сервиса</li>
</ul>

<h3 id="interactive-courses">Interactive-courses</h3>

<p><a href="https://github.com/Hexlet/interactive-courses">interactive-courses</a> - список небольших интерактивных курсов (игровых) по разным направлениям.
Нуждается в пополнении и обновлении.</p>

<p>Задачи:</p>

<ul>
  <li>Добавление новых курсов</li>
  <li>Обновление устаревшей информации</li>
</ul>

<h3 id="руководство-по-rest-api">Руководство по REST API</h3>

<p><a href="https://restapitutorial.ru/">restapitutorial.ru/</a> — перевод оригинального <a href="https://restapitutorial.com/">руководства</a> по REST API на русский язык.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/RestApiTutorial.ru">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Исправление опечаток</li>
  <li>Улучшение внешнего вида</li>
</ul>

<h3 id="react-flowbot-ui-kit">React flowbot ui kit</h3>

<p><a href="https://github.com/Hexlet/react-flowbot-ui-kit">react-flowbot-ui-kit</a> — UI kit для создания флоубота. Работает как виджет, который встраивается на страницу. Пользователь общается с ботом нажимая кнопки в чате, получает в ответ сообщения. Состояния бота описываются в формате yaml как конечный автомат. Вдохновлён <a href="https://github.com/FredrikOseberg/react-chatbot-kit">react-chatbot-kit</a>.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://github.com/Hexlet/react-flowbot-ui-kit">Исходный код</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Разработка виджета</li>
</ul>

<h3 id="nodos">Nodos</h3>

<p><a href="https://github.com/nodosjs/nodos">nodos</a> — фуллстек-фреймворк, вдохновлённый Ruby On Rails для NodeJS. Находится в разработке.</p>

<p>Задачи:</p>
<ul>
  <li>Создание документации</li>
  <li>Разработка ядра</li>
</ul>

<h2 id="хекслет">Хекслет</h2>

<h3 id="курсы">Курсы</h3>

<h4 id="видео-курсы">Видео курсы</h4>

<p>Нас часто просят сделать транскрипцию видео, по образу и подобию курса <a href="https://ru.hexlet.io/courses/introduction_to_programming">введение в программирование</a>. Вы можете попробовать поучаствовать в этом процессе.</p>

<p>Задачи:</p>

<ul>
  <li>Добавить транскрипцию к видео если она отсутствует</li>
</ul>

<h4 id="текстовые-курсы">Текстовые курсы</h4>

<p>Основная проблема — это стилистика и опечатки. На сайте действует механизм отправки сообщений по выбранному куску текста. Комбинация <kbd>ctrl + enter</kbd> показывает окошко, через которое можно сообщить о проблеме, или предложить другой вариант текста.</p>

<p>Если вы хотите погрузиться глубже, то мы можем дать прямой доступ к репозиториям с теорией. Периодически такое происходит. Нам даже пришлось создать специальный канал #public-content в рабочем чате команды Хекслета, куда мы приглашаем наиболее активных ребят, помогающих с текстами.</p>

<p>Задачи:</p>

<ul>
  <li>Исправление опечаток в текстах</li>
  <li>Улучшение описаний и примеров</li>
  <li>Исправление стилистики</li>
</ul>

<h3 id="вопросыответы">Вопросы/Ответы</h3>

<p>Одна из фишек Хекслета — гарантированный менторинг от нашей команды. В этом смысле мы похожи на stackoverflow. Главное отличие в том, что на Хекслете мы не даем прямых ответов, а подводим человека к нему через правильные вопросы и подсказки. Каждый день нам задают десятки вопросов и большая их часть доступна публично.</p>

<p>Периодически на вопросы отвечают другие пользователи, которые в этот момент проходят те же курсы. Для ответов на них не нужно проходить курсы или иметь подписку. На общей странице комьюнити выводятся вообще все вопросы, которые задают к курсам.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://ru.hexlet.io/my/topics">Общий список вопросов в комьюнити</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Помогать другим пользователям.</li>
</ul>

<h3 id="блог">Блог</h3>

<p><a href="https://ru.hexlet.io/blog">Блог</a> — Ежемесячно блог Хекслета посещают десятки тысяч человек. Туда мы постим как переводные статьи, которые нам понравились, так и наши собственные. Иногда посты оставляют наши пользователи.</p>

<p>Любой пользователь может написать в блог. Всего есть три категории постов, которые можно добавить:</p>

<ol>
  <li>История успеха. Самая популярная рубрика. Если вы трудоустроились и Хекслет приложил к этому руку, то обязательно поделитесь своей историей. За нее дается пожизненная 50 процентная скидка на подписку. Пример — <a href="https://ru.hexlet.io/blog/posts/vokrug-da-okolo-ili-priznanie-samomu-sebe">Вокруг да около или признание самому себе</a></li>
  <li>Процесс обучения. Ваши мысли, открытие, сложности с которыми столкнулись. В сообществе есть запрос на такие посты. Все хотят знать, что они не одни и не только им сложно. Пример — <a href="https://ru.hexlet.io/blog/posts/professions-php-greybutton">Миниобзор прохождения профессии php-программист</a></li>
  <li>Полезные статьи на любую тематику, имеющую отношение к нашей аудитории. Пример — <a href="https://ru.hexlet.io/blog/posts/developers-business-value">Классификация программистов по их ценности для бизнеса</a></li>
</ol>

<p>По последнему пункту можно придумать целые рубрики. Одна из них - обзор прочитанных книг.
Примеры интересных тематик:</p>

<ul>
  <li>Программирование.</li>
  <li>Администрирование.</li>
  <li>Бизнес-процессы.</li>
  <li>Информатика.</li>
  <li>HR-тематика.</li>
  <li>Продуктовая разработка.</li>
  <li>Изучение иностранных языков.</li>
  <li>Эмиграция и иммиграция.</li>
</ul>

<p>Список тематик не исчерпывающий.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://ru.hexlet.io/my/blog_posts/myself">Написать в блог</a></li>
</ul>

<p>Задача</p>

<ul>
  <li>Писать в блог)</li>
</ul>

<h3 id="испытания">Испытания</h3>

<p>После каждого курса, наших студентов ожидают испытания — задачи повышенной сложности без возможности подсмотреть решение. Их прохождение не обязательно, но очень желательно.</p>

<p>Испытаний всегда не хватает. В некоторых курсах их слишком мало или нет вообще. Время от времени мы придумываем новые, в основном когда видим интересные идеи где-то в сети. Иногда наши пользователи сами предлагают испытания, и мы их добавляем.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://ru.hexlet.io/challenges">Список всех испытаний</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Добавить испытания в курсы, где их мало или совсем нет.</li>
</ul>

<h3 id="отзывы">Отзывы</h3>

<p>Вы прошли курсы или проекты и вам есть чем поделиться? Напишите на support@hexlet.io свой отзыв, и мы его обязательно добавим на страницу <a href="https://ru.hexlet.io/testimonials">отзывов</a></p>

<h2 id="youtube">Youtube</h2>

<h3 id="вебинары">Вебинары</h3>

<p>За годы существования на Хекслете вышли десятки вебинаров на разные темы. Этот формат всегда был и остается популярным. Последнее время мы начинаем экспериментировать, приглашать людей, не связанных напрямую с программированием, либо приглашать тех, кто может и хочет провести вебинар самостоятельно.</p>

<p>Если вы хотите поделиться какой-то темой с нашей аудиторией, то обязательно пишите, дадим эфир. Если вы готовы вести вебинар в роли ведущего и общаться с другими гостями, то тоже велкам.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=8wurHiUJwUA">Интервью с Романом Павлушко: техническая сторона проекта</a></li>
  <li><a href="https://www.youtube.com/watch?v=jI-cZRFpbkk">В IT возраст важен ? Нужно ли читать книги? Что делать студентам? Интервью с А. Бындю</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Проводить вебинары по интересным темам</li>
  <li>Вести вебинары, в которых есть гость</li>
</ul>

<h3 id="публичные-интервью">Публичные интервью</h3>

<p>В 2016 году мы попробовали новый формат — публичные интервью. Тема зацепила многих. Интервью много обсуждают, и они собирают больше просмотров, чем вебинары. Интервью дают общее представление о том, как это происходит в реальности и помогают выявить слабые стороны.
Главная сложность в проведении таких интервью — найти людей, которые будут их проводить.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=QirXa-T8C2k">Публичное собеседование #3: Данияр Супиев</a></li>
  <li><a href="https://www.youtube.com/watch?v=HM42MlWbhFI">Публичное собеседование: Демид Каширин, JS Backend</a></li>
</ul>

<p>Задачи:</p>

<ul>
  <li>Проводить интервью</li>
</ul>

<h3 id="how-to">How-To</h3>

<p>Короткие видео на 5-15 минут, объясняющие простым языком выбранную тему. Могут быть записаны в формате скринкаста.</p>

<p>Прямо сейчас на канале сформирован плейлист из нескольких таких видео:</p>

<ul>
  <li><a href="https://www.youtube.com/playlist?list=PLo6puixMwuSOnsZFbZRg0i2SmoJediaCA">Плейлист видеогайдов</a></li>
</ul>

<p>Видеогайды очень востребованы и собирают большое количество просмотров. Ролик про SSH один из самых популярных на канале с почти 60 тысячами просмотров.</p>

<p>Задачи:</p>

<ul>
  <li>Создание новых How-To видео</li>
</ul>

<h2 id="чат-сообщества">Чат сообщества</h2>

<p>В <a href="https://slack-ru.hexlet.io/">чате</a> можно проводить слаконары на актуальные для участников темы. <a href="https://github.com/Hexlet/hexlet-slack-archive/wiki/%5B2019-08-05%5D-Слаконар-с-HR-экспертом.-Разбираем-резюме-студентов-Hexlet">Пример слаконара</a>.</p>

<h2 id="свой-город">Свой город</h2>

<p>У нас давно есть мечта, проводить регулярные оффлайновые встречи комьюнити. Сейчас они в основном происходят в Москве или Питере. Там уже сформировалась своя тусовка. На последние московские встречи приходило так много людей, что мы перестали помещаться в барах и начали организовываться в офисах компаний.</p>

<p>Пришла пора расширить географию. Если вы хотите встретиться с такими же увлеченными людьми как вы, то теперь это возможно. Напишите нам, и мы вместе организуем митап в вашем городе. С нас пиар поддержка, помощь в поиске места и общая координация.</p>

<p>Ссылки:</p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=JhLahHbh-dE">Вебинар про комьюнити</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/how-to-create-a-resume/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как составить резюме начинающему программисту без опыта работы</turbo:topic> -->
            <title>Как составить резюме начинающему программисту без опыта работы</title>
            <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/how-to-create-a-resume/">Как составить резюме начинающему программисту без опыта работы</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/how-to-create-a-resume/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Составление резюме для начинающего программиста — процесс не менее сложный, чем обучение программированию. О чем писать, если писать не о чем? Нужно ли указывать нерелевантный опыт? Что писать о себе? Когда стоит писать резюме? Можно ли приукрашивать?</p>

<p>В этом гайде обобщается опыт Хекслета и даются ответы на основные вопросы, которые задают наши пользователи.</p>

<p><em>Дисклеймер: Разные люди по-разному смотрят на резюме и хотят увидеть там разные вещи. К сожалению, не существует единственной универсальной схемы составления резюме, которое понравится всем. Поэтому не забывайте, что описанное ниже — это версия Хекслета.</em></p>

<p>Перед тем как мы начнем, запомните: поиск работы не ограничивается созданием резюме. Пассивный поиск работает для опытных разработчиков. Всем остальным нужно проявлять максимальную активность, находить вакансии, созваниваться, отправлять резюме и просить тестовые задания.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/employment?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Курс, помогающий новичкам эффективно составить резюме, попасть на собеседование и пройти его
</a>
</div>

<p>На начальные позиции, в первую очередь, ищут перспективных ребят. Имеющих активную жизненную позицию (ищите: “автор и жертва”), способных самостоятельно учиться и разбираться с проблемами, но не замыкающихся в себе. В идеале, получивших профильное образование. В техническом плане первично хорошее знание фундаментальных вещей (перечисляются дальше) и базовые практические навыки.</p>

<p>Чем более сильная компания вас рассматривает, тем больше ее интересует фундаментальная подготовка, и в меньшей степени прикладная. В таких компаниях используются разнообразные технологии, которые еще и меняются. Это значит, что важнее уметь быстро учиться и адаптироваться к новому, чем иметь хоть и сверхглубокие, но узкие знания.</p>

<h2 id="когда-программисту-начинать-составлять-резюме">Когда программисту начинать составлять резюме?</h2>

<p>Многие тянут до самого конца: “сначала выучусь, а потом напишу”. Не делайте так. Миру известно немало случаев, когда программистами становились совершенно неожиданно, когда казалось бы ничего не предвещало. Чем раньше ваше резюме появится в поиске, тем больше шансов, что вас заметят. Захотят с вами связаться или нет — другой вопрос. Главное, что вы даете возможность это сделать. Да и появится возможность отправить резюме, если кто-то вами заинтересуется.</p>

<h2 id="можно-ли-обманывать-и-приукрашивать">Можно ли обманывать и приукрашивать?</h2>

<p>Нет. Любой обман вскроется и закроет вам двери навсегда. Будьте честны, новичок — это нормально!</p>

<h2 id="оформление-резюме">Оформление резюме</h2>

<p>То, как и где вы оформляете резюме, может повлиять на первое впечатление.</p>

<p>Ниже список типичных ошибок:</p>

<ol>
  <li>
    <p>Резюме в формате документов Microsoft Office</p>

    <p>Среди разработчиков, очень популярны Mac и Linux. Почти наверняка у них не установлен офис. Формат doc создает как технические проблемы, так и показывает вашу неосведомленность в общих вопросах.</p>

    <p>Стандартом в обмене документов для чтения является PDF. Он специально спроектирован так, что выглядит одинаково на любой системе. Все сайты поиска работы позволяют выгрузить резюме в этом формате.</p>
  </li>
  <li>
    <p>Вставка резюме прямо в тело письма</p>

    <p>Такое резюме тяжело читать и им нельзя поделиться. Создается впечатление, что человек, его пославший, не слышал про сервисы поиска работы.</p>
  </li>
  <li>
    <p>Не иметь готового резюме под рукой</p>

    <p>Даже если вы только учитесь, возможны ситуации, когда вы поговорите с потенциальным работодателем и он попросит показать ему резюме. Получится не очень здорово, если вы скажете, что у вас его нет. Это не смертельно, но сразу становится понятно, что вы даже не пытались стартовать. Имейте готовое резюме на всякий случай.</p>
  </li>
  <li>
    <p>Ошибки и опечатки</p>

    <p>Вычитайте свое резюме на предмет ошибок. Ошибки портят впечатление.</p>
  </li>
  <li>
    <p>Согласование</p>

    <p>Не пишите резюме от первого лица. Оптимально писать от третьего лица в прошедшей форме.</p>
  </li>
</ol>

<h2 id="образование-в-резюме">Образование в резюме</h2>

<p>Указывать обязательно, даже если профессия не связана напрямую с ИТ. Наличие высшего образования, даже неоконченного, рассматривается как плюс при прочих равных. Есть шанс, что ваша специальность имеет отношение к предметной области, в рамках которой работает ваш будущий работодатель. Этот фактор может сильно выделить вас среди других новичков.</p>

<p>Если вы участвовали в олимпиадах по физике или математике, то обязательно указывайте их. Физ-мат подготовка будет хорошим плюсом.</p>

<p>Не менее важно знание английского языка, хотя бы на уровне чтения со словарем. Если ваш уровень выше, то обязательно пишите об этом. Хотим мы того или нет, большая часть контента создается на английском языке.</p>

<p>Книги тоже имеют значение, особенно на начальном этапе. Алгоритмы, операционные системы — все это добавляет плюсов в карму, говорит о вашем кругозоре.</p>

<p>На Хекслете составлен <a href="https://ru.hexlet.io/pages/recommended-books">список рекомендованных книг</a>, важных для любых разработчиков.</p>

<h2 id="дополнительное-образование">Дополнительное образование</h2>

<p>С курсами сложнее. К сожалению, большинство курсов не скажут ничего полезного вашим работодателям. Более того, сплошные курсы в графе “дополнительно” скорее оттолкнут. Со стороны работодателя создается впечатление, что человек хочет пустить пыль в глаза.</p>

<p>Оставьте в резюме только те курсы, которые действительно на вас повлияли, и вы считаете их наиболее ценными.</p>

<p>Кроме курсов, к образованию можно отнести участие в хакатонах, воркшопах и других похожих мероприятиях. Хотя они сами по себе короткие, но настолько интенсивные, что могут дать фору многим курсам. А еще они показывают вашу увлеченность.</p>

<h2 id="опыт-работы">Опыт работы</h2>

<p>Указывайте любой опыт, который хотя бы косвенно связан с ИТ: техподдержка, администрирование, верстка, инженерия.</p>

<p>Что делать, если опыт есть, но он не релевантный? Однозначно сказать нельзя. Если ваш возраст ближе к студенческому, то можно ничего не указывать, но если вы взрослый человек, то резюме без опыта работа смотрится странно. Это не значит, что нужно указывать вообще все, но какие-то последние места обязательно.</p>

<p>Более важный вопрос — что считать за опыт? Годы работы, сами по себе, значат мало. Намного важнее то, чем вы занимались, каких успехов добились. Сравните:</p>

<p>Первый вариант:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ООО "Северное сияние"
Верстальщик
11.10.2006 - 23.05.2010
Верстал сайты заказчиков
</code></pre></div></div>

<p>Второй вариант:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ООО "Северное сияние"
Верстальщик
11.10.2006 - 23.05.2010

Обязанности:

Нарезка макетов
Кроссбраузерная и адаптивная верстка (включая ie8)

Достижения:

Перевел сайт lala.ru на flexbox
Внедрил автоматическую простановку префиксов через autoprefixer
</code></pre></div></div>

<p>Достижения привлекают внимание и говорят о вас значительно больше, чем название компании и годы работы в ней.</p>

<p>Укажите любые активности, которые как-то связаны с программированием. Например, вы автоматизировали какие-то задачи на прошлом рабочем месте, или даже создали сайт для компании. Такое встречается. Идеально, если вы сможете выложить код на <a href="https://github.com">GitHub</a>.</p>

<p>Даже на позициях далеких от ИТ можно научиться полезному: объяснять просто сложные вещи, продавать (это важный навык!), управлять другими людьми.</p>

<h2 id="github">Github</h2>

<p>Отдельным пунктом идет наличие кода на гитхабе. Как показывает практика, если вы постоянно экспериментируете, реализуете какие-то проекты в рамках обучения или выполняете тестовые задания, то ваши шансы найти работу увеличиваются многократно. Код — лучшее доказательство вашей подготовки. В современном мире доходит до того, что некоторые работодатели ищут сотрудников через анализ кода на гитхабе.</p>

<p>Ваш код на гитхабе, сразу говорит о следующем:</p>

<ol>
  <li>Вы знаете про гитхаб, а это уже здорово само по себе. Скорее всего, вы ориентируетесь в том, что происходит.</li>
  <li>Вы умеете работать с git. Минус один пункт в вашем обучении.</li>
  <li>Скорее всего, ваш уровень английского достаточный для самостоятельного решения возникающих проблем.</li>
</ol>

<h3 id="что-можно-добавить-на-github">Что можно добавить на github?</h3>

<p>В книгах по программированию часто содержатся задания в конце глав. Создайте под книгу отдельный репозиторий и выкладывайте там код. Для СИКП у нас есть целая <a href="https://guides.hexlet.io/how-to-learn-sicp/">инструкция</a>.</p>

<p>На Хекслете собрана большая <a href="https://github.com/Hexlet/ru-test-assignments">подборка тестовых заданий</a> на разные позиции от множества компаний. Найдите то, что вам по душе и реализуйте.</p>

<p>По словам наших выпускников, <a href="https://ru.hexlet.io/projects">проекты Хекслета</a> очень помогают при трудоустройстве. Это тоже один из вариантов наполнить портфолио.</p>

<p>Гитхаб — это не только удобное хранилище вашего кода, но и способ влиться в разработку чужих проектов. Вливайтесь в <a href="https://ru.hexlet.io/blog/posts/participate-in-open-source">Open Source</a>.</p>

<h2 id="ключевые-навыки">Ключевые навыки</h2>

<p>То место, где происходит перечисление технологий. Относитесь к этому списку серьезно. Всё, что здесь написано, рассматривается как возможность проверить вас на знание предмета. Не указывайте слова, про которые вы слышали, примерно представляете, но никогда не работали с ними. Если вы пробовали разные языки, то так и напишите “написал пару скриптов на python”. Четко разделяйте вещи, которые вы знаете хорошо, и те, с которыми знакомы только поверхностно.</p>

<p>Разделяйте навыки на фундаментальные и прикладные. К фундаментальным относятся:</p>

<ul>
  <li>Знание операционных систем, владение Linux.</li>
  <li>Знание сетей, tcp/ip, http.</li>
  <li>Алгоритмы и структуры данных.</li>
  <li>Математическая подготовка.</li>
  <li>Базы данных. SQL.</li>
</ul>

<p>К прикладным:</p>

<ul>
  <li>Владение автоматическим тестированием. Если у вас есть этот пункт, то вы уже лучше, чем 99% новичков и многих работающих программистов.</li>
  <li>Языки и уровень их владения.</li>
  <li>Фреймворки. Особенно актуально для веб-разработки.</li>
  <li>Ключевые библиотеки. Этот пункт довольно опасен. Новички пытаются указать все, что они видели в глаза. Но так делать не надо, это подчеркивает ваш уровень. Указывайте только то, что может быть важно работодателям. Например react или jquery.</li>
</ul>

<p>В среде разработчиков популярны сервисы вопросов-ответов такие как <a href="https://ru.stackoverflow.com/">Stackoverflow</a> или <a href="https://qna.habr.com/">Хабр Q&amp;A</a>. Даже если вы только начинаете свой путь, всегда есть люди, которые знают меньше вас. Зарегистрируйтесь на этих сервисах и начните отслеживать вопросы от новичков. Даже десяток полезных ответов даст вам много плюсов в карму. Работодатели ценят такую активность.</p>

<h3 id="о-чем-не-стоит-писать-в-резюме">О чем не стоит писать в резюме?</h3>

<ul>
  <li>Не указывайте форматы данных, например, json или xml. Форматы никак не характеризуют вас, но создают ненужный шум.</li>
  <li>Не добавляйте похожие вещи, например, css2 и css3. Если вы знаете css, то укажите что-то одно.</li>
  <li>Любые базовые навыки по работе с компьютером, например, опыт работы с офисными документами. Профессиональное владение компьютером подразумевается и так.</li>
</ul>

<h2 id="о-себе">О себе</h2>

<p>Работа — это не чисто механический процесс. Даже разработчики проводят много времени общаясь и взаимодействуя. И каждому разработчику хочется работать в окружении людей, которые ему приятны. Раздел “о себе” позволяет найти точки соприкосновения, а при совпадении интересов родить симпатию.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li><a href="https://cv.hexlet.io/">Hexlet CV ⎯ публикация резюме и рекомендации от участников сообщества и профессиональных HR</a></li>
  <li><a href="https://www.forbes.com/sites/lizryan/2014/07/17/how-to-write-your-human-voiced-resume/">How To Write Your Human-Voiced Resume</a></li>
  <li><a href="https://www.youtube.com/watch?v=8wurHiUJwUA&amp;t=5s">Интервью с техническим директором Авито (вторая часть про найм)</a></li>
  <li><a href="https://www.youtube.com/watch?v=Zg9iNKaFqSY">Интервью с рекрутером. Как происходит поиск и фильтрация кандидатов?</a></li>
  <li><a href="https://www.youtube.com/watch?v=lJiWvv5Krbk">Интервью с техническим директором Григорием Добряковым: как составить резюме мечты и пройти собеседование</a> (<a href="https://w96k.com/%D0%B3%D1%80%D0%B8%D0%B3%D0%BE%D1%80%D0%B8%D0%B9-%D0%B4%D0%BE%D0%B1%D1%80%D1%8F%D0%BA%D0%BE%D0%B2-%D0%BE%D0%B1-%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B5-%D0%BD%D0%B0-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83.html">Текстовая выдержка</a>)</li>
  <li><a href="https://www.youtube.com/watch?v=M4WW8-9GwRA">Собеседования. Взгляд со стороны работодателя</a></li>
  <li><a href="https://www.youtube.com/watch?v=JERUf-xKU1o">Публичное собеседование</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/kak-pravilno-otkliknutsya-na-vakansiyu-9-sovetov-ot-hr-menedzhera-heksleta-lyudmily-semyonovoy">Как правильно откликнуться на вакансию: рекомендации HR-менеджера Хекслета Людмилы Семёновой</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/v-rezyume-ne-dolzhno-byt-chastoy-smeny-raboty-ili-o-trebovaniyah-timlida-k-razrabotchikam-intervyu-s-dmitriem-matveevym-evrone">В резюме не должно быть частой смены работы: рекомендации тимлида Evrone Дмитрия Матвеева</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/neprostye-otvety-na-prostye-voprosy-hr-eksperty-rasskazyvayut-o-trudoustroystve">HR-эксперты рассказывают о трудоустройстве</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/check-list-of-engineering-practices/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Чек-лист хороших инженерных практик в компаниях</turbo:topic> -->
            <title>Чек-лист хороших инженерных практик в компаниях</title>
            <pubDate>Fri, 12 Oct 2018 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/check-list-of-engineering-practices/">Чек-лист хороших инженерных практик в компаниях</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/check-list-of-engineering-practices/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Разработка программного обеспечения — нетривиальный процесс, который имеет тенденцию значительно усложняться с ростом количества участников. Больше людей в команде — больше коммуникаций и необходимости синхронизироваться (обмениваться знаниями о частях системы и происходящих процессах, следить за бизнесом и его требованиями). Растет цена ошибки, система перестает умещаться в голове одного разработчика, изменения в одном месте влияют на изменения в других местах.</p>

<p>В этих условиях разные команды проявляют себя по-разному. Некоторые продолжают поддерживать высокий темп разработки и регулярно выпускают новые версии. В других командах происходит сильное замедление процессов: переговоры отнимают больше времени, чем разработка, качество падает, выпуск новой версии становится стрессом и приключением. Общая скорость внедрения новых фич в таких командах может различаться во много раз и даже на порядок.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Причин такой катастрофической разницы довольно много. Вот некоторые из них:</p>

<ul>
  <li>Ошибки топ-менеджмента в бизнесе. Если бизнес делает не то, что надо, то не важно насколько эффективно он делает это — в конце концов бизнес закроется. Эта тема выходит за рамки текущего гайда.</li>
  <li>Ошибки топ-менеджмента в области процессов. Если на этом уровне все плохо, то все остальное вторично. Даже неверная система бонусов может привести к разладу в команде и полной блокировке разработки в конечном счете.</li>
  <li>Человеческий фактор. Личные качества и человеческие пороки могут создать проблемы как остальным членам команды, так и всему проекту в целом. Главная проблема в том, что эту часть невозможно выправить никакими процессами. Только изменение поведения. Либо расставание.</li>
  <li>Плохой процесс разработки. Эта тема касается всех инженеров без исключения. Сюда входит все, начиная от взаимодействия и работы с задачами, заканчивая тестированием и проведением ревью кода.</li>
</ul>

<p>На некоторые проблемы повлиять либо сложно, либо невозможно (с уровня разработчика). Но другие, особенно относящиеся к инженерным практикам, нужно постоянно улучшать и менять. Программисты должны принимать в этом самое активное участие.</p>

<ul>
  <li><a href="https://ru.hexlet.io/pages/recommended-books">Книги</a>
    <ul>
      <li>Человеческий фактор. Успешные проекты и команды</li>
      <li>Мифический человеко-месяц, или Как создаются программные системы</li>
      <li>Идеальный программист. Как стать профессионалом разработки ПО</li>
      <li>Цель. Процесс непрерывного совершенствования</li>
    </ul>
  </li>
  <li><a href="https://bit.ly/2NSBRLp">Manifesto for Agile Software Development</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Bus_factor">Bus Factor</a></li>
  <li><a href="https://ru.wikipedia.org/wiki/Карго-культ">Карго культ</a></li>
</ul>

<p>И хотя практик довольно много, в конечном итоге все сводится к тому, как быстро клиенты получают результат вашей работы и насколько они им удовлетворены. Ниже приводится чек-лист, который позволяет понять, используются ли в команде те инженерные практики, которые считаются наиболее удачными.</p>

<p><em>Соответствие этим практикам не гарантирует того, что в компании нет проблем. Возможно это культ-карго, либо процессы формализованы настолько, что больше мешают, чем помогают. С другой стороны из каждого правила есть исключения и всегда найдется проект, где что-то из списка ниже не применимо. Ну и наконец, некоторые из указанных подходов могут идти вразрез с чьими-то ценностями.</em></p>

<h2 id="код">Код</h2>

<p><strong>Хорошо</strong></p>

<ul>
  <li><a href="https://ru.wikipedia.org/wiki/VCS">VCS</a>. Код находится под контролем версий (как правило гит).</li>
  <li><a href="https://ru.wikipedia.org/wiki/Экстремальное_программирование#Коллективное_владение">Общий код</a>. Любой член команды в любой момент времени может изменить любую часть системы.</li>
  <li><a href="https://ru.wikipedia.org/wiki/Экстремальное_программирование#Стандарты_оформления_кода">Единый стиль кода</a>. В команде все придерживаются стандартов кодирования, принятых для данного стека (языка, платформы).</li>
</ul>

<p><strong>Плохо</strong></p>

<ul>
  <li>Отсутствие единого стиля. Каждый пишет код в том стиле, к которому он привык. Нет общих стандартов либо есть, но свой, совершенно отдельный от общепринятого.</li>
  <li>Не используется контроль версий. Вместо этого используются бекапы кода, а разработчикам приходится договариваться, чтобы не перетереть изменения друг друга.</li>
  <li>Код имеет “владельца”. Программисты защищают свой участок кода от посягательства других участников.</li>
</ul>

<p><strong>Ссылки</strong></p>

<ul>
  <li><a href="https://trunkbaseddevelopment.com/">Trunk Based Development</a></li>
</ul>

<h2 id="среда-разработки">Среда разработки</h2>

<p><strong>Хорошо</strong></p>

<ul>
  <li>Девелопмент среда. Разработка ведется в специальной development (dev) среде. Как правило, это локальная машина (возможно, с использованием Vagrant или Docker Compose). Эта среда у каждого разработчика полностью своя, и изменения в одной среде не могут влиять на другие среды разработки.</li>
  <li>Разворачивание среды автоматизировано и происходит “одной кнопкой”. Это позволяет легко вводить в проект новичков, быстро и в автоматическом режиме распространять инфраструктурные изменения, работать без страха что-либо поломать, так как легко восстановить.</li>
  <li>Инфраструктура как код. Распространение изменений конфигурации происходит через код проекта. Достаточно еще раз выполнить развертывание дев среды (с новым кодом проекта), как подхватятся все обновления.</li>
  <li>Среда разработки максимально приближена к условиям продакшена. Если сервис работает на Linux, то и разработка ведется на Linux. То же самое касается и других аспектов.</li>
</ul>

<p><strong>Плохо</strong></p>

<ul>
  <li>Разворачивание среды и настройка происходит по мануалам, либо методом “попробовал запустить — прочитал сообщение об ошибке — погуглил — исправил”. Дорого и неэффективно. Мануалы устаревают практически сразу после того, как их пишут. Новый человек может тратить дни на разворачивание среды с нуля.</li>
  <li>Ручное обновление конфигурации. Всем разработчикам рассылается директива произвести локальные изменения настройки среды (например, доставить что-нибудь новое) для работы нового кода.</li>
  <li>Общая база данных для всех разработчиков. Нагрузка от одного человека влияет на всех. Случайная поломка также тормозит всех остальных.</li>
</ul>

<h2 id="качество">Качество</h2>

<p><strong>Хорошо</strong></p>

<ul>
  <li>Кодовая база покрыта тестами. Тесты повышают уверенность в работоспособности кода. Хорошие тесты положительно влияют на дизайн самого кода. Как правило, код, покрытый тестами, сам по себе лучше кода без тестов. Хотя есть корреляция.</li>
  <li>Частично протестированная фича или вовсе — фича без тестов — не считается выполненной. Наличие тестов значительно снижает нагрузку на всех остальных членов команды и положительно влияет на качество решения задачи. К тому же часто происходит, что если тесты не написать сразу, то потом на них времени не останется.</li>
  <li>Программист отвечает за фичу до самого конца. Фича считается выполненной, только когда она работает на продакшене. Каждый человек в команде должен понимать, что наиважнейшая цель — это доставка ценности клиенту. Пока фичей никто не пользуется, то не важно, написана она или нет, потому что бизнес в этот момент остается в пролете.</li>
  <li>Команда ревьювит код друг друга (без фанатизма). Ревью — не только способ найти ошибки, но и способ учиться друг у друга.</li>
  <li><a href="https://ru.wikipedia.org/wiki/Парное_программирование">Парное программирование</a>. Техника эффективна не только между программистами. Она очень полезна в парах “программист и тестировщик”, “новичок и опытный”.</li>
  <li><a href="https://ru.wikipedia.org/wiki/Непрерывная_интеграция">Continuous integration (CI)</a>. Репозитории проекта подключены к серверу непрерывной интеграции, на котором после каждого коммита проверяется стиль кодирования (через запуск линтеров), прогоняются тесты, осуществляется сборка проекта (например, компиляция).</li>
  <li>В случае инцидентов проводятся <a href="https://www.pagerduty.com/resources/learn/post-mortem-incident-report/">пост мортемы</a>.</li>
  <li><a href="https://ru.wikipedia.org/wiki/Ретроспектива_в_программировании">Ретроспектива</a>. Процесс непрерывно улучшается и на изменения влияет каждый член команды.</li>
</ul>

<p><strong>Плохо</strong></p>

<ul>
  <li>Нет тестов. Работа нового кода проверяется только ручным способом, через прокликивание. Последствия катастрофические — скорость доставки низкая, а качество кода, скорее всего, неудовлетворительное.</li>
  <li>Отсутствует код ревью. Разный стиль кодирования, изоляция программистов друг от друга, слабый обмен опытом, плохие решения в продакшене.</li>
  <li>Программист считает, что фича закрыта, когда код попал в основную ветку. Новый код лежит мертвым грузом и не приносит пользы. Может устареть до попадания клиенту.</li>
  <li><a href="https://ru.wikipedia.org/wiki/Ключевые_показатели_эффективности">KPI</a>. Активно используются количественные метрики: строки кода, выпущенные фичи, закрытые баги. Вместо ориентации на результат, разработчики стремятся выполнить KPI. Даже в случае, если это идет вразрез с задачами бизнеса.</li>
  <li>Высокий уровень формализации процессов. Замедляется скорость, падает мотивация.</li>
</ul>

<p><strong>Ссылки</strong></p>

<ul>
  <li><a href="https://ru.wikipedia.org/wiki/Экстремальное_программирование">Экстремальное программирование</a></li>
  <li><a href="https://www.youtube.com/watch?v=Vu5ujdZDS6E">Парное программирование (доклад Николая Рыжикова)</a></li>
  <li><a href="https://www.youtube.com/watch?v=mOfiWrTW9dA">Как распространять инженерную культуру в своей компании</a></li>
</ul>

<h2 id="процесс-разработки">Процесс разработки</h2>

<p><strong>Хорошо</strong></p>

<ul>
  <li>Разработчики руководствуются принципами <a href="https://habr.com/post/258739/">12factors</a>. Приложения проще разворачивать, масштабировать и мониторить.</li>
  <li>Запуск одного теста выполняется за доли секунды. Разработка через тесты подразумевает очень частый запуск тестов в процессе отладки. В такой ситуации крайне важна скорость старта конкретного теста — она должна быть настолько быстрой, чтобы разработчик оставался в контексте.</li>
  <li>Тесты писать легко и приятно. Лакмусовая бумажка для определения того, насколько хорошо с тестами в проекте. Если приходится себя заставлять, то есть вероятность, что тесты написаны плохо (например, много моков) и их будет недостаточно.</li>
  <li>
    <p><a href="https://ru.wikipedia.org/wiki/TDD">Test-driven development (TDD)</a>. По возможности тесты пишутся до кода. Есть несколько причин, по которым это важно:</p>

    <p>Тесты заставляют думать не о реализации, а о том, как тестируемый код будет использоваться. Благодаря такому подходу, программисты видят изъяны в интерфейсах на самых ранних стадиях.</p>

    <p>Код в любом случае надо проверять. Если теста не будет, то это придется делать руками.</p>
  </li>
  <li>Перед починкой бага сначала пишется тест, который его воспроизводит, затем происходит исправление. Только в этом случае тесты действительно помогают.</li>
</ul>

<p><strong>Плохо</strong></p>

<ul>
  <li>Тесты есть, но приходится заставлять себя писать тесты, потому что их сложно писать, они долго выполняются, часто ломаются или постоянно приходится их переписывать.</li>
  <li>Запуск одного теста занимает секунды. Такой тест тяжело запускать при разработке через тесты и общее время выполнения тестов становится слишком большим.</li>
  <li>Код правится прямо на продакшене (то место где он работает). Без комментариев.</li>
</ul>

<p><strong>Ссылки</strong></p>

<ul>
  <li><a href="https://12factor.net/ru/">12factors</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/how-to-test-code">Начинаем писать тесты (правильно)</a></li>
  <li><a href="https://www.youtube.com/watch?v=zsz8kdi62mE">Бережливое тестирование</a></li>
</ul>

<h2 id="выкатка-новых-версий-более-актуально-для-веб-проектов">Выкатка новых версий (более актуально для веб-проектов)</h2>

<p>Продакшен-среда — инфраструктура (например, сервера), в которой развернут проект. Она обеспечивает доступ к проекту конечным пользователям.</p>

<p>Деплой (выкатка) — процесс, в рамках которого происходит обновление проекта в продакшен среде.</p>

<p><strong>Хорошо</strong></p>

<ul>
  <li>Автоматизация. Развертывание автоматизировано и выполняется одной кнопкой.</li>
  <li>Частые небольшие релизы. Развертывание — рядовое событие, которое может выполняться в любой момент по готовности фич, без необходимости отвлекать команду.</li>
  <li>Zero Downtime Deploy. Обновление версии происходит прозрачно для пользователей.</li>
  <li>Развертывание, технически (то есть все хорошо автоматизировано), может выполнить любой член команды.</li>
</ul>

<p><strong>Плохо</strong></p>

<ul>
  <li>Выкладка происходит в ручном режиме. Например, через прямое управление с сервера. Самый ненадежный и не масштабируемый подход, подвержен ошибкам и может занимать значительное время. При наличии нескольких серверов просто не работает.</li>
  <li>Выкладка кода сопровождается эмоциональным напряжением и вовлечением большого числа участников. В такой атмосфере все стремятся выкатываться реже, что приводит к еще большим проблемам и напрямую вредит бизнесу.</li>
  <li>Процесс развертывания длится десятки минут или часы. Скорее всего, это означает, что процесс сборки проекта интегрирован с самим деплоем. Эти задачи нужно выполнять независимо.</li>
  <li>Разворачивание происходит раз в неделю и реже. Чем больше изменений выкатывается сразу, тем выше шанс поломки. И тем сложнее отследить влияние каждой фичи на бизнес-показатели. Кроме того, происходит забывание тех изменений, которые были сделаны ранее и ждали своего часа до выхода в продакшен.</li>
  <li>Во время разворачивания наблюдаются длительные даунтаймы. Пользователи вынуждены ожидать завершения деплоя. Такая ситуация мешает деплоить часто.</li>
  <li>Развертывание выполняет один специальный человек. Знания хранятся в одной голове. Уход в отпуск или болезнь ломает весь процесс. Остальные программисты не понимают “как оно работает там”.</li>
  <li>Деплой конфигурации. Обновление конфигурации, не относящейся непосредственно к логике кода, требует повторного деплоя. Например, изменение пароля к базе данных или адреса базы. Эти параметры являются чисто инфраструктурными и должны попадать в код так, как описано в 12factors.</li>
</ul>

<p><strong>Ссылки</strong></p>

<ul>
  <li><a href="https://ru.atlassian.com/devops">Что такое DevOps?</a></li>
  <li><a href="https://bronevichok.ru/blog/2015/04/26/engineering-at-booking.com.html">Инжиниринг в букинге</a></li>
  <li><a href="https://ru.hexlet.io/blog/posts/environment">Среды разработки. Мужики, выкатывай!</a></li>
  <li><a href="https://www.youtube.com/watch?v=mOfiWrTW9dA">Вебинар: Как распространять инженерную культуру в своей компании?</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/how-to-learn-sicp/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как изучать Структуру и Интерпретацию Компьютерных Программ (SICP)</turbo:topic> -->
            <title>Как изучать Структуру и Интерпретацию Компьютерных Программ (SICP)</title>
            <pubDate>Fri, 16 Mar 2018 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/how-to-learn-sicp/">Как изучать Структуру и Интерпретацию Компьютерных Программ (SICP)</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/how-to-learn-sicp/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>СИКП — одноименная книга и легендарный учебный курс в MIT (Массачусетский технологический институт).</strong></p>

<p>СИКП — не книга про языки программирования или разработку программного обеспечения, не книга по ООП, функциональному программированию или паттернам проектирования.</p>

<p>СИКП — книга об информатике (computer science). Восприятии компьютеров как абстрактных машин, используемых для манипулирования данными. Несмотря на то, что книга впервые опубликована в 1979, она до сих пор не потеряла свою актуальность и не потеряет в будущем. СИКП неизменно находится в топе лучших книг по обучению программированию на протяжении десятков лет.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.code-basics.com/languages/racket?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Бесплатный курс «Racket как второй язык»
</a>
</div>

<blockquote>
  <p>This is one of the great classics of computer science. I bought my first copy 15 years ago, and I still don’t feel I have learned everything the book has to teach. <em>— Paul Graham</em>.</p>
</blockquote>

<p>Стоит ли её читать? Однозначно стоит всем разработчикам на любых языках программирования с любым опытом. СИКП — достаточно сложная книга, поэтому появилось руководство, которое вы прямо сейчас читаете.</p>

<h2 id="очень-краткое-содержание">Очень краткое содержание</h2>

<h3 id="абстракция-с-помощью-функций">Абстракция с помощью функций</h3>

<ol>
  <li>Элементы программ
    <ul>
      <li>Выражения</li>
      <li>Вычислительные стратегии</li>
      <li>Подстановочная модель вычислений</li>
    </ul>
  </li>
  <li>Функции и процессы порождаемые ими
    <ul>
      <li>Линейная рекурсия и итерация</li>
      <li>Древовидная рекурсия</li>
    </ul>
  </li>
  <li>Функции высшего порядка
    <ul>
      <li>Функции как аргументы</li>
      <li>Функции как обобщения</li>
      <li>Функции как возвращаемые значения</li>
    </ul>
  </li>
</ol>

<h3 id="абстракция-с-помощью-данных">Абстракция с помощью данных</h3>

<ol>
  <li>Введение в абстракцию данных
    <ul>
      <li>Барьеры абстракции</li>
      <li>Что такое данные?</li>
    </ul>
  </li>
  <li>Иерархические данные и свойство замыкания
    <ul>
      <li>Представление последовательностей</li>
      <li>Иерархические структуры</li>
      <li>Последовательности как стандартные интерфейсы</li>
    </ul>
  </li>
  <li>Символьные данные
    <ul>
      <li>Цитирование</li>
    </ul>
  </li>
  <li>Множественные представления абстрактных данных
    <ul>
      <li>Тегирование данных</li>
      <li>Программирование управляемое данными. Аддитивность.</li>
    </ul>
  </li>
</ol>

<h3 id="модульность-объекты-и-состояние">Модульность, Объекты и Состояние</h3>

<ol>
  <li>Присваивание и локальное состояние
    <ul>
      <li>Преимущества присваивания</li>
      <li>Недостатки присваивания</li>
    </ul>
  </li>
  <li>Модель с окружениями
    <ul>
      <li>Правила вычисления</li>
      <li>Применение</li>
      <li>Фреймы как репозитории локального состояния</li>
    </ul>
  </li>
  <li>Моделирование с изменяемыми данными
    <ul>
      <li>Изменяемый список</li>
      <li>Представление очереди</li>
      <li>Представление таблиц</li>
    </ul>
  </li>
  <li>Многозадачность</li>
  <li>Потоки</li>
</ol>

<h3 id="метаязыковые-абстракции">Метаязыковые абстракции</h3>

<p>…</p>

<h3 id="вычисление-с-помощью-регистровых-машин">Вычисление с помощью регистровых машин</h3>

<p>…</p>

<hr />

<h2 id="рекомендации">Рекомендации</h2>

<p>Первое, что нужно понимать: СИКП — не просто книга. Это университетский курс, записанный в виде книги. Он сложный и объёмный, его бесполезно проходить без практики. Практику придумывать не придётся. После каждой главы есть блок задач, которые авторы просят выполнить. Некоторые из них сугубо математические (просят что-то доказать), либо подразумевают хорошую математическую базу. Их можно и даже нужно пропускать, иначе вы можете очень быстро потерять мотивацию.</p>

<h3 id="сколько-читать">Сколько читать</h3>

<p>СИКП условно можно разделить на две части. В первую часть входят главы 1, 2 и 3. Во вторую — 4 и 5. Разница в том, что во вторую часть входят главы, копающие очень глубоко, и пройти сквозь них может только по-настоящему увлеченный человек. По этой причине Хекслет рекомендует поставить себе планкой прохождение первых трех глав. Остальное можно с легкостью отложить на потом.</p>

<h3 id="язык">Язык</h3>

<p>Для примеров и практики в книге используется язык Scheme (Ским), созданный авторами курса. Это один из диалектов семейства Lisp. Как и полагается любому Lisp-языку, Scheme имеет примитивный синтаксис, который можно изучить буквально за несколько часов. Он очень необычен для тех, кто имел дело только с широко распространенными языками, но обладает рядом серьезных достоинств, о которых говорится в книге.</p>

<p>Его выбор, в качестве основного языка для курса обоснован тем, что Scheme позволяет сосредоточиться на сути вещей вместо синтаксиса, увидеть чистые концепции в первозданном виде. Scheme как и любой Лисп, обладает невероятно высокой выразительностью благодаря тому, что в языке всё есть выражение, а инструкции отсутствуют вообще.</p>

<p>Вторая причина — гомоиконность. Свойство языков, в которых данные и код — одно и тоже. Этот тезис сложно понять на словах, его нужно прочувствовать на практике. Есть еще и третья причина — макросы, но они в книге не используются.</p>

<p>Сам язык Scheme, это в первую очередь стандарт языка плюс разные реализации этого стандарта. На данный момент один из самых развитых – и продолжающих развиваться – потомков Scheme, это язык <a href="https://racket-lang.org/">Racket</a>. Хекслет рекомендует проходить СИКП именно на Racket. Специально для этого гайда мы подготовили <a href="https://github.com/hexlet-boilerplates/sicp-racket">репозиторий</a>, который можно использовать как основу для кода. В репозиторий стоит заглянуть хотя бы для того, чтобы узнать, как настроить Racket на совместимость именно с тем стандартом Scheme, который используется для примеров кода в книге: немногие существующие реализации Scheme позволяют воссоздать “то самое” окружение, к счастью, Racket может! Не забудьте правильно настроить редактор: Lisp языки относятся к тем языкам, для которых нужна поддержка со стороны редактора для комфортной работы.</p>

<h2 id="оформление">Оформление</h2>

<p>На Гитхабе <a href="https://github.com/search?q=sicp">можно найти</a> множество репозиториев, в которых лежат решения задач из СИКП на всех возможных языках программирования. Мы настоятельно рекомендуем поступать также: создать репозиторий в своем аккаунте и выкладывать в него все свои решения. Идеально, если каждое решение будет сопровождаться <a href="https://docs.racket-lang.org/rackunit/">тестами</a>. Такой подход хорош не только тем, что вы дополнительно прокачиваетесь в git и получаете дополнительную мотивацию, но и тем, что у вас появляется код, который можно показать при поиске работы. Более того, велика вероятность, что собеседовать вас будет человек, знающий про СИКП. Это добавит очков в карму и даст возможность продуктивно пообщаться.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li>
    <p><a href="https://www.youtube.com/watch?v=bFMbqKRjU84&amp;list=PLo6puixMwuSO8eB2uBH5lZy5kjNtdhTfT">Курс: Структура и интерпретация компьютерных программ (SICP по-русски)</a></p>
  </li>
  <li>
    <p><a href="https://sicp.hexlet.io/">Сервис для отслеживания прогресса изучения книги</a></p>
  </li>
  <li>
    <p><a href="https://www.youtube.com/playlist?list=PLc6AqfeLgwzPPK1H3XV1Wfb_CGvT6sXkC">Лекции от авторов курса переведенные на русский язык</a></p>
  </li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/docker/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как и для чего использовать Docker</turbo:topic> -->
            <title>Как и для чего использовать Docker</title>
            <pubDate>Tue, 30 Jan 2018 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/docker/">Как и для чего использовать Docker</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/docker/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>Docker — программа, позволяющая операционной системе запускать процессы в изолированном окружении на базе специально созданных образов. Несмотря на то, что технологии, лежащие в основе Докера появились до него, именно Докер произвел революцию в том, как сегодня создается инфраструктура проектов, собираются и запускаются сервисы.</strong></p>

<p><em>(В статье намеренно опущены многие детали, чтобы не грузить информацией, которая не нужна для ознакомления).</em></p>

<h2 id="установка">Установка</h2>

<p>Чтобы начать пользоваться Докером, необходимо установить движок — Docker Engine. На странице https://docs.docker.com/engine/install/ доступны ссылки для скачивания под все популярные платформы. Выберите вашу и установите Докер.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>В работе Докера есть одна деталь, которую важно знать при установке на Mac и Linux. По умолчанию Докер работает через unix сокет. В целях безопасности сокет закрыт для пользователей, не входящих в группу <em>docker</em>. И хотя установщик добавляет текущего пользователя в эту группу автоматически, Докер сразу не заработает. Дело в том, что если пользователь меняет группу сам себе, то ничего не изменится до тех пор, пока пользователь не перелогинится. Такова особенность работы ядра. Для проверки того, в какие группы входит ваш пользователь, можно набрать команду <code class="language-plaintext highlighter-rouge">id</code>.</p>

<p>Проверить успешность установки можно командой <code class="language-plaintext highlighter-rouge">docker info</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker info
Containers: 22
 Running: 2
 Paused: 0
 Stopped: 20
Images: 72
Server Version: 17.12.0-ce
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: <span class="nb">true
 </span>Native Overlay Diff: <span class="nb">true
</span>Logging Driver: json-file
Cgroup Driver: cgroupfs
...
</code></pre></div></div>

<p>Она выдаёт довольно много информации о конфигурации самого Докера и статистику работы.</p>

<h2 id="запуск">Запуск</h2>

<p>На этом этапе команды на выполнение даются “как есть” без объяснения деталей. Подробнее о том, как их формировать и
что в них входит разбирается позже.</p>

<p>Начнем с самого простого варианта:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> nginx bash
root@a6c26812d23b:/#
</code></pre></div></div>

<p>При первом вызове данная команда начнет скачивать образ (image) <em>nginx</em>, поэтому придется немного подождать. После того, как образ скачается, запустится <em>bash</em>, и вы окажетесь <strong>внутри контейнера</strong> (container).</p>

<p>Побродите по файловой системе, посмотрите директорию <em>/etc/nginx</em>. Как видите, её содержимое не совпадает с тем, что находится у вас на компьютере. Эта файловая система появилась из образа <em>nginx</em>. Всё, что вы сделаете здесь внутри, никак не затронет вашу основную файловую систему. Вернуться в родные скрепы можно командой <code class="language-plaintext highlighter-rouge">exit</code>.</p>

<p>Теперь посмотрим вариант вызова команды <code class="language-plaintext highlighter-rouge">cat</code>, выполненной уже в другом контейнере, но тоже запущенном из образа <em>nginx</em>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run nginx <span class="nb">cat</span> /etc/nginx/nginx.conf

user  nginx<span class="p">;</span>
worker_processes  1<span class="p">;</span>

error_log  /var/log/nginx/error.log warn<span class="p">;</span>
pid        /var/run/nginx.pid<span class="p">;</span>
...
<span class="err">$</span>
</code></pre></div></div>

<p>Команда выполняется практически мгновенно, так как образ уже загружен. В отличие от предыдущего старта, где запускается баш и начинается интерактивная сессия внутри контейнера, запуск команды <code class="language-plaintext highlighter-rouge">cat /etc/nginx/nginx.conf</code> для образа <em>nginx</em> выведет на экран содержимое указанного файла (взяв его из файловой системы запущенного контейнера) и вернет управление в то место, где вы были. Вы не окажетесь внутри контейнера.</p>

<p>Последний вариант запуска будет таким:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Обратите внимание на то, что после имени образа не указана никакая команда.</span>
<span class="c"># Такой подход работает в случае если команда на запуск прописана в самом образе</span>
<span class="nv">$ </span>docker run <span class="nt">-p</span> 8080:80 nginx
</code></pre></div></div>

<p>Данная команда не возвращает управление, потому что стартует nginx. Откройте браузер и наберите <code class="language-plaintext highlighter-rouge">localhost:8080</code>. Вы увидите как загрузилась страница <em>Welcome to nginx!</em>. Если в этот момент снова посмотреть в консоль, где был запущен контейнер, то можно увидеть, что туда выводится лог запросов к <code class="language-plaintext highlighter-rouge">localhost:8080</code>. Остановить nginx можно командой <kbd>Ctrl + C</kbd>.</p>

<p>Несмотря на то, что все запуски выполнялись по-разному и приводили к разным результатам, общая схема их работы — одна. Докер при необходимости автоматически скачивает образ (первый аргумент после <code class="language-plaintext highlighter-rouge">docker run</code>) и на основе него стартует контейнер с указанной командой.</p>

<p><strong>Образ — самостоятельная файловая система</strong>. Пока мы используем готовые образы, но потом научимся создавать их самостоятельно.</p>

<p><strong>Контейнер — запущенный процесс операционной системы в изолированном окружении</strong> с подключенной файловой системой из образа.</p>

<p>Повторюсь, что контейнер — всего лишь обычный процесс вашей операционной системы. Разница лишь в том, что благодаря возможностям ядра (о них в конце) Докер стартует процесс в изолированном окружении. Контейнер видит свой собственный список процессов, свою собственную сеть, свою собственную файловую систему и так далее. Пока ему не укажут явно, он не может взаимодействовать с вашей основной операционной системой и всем, что в ней хранится или запущено.</p>

<p>Попробуйте выполнить команду <code class="language-plaintext highlighter-rouge">docker run -it ubuntu bash</code> и наберите <code class="language-plaintext highlighter-rouge">ps auxf</code> внутри запущенного контейнера. Вывод будет таким:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.1  18240  3300 pts/0    Ss   15:39   0:00 /bin/bash
root        12  0.0  0.1  34424  2808 pts/0    R+   15:40   0:00 ps aux
</code></pre></div></div>

<p>Как видно, процесса всего два, и у Bash PID равен 1. Заодно можно посмотреть в директорию <em>/home</em> командой <code class="language-plaintext highlighter-rouge">ls /home</code> и убедиться, что она пустая. Также обратите внимание, что внутри контейнера по умолчанию используется пользователь <code class="language-plaintext highlighter-rouge">root</code>.</p>

<h2 id="зачем-все-это">Зачем все это?</h2>

<p><strong>Докер — универсальный способ доставки приложений на машины (локальный компьютер или удаленные сервера) и их запуска в изолированном окружении.</strong></p>

<p>Вспомните, когда вам приходилось собирать программы из исходников. Этот процесс включает в себя следующие шаги:</p>

<ul>
  <li>Установить все необходимые зависимости под вашу операционную систему (их список еще надо найти).</li>
  <li>Скачать архив, распаковать.</li>
  <li>Запустить конфигурирование <code class="language-plaintext highlighter-rouge">make configure</code>.</li>
  <li>Запустить компиляцию <code class="language-plaintext highlighter-rouge">make compile</code>.</li>
  <li>Установить <code class="language-plaintext highlighter-rouge">make install</code>.</li>
</ul>

<p>Как видите, процесс нетривиальный и далеко не всегда быстрый. Иногда даже невыполнимый из-за непонятных ошибок. И это не говоря про загрязнение операционной системы.</p>

<p>Докер позволяет упростить эту процедуру до запуска одной команды причем с почти 100% гарантией успеха. Посмотрите на вымышленный пример, в котором происходит установка программы Tunnel на локальный компьютер в директорию <em>/usr/local/bin</em> используя образ <em>tunnel</em>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>docker run <span class="nt">-v</span> /usr/local/bin:/out tunnel
</code></pre></div></div>

<p>Запуск этой команды приводит к тому, что в основной системе в директории <em>/usr/local/bin</em> оказывается исполняемый файл программы, находящейся внутри образа <em>tunnel</em>. Команда <code class="language-plaintext highlighter-rouge">docker run</code> запускает контейнер из образа <em>tunnel</em>, внутри происходит компиляция программы и, в конечном итоге, она оказывается в директории <em>/usr/local/bin</em> основной файловой системы. Теперь можно стартовать программу, просто набрав <code class="language-plaintext highlighter-rouge">tunnel</code> в терминале.</p>

<p>А что если программа, которую мы устанавливаем таким способом, имеет зависимости? Весь фокус в том, что образ, из которого был запущен контейнер, полностью укомплектован. Внутри него установлены все необходимые зависимости, и его запуск практически гарантирует 100% работоспособность независимо от состояния основной ОС.</p>

<p>Часто даже не обязательно копировать программу из контейнера на вашу основную систему. Достаточно запускать сам контейнер, когда в этом возникнет необходимость. Предположим, что мы решили разработать статический сайт на основе Jekyll. Jekyll — популярный генератор статических сайтов, написанный на Ruby. Например, гайд который вы читаете прямо сейчас, находится на статическом сайте, сгенерированном с его помощью. И при его генерации использовался Докер (об этом можно прочитать в гайде: <a href="https://guides.hexlet.io/jekyll/">как делать блог на Jekyll</a>).</p>

<p>Старый способ использования Jekyll требовал установки на вашу основную систему как минимум Ruby и самого Jekyll в виде гема (gem — название пакетов в Ruby). Причем, как и всегда в подобных вещах, Jekyll работает только с определенными версиями Ruby, что вносит свои проблемы при настройке.</p>

<p>С Докером запуск Jekyll сводится к одной команде, выполняемой в директории с блогом (подробнее можно посмотреть в <a href="https://github.com/hexletguides/hexletguides.github.io">репозитории</a> наших гайдов):</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>docker run <span class="nt">--rm</span> <span class="nt">--volume</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PWD</span><span class="s2">:/srv/jekyll"</span> <span class="nt">-it</span> jekyll/jekyll jekyll server
</code></pre></div></div>

<p>Точно таким же образом сейчас запускается огромное количество различного софта. Чем дальше, тем больше подобный способ захватывает мир. На этом месте можно немного окунуться в происхождение названия Docker.</p>

<p><img src="/assets/images/docker/docker_logo.png" alt="docker logo" /></p>

<p>Как вы знаете, основной способ распространения товаров по миру — корабли. Раньше стоимость перевозки была довольно большая, по причине того, что каждый груз имел собственную форму и тип материала.</p>

<p><img src="/assets/images/docker/cargo.jpg" alt="loading cargo onto a ship" /></p>

<p>Загрузить на корабль мешок с рыбой или машину — разные задачи, требующие разных процессов и инструментов. Возникали проблемы со способами погрузки, требовались разнообразные краны и инструменты. А эффективно упаковать груз на самом корабле, с учетом его хрупкости — задача нетривиальная.</p>

<p>Но в какой-то момент все изменилось. Картинка стоит тысячи слов:</p>

<p><img src="/assets/images/docker/container_terminal.jpg" alt="shipping container terminal" /></p>

<p>Контейнеры уравняли все виды грузов и стандартизировали инструменты погрузки и разгрузки во всем мире. Что в свою очередь привело к упрощению процессов, ускорению и, следовательно, уменьшению стоимости перевозок.</p>

<p>То же самое произошло и в разработке ПО. Docker стал универсальным средством доставки софта независимо от его структуры, зависимостей и способа установки. Всё, что нужно программам, распространяемым через Докер, находится внутри образа и не пересекается с основной системой и другими контейнерами. Важность этого факта невозможно переоценить. Теперь обновление версий программ никак не задействует ни саму систему, ни другие программы. Сломаться больше ничего не может. Всё, что нужно сделать, это скачать новый образ той программы, которую требуется обновить. Другими словами, Докер убрал проблему <a href="https://ru.wikipedia.org/wiki/Dependency_hell">dependency hell</a> и сделал инфраструктуру <a href="https://martinfowler.com/bliki/ImmutableServer.html">immutable</a> (неизменяемой).</p>

<p>Больше всего Docker повлиял именно на серверную инфраструктуру. До эры Докера управление серверами было очень болезненным мероприятием даже несмотря на наличие программ по управлению конфигурацией (chef, puppet, ansible). Основная причина всех проблем — изменяемое состояние. Программы ставятся, обновляются, удаляются. Происходит это в разное время на разных серверах и немного по-разному. Например, обновить версию таких языков, как PHP, Ruby или Python могло стать целым приключением с потерей работоспособности. Проще поставить рядом новый сервер и переключиться на него. Идейно Докер позволяет сделать именно такое переключение. Забыть про старое и поставить новое, ведь каждый запущенный контейнер живет в своем окружении. Причем, откат в такой системе тривиален: всё что нужно — остановить новый контейнер и поднять старый, на базе предыдущего образа.</p>

<h2 id="приложение-в-контейнере">Приложение в контейнере</h2>

<p>Теперь поговорим о том, как приложение отображается на контейнеры. Возможны два подхода:</p>

<ol>
  <li>Всё приложение — один контейнер, внутри которого поднимается дерево процессов: приложение, веб сервер, база данных и всё в этом духе.</li>
  <li>Каждый запущенный контейнер — атомарный сервис. Другими словами каждый контейнер представляет из себя ровно одну программу, будь то веб-сервер или приложение.</li>
</ol>

<p>На практике все преимущества Docker достигаются только со вторым подходом. Во-первых, сервисы, как правило, разнесены по разным машинам и нередко перемещаются по ним (например, в случае выхода из строя сервера), во-вторых, обновление одного сервиса не должно приводить к остановке остальных.</p>

<p>Первый подход крайне редко, но бывает нужен. Например, Хекслет работает в двух режимах. Сам сайт с его сервисами использует вторую модель, когда каждый сервис отдельно, но вот практика, выполняемая в браузере, стартует по принципу “один пользователь — один контейнер”. Внутри контейнера может оказаться всё что угодно в зависимости от практики. Как минимум, там всегда стартует сама среда Хекслет IDE, а она в свою очередь порождает терминалы (процессы). В курсе по базам данных в этом же контейнере стартует и база данных, в курсе, связанном с вебом, стартует веб-сервер. Такой подход позволяет создать иллюзию работы на настоящей машине и резко снижает сложность в поддержке упражнений. Повторюсь, что такой вариант использования очень специфичен и вам вряд ли понадобится.</p>

<p>Другой важный аспект при работе с контейнерами касается состояния. Например, если база запускается в контейнере, то ее данные ни в коем случае не должны храниться там же, внутри контейнера. Контейнер как процесс операционной системы, может быть легко уничтожен, его наличие всегда временно. Docker содержит механизмы, для хранения и использования данных лежащих в основной файловой системе. О них будет позже.</p>

<h2 id="работа-с-образами">Работа с образами</h2>

<p>Docker — больше, чем просто программа. Это целая экосистема со множеством проектов и сервисов. Главный сервис, с которым вам придется иметь дело — Registry. Хранилище образов.</p>

<p>Концептуально оно работает так же, как и репозиторий пакетов любого пакетного менеджера. Посмотреть его содержимое можно на сайте <a href="https://hub.docker.com/">https://hub.docker.com/</a>, кликнув по ссылке Explore.</p>

<p>Когда мы выполняем команду <em>run</em> <code class="language-plaintext highlighter-rouge">docker run &lt;image name&gt;</code>, то Docker проверяет наличие указанного образа на локальной машине и скачивает его по необходимости. Список образов, уже скачанных на компьютер, можно посмотреть командой <code class="language-plaintext highlighter-rouge">docker images</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker images
REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE
workshopdevops_web                   latest              cfd7771b4b3a        2 days ago          817MB
hexletbasics_app                     latest              8e34a5f631ea        2 days ago          1.3GB
mokevnin/rails                       latest              96487c602a9b        2 days ago          743MB
ubuntu                               latest              2a4cca5ac898        3 days ago          111MB
Ruby                                 2.4                 713da53688a6        3 weeks ago         687MB
Ruby                                 2.5                 4c7885e3f2bb        3 weeks ago         881MB
nginx                                latest              3f8a4339aadd        3 weeks ago         108MB
elixir                               latest              93617745963c        4 weeks ago         889MB
postgres                             latest              ec61d13c8566        5 weeks ago         287MB
</code></pre></div></div>

<p>Разберемся с тем, как формируется имя образа, и что оно в себя включает.</p>

<p>Вторая колонка в выводе выше называется TAG. Когда мы выполняли команду <code class="language-plaintext highlighter-rouge">docker run nginx</code>, то на самом деле выполнялась команда <code class="language-plaintext highlighter-rouge">docker run nginx:latest</code>. То есть мы не просто скачиваем образ <em>nginx</em>, а скачиваем его конкретную версию. Latest — тег по умолчанию. Несложно догадаться, что он означает последнюю версию образа.</p>

<p>Важно понимать, что это всего лишь соглашение, а не правило. Конкретный образ вообще может не иметь тега <em>latest</em>, либо иметь, но он не будет содержать последние изменения, просто потому, что никто их не публикует. Впрочем, популярные образы следуют соглашению. Как понятно из контекста, теги в Докере изменяемы, другими словами, вам никто не гарантирует, что скачав образ с одним и тем же тегом на разных компьютерах в разное время вы получите одно и то же. Такой подход может показаться странным и ненадежным, ведь нет гарантий, но на практике есть определенные соглашения, которым следуют все популярные образы. Тег latest действительно всегда содержит последнюю версию и постоянно обновляется, но кроме этого тега активно используется <a href="https://semver.org/">семантическое версионирование</a>. Рассмотрим https://hub.docker.com/_/nginx</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>1.13.8, mainline, 1, 1.13, latest
1.13.8-perl, mainline-perl, 1-perl, 1.13-perl, perl
1.13.8-alpine, mainline-alpine, 1-alpine, 1.13-alpine, alpine
1.13.8-alpine-perl, mainline-alpine-perl, 1-alpine-perl, 1.13-alpine-perl, alpine-perl
1.12.2, stable, 1.12
1.12.2-perl, stable-perl, 1.12-perl
1.12.2-alpine, stable-alpine, 1.12-alpine
1.12.2-alpine-perl, stable-alpine-perl, 1.12-alpine-perl
</code></pre></div></div>

<p>Теги, в которых присутствует полная семантическая версия (x.x.x) всегда неизменяемы, даже если в них встречается что-то еще, например, <em>1.12.2-alphine</em>. Такую версию смело нужно брать для продакшен-окружения. Теги, подобные такому <em>1.12</em>, обновляются при изменении path версии. То есть внутри образа может оказаться и версия <em>1.12.2</em>, и в будущем <em>1.12.8</em>. Точно такая же схема и с версиями, в которых указана только мажорная версия, например, <em>1</em>. Только в данном случае обновление идет не только по патчу, но и по минорной версии.</p>

<p>Как вы помните, команда <code class="language-plaintext highlighter-rouge">docker run</code> скачивает образ, если его нет локально, но эта проверка не связана с обновлением содержимого. Другими словами, если <em>nginx:latest</em> обновился, то <code class="language-plaintext highlighter-rouge">docker run</code> его не будет скачивать, он использует тот <em>latest</em>, который прямо сейчас уже загружен. Для гарантированного обновления образа существует другая команда: <code class="language-plaintext highlighter-rouge">docker pull</code>. Вот она всегда проверяет, обновился ли образ для определенного тега.</p>

<p>Кроме тегов имя образа может содержать префикс: например, <code class="language-plaintext highlighter-rouge">etsy/chef</code>. Этот префикс является именем аккаунта на сайте, через который создаются образы, попадающие в Registry. Большинство образов как раз такие, с префиксом. И есть небольшой набор, буквально сотня образов, которые не имеют префикса. Их особенность в том, что эти образы поддерживает сам Docker. Поэтому если вы видите, что в имени образа нет префикса, значит это официальный образ. Список таких образов можно увидеть здесь: https://github.com/docker-library/official-images/tree/master/library</p>

<p>Удаляются образы командой <code class="language-plaintext highlighter-rouge">docker rmi &lt;imagename&gt;</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker rmi Ruby:2.4
Untagged: Ruby:2.4
Untagged: Ruby@sha256:d973c59b89f3c5c9bb330e3350ef8c529753ba9004dcd1bfbcaa4e9c0acb0c82
</code></pre></div></div>

<p>Если в Докере присутствует хоть один контейнер из удаляемого образа, то Докер не даст его удалить по понятным причинам. Если вы всё же хотите удалить и образ, и все контейнеры, связанные с ним, используйте флаг <code class="language-plaintext highlighter-rouge">-f</code>.</p>

<h2 id="управление-контейнерами">Управление контейнерами</h2>

<p><img src="/assets/images/docker/docker-container-lifecycle.png" alt="Docker Container LifeCycle" /></p>

<p>Картинка описывает жизненный цикл (конечный автомат) контейнера. Кружками на нём изображены состояния, жирным выделены консольные команды, а квадратиками показывается то, что в реальности выполняется.</p>

<p>Проследите путь команды <code class="language-plaintext highlighter-rouge">docker run</code>. Несмотря на то, что команда одна, с точки зрения работы Докера выполняется два действия: создание контейнера и запуск. Существуют и более сложные варианты исполнения, но в этом разделе мы рассмотрим только базовые команды.</p>

<p>Запустим nginx так, чтобы он работал в фоне. Для этого после слова <em>run</em> добавляется флаг <code class="language-plaintext highlighter-rouge">-d</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 8080:80 nginx
431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e
</code></pre></div></div>

<p>После выполнения команды Докер выводит идентификатор контейнера и возвращает управление. Убедитесь в том, что nginx работает, открыв в браузере ссылку <code class="language-plaintext highlighter-rouge">localhost:8080</code>. В отличие от предыдущего запуска, наш nginx работает в фоне, а значит не видно его вывода (логов). Посмотреть его можно командой <code class="language-plaintext highlighter-rouge">docker logs</code>, которой нужно передать идентификатор контейнера:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker logs 431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e

172.17.0.1 - - <span class="o">[</span>19/Jan/2018:07:38:55 +0000] <span class="s2">"GET / HTTP/1.1"</span> 200 612 <span class="s2">"-"</span> <span class="s2">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36"</span> <span class="s2">"-"</span>
</code></pre></div></div>

<p>Вы также можете подсоединиться к выводу лога в стиле <code class="language-plaintext highlighter-rouge">tail -f</code>. Для этого запустите <code class="language-plaintext highlighter-rouge">docker logs -f 431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e</code>. Теперь лог будет обновляться каждый раз, когда вы обновляете страницу в браузере. Выйти из этого режима можно набрав <kbd>Ctrl + C</kbd>, при этом сам контейнер остановлен не будет.</p>

<p>Теперь выведем информацию о запущенных контейнерах командой <code class="language-plaintext highlighter-rouge">docker ps</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS              PORTS                                          NAMES
431a3b3fc24b        nginx                            <span class="s2">"nginx -g 'daemon of…"</span>   2 minutes ago       Up 2 minutes        80/tcp                                         wizardly_rosalind
</code></pre></div></div>

<p>Расшифровка столбиков:</p>

<ul>
  <li>CONTAINER_ID — идентификатор контейнера. Так же, как и в git, используется сокращенная запись хеша.</li>
  <li>IMAGE — имя образа, из которого был поднят контейнер. Если не указан тег, то подразумевается <em>latest</em>.</li>
  <li>COMMAND — команда, которая выполнилась на самом деле при старте контейнера.</li>
  <li>CREATED — время создания контейнера</li>
  <li>STATUS — текущее состояние.</li>
  <li>PORTS — проброс портов.</li>
  <li>NAMES — алиас. Докер позволяет кроме идентификатора иметь имя. Так гораздо проще обращаться с контейнером. Если при создании контейнера имя не указано, то Докер самостоятельно его придумывает. В выводе выше как раз такое имя у nginx.</li>
</ul>

<p>(<em>Команда <code class="language-plaintext highlighter-rouge">docker stats</code> выводит информацию о том, сколько ресурсов потребляют запущенные контейнеры).</em></p>

<p>Теперь попробуем остановить контейнер. Выполним команду:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c"># Вместо CONTAINER_ID можно указывать имя</span>
<span class="nv">$ </span>docker <span class="nb">kill </span>431a3b3fc24b <span class="c"># docker kill wizardly_rosalind</span>
431a3b3fc24b
</code></pre></div></div>

<p>Если попробовать набрать <code class="language-plaintext highlighter-rouge">docker ps</code>, то там этого контейнера больше нет. Он удален.</p>

<p>Команда <code class="language-plaintext highlighter-rouge">docker ps</code> выводит только запущенные контейнеры. Но кроме них могут быть и остановленные. Причем, остановка может происходить как и по успешному завершению, так и в случае ошибок. Попробуйте набрать <code class="language-plaintext highlighter-rouge">docker run ubuntu ls</code>, а затем <code class="language-plaintext highlighter-rouge">docker run ubuntu bash -c "unknown"</code>. Эти команды не запускают долгоживущий процесс, они завершаются сразу после выполнения, причем вторая с ошибкой, так как такой команды не существует.</p>

<p>Теперь выведем все контейнеры командой <code class="language-plaintext highlighter-rouge">docker ps -a</code>. Первыми тремя строчками вывода окажутся:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>CONTAINER ID        IMAGE                            COMMAND                  CREATED                  STATUS                       PORTS                                          NAMES
85fb81250406        ubuntu                           <span class="s2">"bash -c unkown"</span>         Less than a second ago   Exited <span class="o">(</span>127<span class="o">)</span> 3 seconds ago                                                  loving_bose
c379040bce42        ubuntu                           <span class="s2">"ls"</span>                     Less than a second ago   Exited <span class="o">(</span>0<span class="o">)</span> 9 seconds ago                                                    determined_tereshkova
</code></pre></div></div>

<p>Здесь как раз два последних наших запуска. Если посмотреть на колонку STATUS, то видно, что оба контейнера находятся в состоянии Exited. То есть запущенная команда внутри них выполнилась, и они остановились. Разница лишь в том, что один завершился успешно (0), а второй с ошибкой (127). После остановки контейнер можно даже перезапустить:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>docker start determined_tereshkova <span class="c"># В вашем случае будет другое имя</span>
</code></pre></div></div>

<p>Только в этот раз вы не увидите вывод. Чтобы его посмотреть, воспользуйтесь командой <code class="language-plaintext highlighter-rouge">docker logs determined_tereshkova</code>.</p>

<h2 id="взаимодействие-с-другими-частями-системы">Взаимодействие с другими частями системы</h2>

<p>Запускать изолированный контейнер, который живет весь внутри себя — малополезно. Как правило, контейнеру нужно взаимодействовать с внешним миром, принимать входящие запросы на определенный порт, выполнять запросы на другие сервисы, читать общие файлы и писать в них. Все эти возможности настраиваются при создании контейнера.</p>

<h3 id="interactive-mode">Interactive mode</h3>

<p>Самый простой вариант использования Докера, как мы уже убедились — поднять контейнер и выполнить внутри него какую-либо команду:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run ubuntu <span class="nb">ls</span> /usr
bin
games
include
lib
<span class="nb">local
</span>sbin
share
src
<span class="err">$</span>
</code></pre></div></div>

<p>После выполнения команды Docker возвращает управление, и мы снова находимся вне контейнера. Если попробовать точно так же запустить баш, то мы получим не то, что хотим:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run ubuntu bash
<span class="err">$</span>
</code></pre></div></div>

<p>Дело в том, что <code class="language-plaintext highlighter-rouge">bash</code> запускает интерактивную сессию внутри контейнера. Для взаимодействия с ней нужно оставить открытым поток STDIN и запустить TTY (псевдо-терминал). Поэтому для запуска интерактивных сессий нужно не забыть добавить опции <code class="language-plaintext highlighter-rouge">-i</code> и <code class="language-plaintext highlighter-rouge">-t</code>. Как правило их добавляют сразу вместе как <code class="language-plaintext highlighter-rouge">-it</code>. Поэтому правильный способ запуска баша выглядит так: <code class="language-plaintext highlighter-rouge">docker run -it ubuntu bash</code>.</p>

<h3 id="ports">Ports</h3>

<p>Если запустить nginx такой командой <code class="language-plaintext highlighter-rouge">docker run nginx</code>, то nginx не сможет принять ни один запрос, несмотря на то, что внутри контейнера он слушает <em>80</em> порт (напомню, что каждый контейнер по умолчанию живет в своей собственной сети). Но если запустить его так <code class="language-plaintext highlighter-rouge">docker run -p 8080:80 nginx</code>, то nginx начнет отвечать на порту <em>8080</em>.</p>

<p>Флаг <code class="language-plaintext highlighter-rouge">-p</code> позволяет описывать как и какой порт выставить наружу. Формат записи <code class="language-plaintext highlighter-rouge">8080:80</code> расшифровывается так: пробросить порт <em>8080</em> снаружи контейнера в контейнер на порт <em>80</em>. Причем, по умолчанию, порт <em>8080</em> слушается на <code class="language-plaintext highlighter-rouge">0.0.0.0</code>, то есть на всех доступных интерфейсах. Поэтому запущенный таким образом контейнер доступен не только через <code class="language-plaintext highlighter-rouge">localhost:8080</code>, но и снаружи машины (если доступ не запрещен как-нибудь еще). Если нужно выполнить проброс только на <em>loopback</em>, то команда меняется на такую: <code class="language-plaintext highlighter-rouge">docker run -p 127.0.0.1:8080:80 nginx</code>.</p>

<p>Docker позволяет пробрасывать столько портов, сколько нужно. Например, в случае nginx часто требуется использовать и <code class="language-plaintext highlighter-rouge">80</code> порт, и <code class="language-plaintext highlighter-rouge">443</code> для HTTPS. Сделать это можно так: <code class="language-plaintext highlighter-rouge">docker run -p 80:80 -p 443:443 nginx</code> Про остальные способы пробрасывать порты  можно прочитать в официальной документации.</p>

<h3 id="volumes">Volumes</h3>

<p>Другая частая задача связана с доступом к основной файловой системе. Например, при старте nginx-контейнера ему можно указать конфигурацию, лежащую на основной фс. Докер прокинет её во внутреннюю фс, и nginx сможет её читать и использовать.</p>

<p>Проброс осуществляется с помощью опции <code class="language-plaintext highlighter-rouge">-v</code>. Вот как можно запустить баш сессию из образа Ubuntu, подключив туда историю команд с основной файловой системы: <code class="language-plaintext highlighter-rouge">docker run -it -v ~/.bash_history:/root/.bash_history ubuntu bash</code>. Если в открытом баше понажимать стрелку вверх, то отобразится история. Пробрасывать можно как файлы, так и директории. Любые изменения производимые внутри volume меняются как внутри контейнера, так и снаружи, причем по умолчанию доступны любые операции. Как и в случае портов, количество пробрасываемых файлов и директорий может быть любым.</p>

<p>При работе с Volumes есть несколько важных правил, которые надо знать:</p>

<ul>
  <li>Путь до файла во внешней системе должен быть абсолютным.</li>
  <li>Если внутренний путь (то, что идет после <code class="language-plaintext highlighter-rouge">:</code>) не существует, то Докер создаст все необходимые директории и файлы. Если существует, то заменит старое тем, что было проброшено.</li>
</ul>

<p>Кроме пробрасывания части фс снаружи, Докер предоставляет еще несколько вариантов создания и использования Volumes. Подробнее — в официальной документации.</p>

<h3 id="переменные-окружения">Переменные окружения</h3>

<p>Конфигурирование приложения внутри контейнера, как правило, осуществляется с помощью переменных окружения в соответствии с <a href="https://12factor.net/ru/">12factors</a>. Существует два способа их установки:</p>

<ul>
  <li>Флаг <code class="language-plaintext highlighter-rouge">-e</code>. Используется он так: <code class="language-plaintext highlighter-rouge">docker run -it -e "HOME=/tmp" ubuntu bash</code></li>
  <li>Специальный файл, содержащий определения переменных окружения, который пробрасывается внутрь контейнера опцией <code class="language-plaintext highlighter-rouge">--env-file</code>.</li>
</ul>

<h2 id="подготовка-собственного-образа">Подготовка собственного образа</h2>

<p>Создание и публикация собственного образа не сложнее его использования. Весь процесс делится на три шага:</p>

<ul>
  <li>Создается файл <code class="language-plaintext highlighter-rouge">Dockerfile</code> в корне проекта. Внутри описывается процесс создания образа.</li>
  <li>Выполняется сборка образа командой <code class="language-plaintext highlighter-rouge">docker build</code></li>
  <li>Выполняется публикация образа в Registry командой <code class="language-plaintext highlighter-rouge">docker push</code></li>
</ul>

<p>Рассмотрим процесс создания образа на примере упаковки линтера <code class="language-plaintext highlighter-rouge">eslint</code> (не забудьте повторить его самостоятельно). В результате сборки, мы получим образ, который можно использовать так:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker run <span class="nt">-it</span> <span class="nt">-v</span> /path/to/js/files:/app my_account_name/eslint

/app/index.js
  3:6  error  Parsing error: Unexpected token

  1 | import path from <span class="s1">'path'</span><span class="p">;</span>
  2 |
<span class="o">&gt;</span> 3 | path<span class="o">(</span><span class="p">;</span><span class="o">)</span>
    |      ^
  4 |

✖ 1 problem <span class="o">(</span>1 error, 0 warnings<span class="o">)</span>
</code></pre></div></div>

<p>То есть достаточно запустить контейнер из этого образа, подключив каталог с файлами js для проверки как Volume во внутреннюю директорию <em>/app</em>.</p>

<h3 id="1-конечная-структура-директории-на-основе-файлов-которой-соберется-образ-выглядит-так">1. Конечная структура директории, на основе файлов которой соберется образ, выглядит так:</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>eslint-docker/
    Dockerfile
    eslintrc.yml
</code></pre></div></div>

<p>Файл <em>eslintrc.yml</em> содержит конфигурацию линтера. Он автоматически прочитывается, если лежит в домашней директории под именем <em>.eslintrc.yml</em>. То есть этот файл должен попасть под таким именем в директорию <em>/root</em> внутрь образа.</p>

<h3 id="2-создание-dockerfile">2. Создание Dockerfile</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code># Dockerfile
FROM node:9.3

WORKDIR /usr/src

RUN npm install -g eslint babel-eslint
RUN npm install -g eslint-config-airbnb-base eslint-plugin-import

COPY eslintrc.yml /root/.eslintrc.yml

CMD ["eslint", "/app"]
</code></pre></div></div>

<p>Dockerfile имеет довольно простой формат. На каждой строчке указывается инструкция (директива) и её описание.</p>

<h4 id="from">FROM</h4>

<p>Инструкция FROM нужна для указания образа, от которого происходит наследование. Здесь необходимо оговориться, что образы строятся на базе друг друга и все вместе образуют большое дерево.</p>

<p>В корне этого дерева находится образ <em>busybox</em>. В прикладных задачах напрямую его не используют, так как Докером предоставляются подготовленные образы под каждую экосистему и стек.</p>

<h4 id="run">RUN</h4>

<p>Основная инструкция в Dockerfile. Фактически здесь указывается <em>sh</em> команда, которая будет выполнена в рамках окружения, указанного во FROM при сборке образа. Так как по умолчанию всё выполняется от пользователя <em>root</em>, то использовать <em>sudo</em> не нужно (и скорее всего его нет в базовом образе). К тому же учтите, что сборка образа — процесс не интерактивный. В тех ситуациях, когда вы используете команду, которая может запросить что-то от пользователя, необходимо подавлять этот вывод. Например, в случае пакетных менеджеров делают так: <code class="language-plaintext highlighter-rouge">apt-get install -y curl</code>. Флаг <code class="language-plaintext highlighter-rouge">-y</code> как раз говорит о том что нужно производиться установку без дополнительных вопросов.</p>

<p>Технически образ Докера — это не один файл, а набор так называемых <em>слоев</em>. Каждый вызов RUN формирует новый слой, который можно представить как набор файлов, созданных и измененных (в том числе удаленных) командой, указанной в RUN. Такой подход позволяет значительно улучшить производительность системы, задействовав кеширование слоев, которые не поменялись. С другой стороны, Докер переиспользует слои в разных образах если они идентичны, что сокращает и скорость загрузки и занимаемое пространство на диске. Тема кеширования слоев довольно важная при активном использовании Докера. Для её эффективной работы нужно понимать как она устроена и как правильно описывать инструкции <code class="language-plaintext highlighter-rouge">RUN</code> для максимальной утилизации.</p>

<h4 id="copy">COPY</h4>

<p>В соответствии со своим названием команда COPY берет файл или директорию из основной файловой системы и копирует её внутрь образа. У команды есть ограничение. То, что копируется, должно лежать в той же директории, где и Dockerfile. Именно эту команду используют при разработке когда необходимо упаковать приложение внутрь образа.</p>

<h4 id="workdir">WORKDIR</h4>

<p>Инструкция, устанавливающая рабочую директорию. Все последующие инструкции будут считать, что они выполняются именно внутри неё. По инструкция <code class="language-plaintext highlighter-rouge">WORKDIR</code> действует, как команда <code class="language-plaintext highlighter-rouge">cd</code>. Кроме того, когда мы запускаем контейнер, то он также стартует из рабочей директории. Например, запустив bash, вы окажетесь внутри неё.</p>

<h4 id="cmd">CMD</h4>

<p>Та самая инструкция, определяющая действие по умолчанию при использовании <code class="language-plaintext highlighter-rouge">docker run</code>. Она используется только в том случае, если контейнер был запущен без указания команды, иначе она игнорируется.</p>

<h3 id="3-сборка">3. Сборка</h3>

<p>Для сборки образа используется команда <code class="language-plaintext highlighter-rouge">docker build</code>. С помощью флага <code class="language-plaintext highlighter-rouge">-t</code> передается имя образа, включая имя аккаунта и тег. Как обычно, если не указывать тег, то подставляется <em>latest</em>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker build <span class="nt">-t</span> my_account_name/eslint <span class="nb">.</span>
</code></pre></div></div>

<p>После выполнения данной команды вы можете увидеть текущий образ в списке <code class="language-plaintext highlighter-rouge">docker images</code>. Вы даже можете начать его использовать без необходимости публикации в Registry. Напомню, что команда <code class="language-plaintext highlighter-rouge">docker run</code> не пытается искать обновленную версию образа, если локально есть образ с таким именем и тегом.</p>

<h3 id="4-публикация">4. Публикация</h3>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>docker push my_account_name/eslint
</code></pre></div></div>

<p>Для успешного выполнения публикации нужно соблюсти два условия:</p>

<ul>
  <li>Зарегистрироваться на Docker Cloud и создать там репозиторий для образа.</li>
  <li>Залогиниться в cli интерфейсе используя команду <code class="language-plaintext highlighter-rouge">docker login</code>.</li>
</ul>

<h2 id="docker-compose">Docker Compose</h2>

<p>Docker Compose — продукт, позволяющий разрабатывать проект локально, используя Докер. По решаемым задачам его можно сравнивать с Vagrant.</p>

<p>Docker Compose позволяет управлять набором контейнеров, каждый из которых представляет из себя один сервис проекта. Управление включает в себя сборку, запуск с учетом зависимостей и конфигурацию. Конфигурация Docker Compose описывается в файле <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>, лежащем в корне проекта, и выглядит примерно так:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="c1"># https://github.com/hexlet-basics/hexlet_basics</span>

<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.3'</span>

<span class="na">services</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
  <span class="na">app</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">services/app</span>
      <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">Dockerfile</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">mix phx.server</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">${PORT}:${PORT}"</span>
    <span class="na">env_file</span><span class="pi">:</span> <span class="s1">'</span><span class="s">.env'</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">./services/app:/app:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">~/.bash_history:/root/.bash_history:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">.bashrc:/root/.bashrc:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/var/tmp:/var/tmp:cached"</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/tmp:/tmp:cached"</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
</code></pre></div></div>

<h2 id="в-бою">В бою</h2>

<p>При использовании Докера настройка машин проекта, как правило, сводится к установке Докера. Дальше нужно только деплоить. Простейший процесс выкладки выглядит так:</p>

<ol>
  <li>Скачать новый образ.</li>
  <li>Остановить старый контейнер.</li>
  <li>Поднять новый контейнер.</li>
</ol>

<p>Причем, данный порядок действий не зависит от стека технологий. Выполнять деплой можно (как и настройку машин) с помощью <a href="https://docs.ansible.com/ansible/2.5/modules/docker_container_module.html">Ansible</a>.</p>

<p>Другой вариант, подходящий для нетривиальных проектов, основан на использовании специальных систем оркестрации типа <a href="https://kubernetes.io/">Kubernetes</a>. Данный вариант требует от вас довольно серьезной подготовки, включающий понимание принципов работы распределенных систем.</p>

<h2 id="докер-под-капотом">Докер под капотом</h2>

<p>Изоляция, которую предоставляет Докер, достигается благодаря возможностям ядра <a href="https://en.wikipedia.org/wiki/Cgroups">Cgroups</a> и <a href="https://en.wikipedia.org/wiki/Linux_namespaces">Namespaces</a>. Они позволяют запускать процесс операционной системы не только в изолированном окружении, но и с ограничением по использованию физических ресурсов, таких как память или процессор.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=dfXuTTV6TVo">Вебинар: Введение в докер</a></li>
  <li><a href="https://ru.hexlet.io/courses/docker-basics">Docker: Основы</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/virtualization/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое виртуализация и для чего она нужна</turbo:topic> -->
            <title>Что такое виртуализация и для чего она нужна</title>
            <pubDate>Mon, 29 Jan 2018 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/virtualization/">Что такое виртуализация и для чего она нужна</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/virtualization/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>У пользователей Linux или Mac иногда возникает потребность в запуске программ, работающих только в Windows, а у Windows-пользователей, особенно программистов, потребность в запуске Linux или другой версии Windows. Классический пример — игры или Photoshop.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Самый очевидный способ сделать это — купить второй компьютер, но это дорогое удовольствие. Второй вариант - поставить Windows рядом со своей основной операционной системой. Такая установка, как правило, может все сломать, но если у вас получилось, во время старта компьютера вы сможете выбрать операционную систему для загрузки. Но существует третий путь — <strong>виртуализация</strong>.</p>

<h2 id="виртуализация">Виртуализация</h2>

<p><strong>Виртуализация — это создание изолированных окружений в рамках одного физического устройства</strong> (в нашем случае — компьютера). Каждое окружение при этом выглядит как отдельный компьютер со своими характеристиками, такими как доступная память, процессор и тому подобное. Такое окружение называют набором логических ресурсов или <strong>виртуальной машиной</strong>.</p>

<p><em>Виртуализация позволяет запускать операционную систему как обычную программу на вашем компьютере!</em></p>

<p>ОС, внутри которой стартует другая ОС, называется <strong>хост-системой</strong>, (host) а ОС, которая работает в виртуальном окружении — <strong>гостевой</strong> (guest).</p>

<p>Специальная программа (по сути тоже операционная система) — <strong>гипервизор</strong> — занимается созданием виртуальных машин и их управлением. Гипервизор обеспечивает изоляцию операционных систем друг от друга, защиту и безопасность, разделение ресурсов между запущенными ОС. В зависимости от типа используемой виртуализации, гипервизор может работать как напрямую с железом без хост системы, так и через основную операционную систему, установленную на хост-машину. В первом случае используется <strong>аппаратная виртуализация</strong>, во втором — <strong>программная виртуализация</strong>. На домашних компьютерах распространен именно второй тип.</p>

<p>В отличие от установки двух операционных систем рядом в одну машину, виртуализация — это гораздо более безопасный метод. В любой момент можно все снести и переустановить. Вы можете создать столько виртуальных машин, сколько нужно.</p>

<h3 id="аппаратная-виртуализация">Аппаратная виртуализация</h3>

<p>Как ясно из названия, аппаратная виртуализация работает благодаря поддержке со стороны железа — процессора. В отличие от программной виртуализации, гостевые операционные системы управляются гипервизором напрямую без участия хостовой ОС.</p>

<p>Аппаратная виртуализация гораздо эффективнее программной, так как гипервизор, в отличие от хостовой ОС, создает очень небольшой оверхед (overhead, накладные расходы). Программная виртуализация, в свою очередь, делится на несколько подтипов, о которых подробнее можно прочитать в <a href="https://ru.wikipedia.org/wiki/Виртуализация">Википедии</a>.</p>

<h3 id="контейнерная-виртуализация">Контейнерная виртуализация</h3>

<p>Особняком стоит так называемая <strong>контейнерная виртуализация</strong>. В отличие от предыдущих видов, она не связана с запуском ОС в изолированном окружении. При контейнерной виртуализации изоляция происходит на уровне процесса операционной системы.</p>

<p>На текущий момент такой вид виртуализации существует только в Linux и доступен благодаря двум возможностям ядра: cgroups и namespaces. Они позволяют запускать всего лишь один процесс так, как будто он выполняется в своем собственном мире, со своей сетью, своим диском, своей файловой системой и так далее. При таком виде виртуализации происходит запуск процесса в <strong>той же операционной системе и на том же ядре</strong>, а значит вы не можете с помощью нее в Linux запустить Windows. Эту виртуализацию применяют на уровне сервисов, составляющих части программного продукта. Наиболее известные проекты: OpenVZ, Docker, LXC.</p>

<h2 id="хостинг">Хостинг</h2>

<p>Каждая виртуальная машина получит столько ресурсов, сколько вы укажете. Этим фактом особенно пользуются хостеры (компании, предоставляющие услуги веб-хостинга). Фактически на каждого пользователя создается своя собственная виртуальная машина с квотами, соответствующими выбранному тарифу (ограничения по памяти, процессору и так далее).</p>

<p>Кроме того, виртуализация изолирует машины друг от друга, а значит вам не придется переживать, если пользователи попытаются навредить системе или соседним пользователям. Подобная услуга обычно называется VPS (virtual private server) и в базовой комплектации стоит дешево.</p>

<p>Виртуальные машины позволяют эффективнее утилизировать (использовать) ресурсы железной машины. Как правило, далеко не всем пользователям нужна мощность того железа, которое стоит у хостера, да и платить за нее он не готов. А вот виртуальная машина может съедать лишь проценты от мощности железа, что позволяет на одной машине размещать десятки клиентов (а то и больше). Получается, что и пользователь доволен, и хостер заработал свои деньги.</p>

<h2 id="частые-вопросы">Частые вопросы</h2>

<h3 id="что-делать-если-процессор-не-поддерживает-виртуализацию">Что делать если процессор не поддерживает виртуализацию?</h3>

<p>Это крайне маловероятно, но даже в таком случае можно запустить виртуальную машину. Правда производительность будет очень низкой, так как по факту будет работать программная виртуализация вместо аппаратной. Лучше всё же обновить железо на более современное.</p>

<h2 id="другие-гайды-по-теме">Другие гайды по теме</h2>

<ol>
  <li><a href="/vagrant/">Что такое Vagrant</a>. Vagrant позволяет создавать и конфигурировать легковесные, повторяемые и переносимые окружения для разработки в виртуальных машинах.</li>
  <li><a href="/ubuntu-linux-in-windows/">Как работать с Linux используя Windows</a>. Инструкция по установке Ubuntu Linux внутри Windows с использованием различных технологий виртуализации.</li>
</ol>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/vim/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Зачем использовать vim</turbo:topic> -->
            <title>Зачем использовать vim</title>
            <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/vim/">Зачем использовать vim</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/vim/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>VI(M) — текстовый редактор, который появился в далеком 1991 году, но до сих пор пользуется огромной популярностью (наряду с Emacs). Как правило, на него переходят после других редакторов уже состоявшиеся разработчики. Нередко, переходят с полноценных IDE. Почему?</strong></p>

<p><img src="/assets/images/vim/vim.png" alt="vim, linter, fzf" />
<small>vim с настроенным линтером, файловым деревом NERDTree и нечетким поиском с fzf</small></p>

<p>В этом гайде не будет пошагового обучения виму. Цель — объяснить философию vim и причины его популярности, а также дать направление для дальнейшего обучения.</p>

<h2 id="различия-редакторов">Различия редакторов</h2>

<p>В современном мире есть из чего выбрать среди редакторов: Sublime Text, Atom, VS Code, Brackets. И это не считая IDE.</p>

<p><img src="/assets/images/vscode-js-setup/vscode_eslint.png" alt="eslint vscode" />
<small>Visual Studio Code</small></p>

<p>Все они не лишены недостатков, но с точки зрения возможностей наворочены по максимуму. Между собой редакторы сравнивают по следующим характеристикам:</p>

<ul>
  <li>Скорость работы. Хотя её ставят превыше всего, практика показывает, что программисты готовы страдать ради продвинутых возможностей.</li>
  <li>Возможности по редактированию текста, например мультикурсоры или сплиты (разделения экрана).</li>
  <li>Наличие большого числа разнообразных плагинов, включающих поддержку языков и инструментов.</li>
  <li>Интеграции, такие как git, терминалы и другое.</li>
</ul>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/courses/cli-basics?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Основы командной строки с практикой в браузере. Бесплатно
</a>
</div>

<p>При таком способе сравнения vim выглядит достаточно бледно на фоне других редакторов. Да, он самый быстрый, но количество и качество плагинов явно уступает, а интеграций и вовсе нет, хотя, с другой стороны, многие из них не нужны в мире вима. Кроме всего прочего, обычный vim (а есть еще gvim — версия, запускающаяся в виде отдельного оконного приложения) — терминальная программа со всеми вытекающими последствиями. Мышка хоть и поддерживается, но работать используя её в виме —  сомнительное удовольствие. Например скроллинг двигается рывками, так как в текстовом терминале смещение построчное.</p>

<p>И завершает картину кривая обучения. У вима она даже круче, чем у emacs. Чтобы научиться им пользоваться, придется в буквальном смысле страдать (но недолго если правильно учиться).</p>

<p><img src="/assets/images/vim/vim_learning.png" alt="learning curve" /></p>

<h2 id="чужой-среди-своих">Чужой среди своих</h2>

<p>Так почему же вим?</p>

<p>Если <a href="/typing/">слепой десятипальцевый метод</a> печатания создан для эффективного набора текста, то вим создан для слепого десятипальцевого редактирования текста.</p>

<p>Вим предлагает другой взгляд на способ работы с текстом. Вместо горячих клавиш + мышка + перемещение стрелками вим вводит понятие <em>режимы</em>. По умолчанию, открыв редактор, мы попадаем в режим <em>normal</em>. В этом режиме вся клавиатура действует как приборная панель, набор текста в нём невозможен. Его основная задача — использовать клавиатуру для перемещения по тексту и выполнение модификаций с помощью команд. В отличие от горячих клавиш, все команды короткие и нередко составные, причем, нажатие составных команд всегда последовательное, а не одновременное, как в горячих клавишах.</p>

<p>Другими словами, вим предоставляет язык для модификации текста.</p>

<p>Приведу несколько примеров:</p>

<ul>
  <li><kbd>w</kbd> — переместиться на слово вперед</li>
  <li><kbd>W</kbd> — перемещаться вперед по пробелам</li>
  <li><kbd>b</kbd> — переместиться назад</li>
  <li><kbd>B</kbd> — перемещаться назад по пробелам</li>
  <li><kbd>dd</kbd> — удалить строку</li>
  <li><kbd>diw</kbd> — удалить слово, которое находится под курсором</li>
  <li><kbd>daw</kbd> — удалить слово, которое находится под курсором вместе с окружением (всё, кроме пробелов, например кавычки)</li>
  <li><kbd>gg</kbd> — переместиться в начало документа</li>
  <li><kbd>/</kbd> — начнёт поиск; всё, что вводится далее, ищется в открытом файле (плюс есть команды для перемещения вперед и назад по найденному)</li>
</ul>

<p>А вот, например, более интересная команда — <kbd>r</kbd>. После нажатия редактор ожидает следующего символа. Затем, когда он будет введен, редактор заменяет символ под курсором на введённый. Нетрудно догадаться, что <kbd>r</kbd> означает <em>replace</em>. Подобных команд в виме не одна сотня. И многие из них могут комбинироваться в довольно сложные цепочки, позволяя творить чудеса.</p>

<p>Сама система команд, при этом, выстраивается в логичную систему, где всё имеет смысл и находится на своем месте. Причем, не только с точки зрения обозначений (i — inner, a — around и так далее), но и с точки зрения расположения на клавиатуре. Из этого, кстати, следует интересный вывод: если ваша раскладка не qwerty, то вся клавиатура «поедет», и пользоваться вимом станет невыносимо больно.</p>

<p>Отдельного упоминания заслуживает перемещение по тексту. В виме все перемещения делаются набором клавиш <code class="language-plaintext highlighter-rouge">hjkl</code>. Вы, должно быть, удивлены что эти клавиши расположены в одну строчку. Но как показывает практика, к такой системе привыкаешь крайне быстро и потом везде пытаешься перемещаться таким же способом.</p>

<p>Ключевое место в этой структуре имеет клавиша под названием Leader. Это не какая-то конкретная клавиша, она разная у разных пользователей, хотя сейчас, как правило, все используют пробел. Дело в том что большая часть пользовательских комбинаций (и тех, кто предоставляют плагины), делаются как раз через лидер. В конфигурации она обозначается как <code class="language-plaintext highlighter-rouge">&lt;Leader&gt;</code>.</p>

<p><img src="/assets/images/vim/vim_cheat_sheet.jpg" alt="vim cheat sheet" />
<small>vim cheat sheet by Max Cantor</small></p>

<p>Но для полноценной работы одного режима <em>normal</em> недостаточно. Для перехода в режим редактирования <em>insert</em>, существует более 6 способов! Например ввод команды <kbd>i</kbd> приводит к тому, что ввод начинается прямо в том месте, где стоит курсор, а <kbd>shift + a</kbd> перемещает курсор в конец строки (требуется довольно часто), в свою очередь <kbd>cc</kbd> стирает ту строчку, где находится курсор и входит в режим редактирования.</p>

<p>Для выхода из режима вставки в нормальный режим, достаточно нажать ESC.</p>

<p>Кроме этих двух, у vim есть режим <em>visual</em>, который похож на normal, но используется исключительно для выделения текста. И еще один способ взаимодействия с редактором появляется после ввода символа <code class="language-plaintext highlighter-rouge">:</code> в нормальном режиме. Курсор перемещается вниз экрана, куда можно вводить различные команды. Так, например, делается выход из вим. В этой строке необходимо набрать <code class="language-plaintext highlighter-rouge">q</code> и нажать Enter. Команды, вводимые подобным образом, обычно обозначают так: <code class="language-plaintext highlighter-rouge">:help</code>. То есть необходимо набрать <code class="language-plaintext highlighter-rouge">:</code> затем слово <code class="language-plaintext highlighter-rouge">help</code> и затем нажать Enter.</p>

<p>При правильной работе в вим режим вставки используется только для ситуации набора текста (или стирания во время набора). Модификации и перемещения выполняются, в подавляющем большинстве случаев, в режиме команд.</p>

<p>Мощь режима <em>normal</em> вы можете оценить хотя бы по тому, что абсолютно в каждом популярном редакторе есть плагин, эмулирующий работу vim и, как правило, это самый популярный плагин с огромным отрывом от всех остальных. Например, плагин в VS Code установили более миллиона раз.</p>

<p>Другой, не менее интересный, а для многих, возможно, шокирующий пример популярности этого режима — программное обеспечение вокруг нас. Gmail поддерживает перемещение как в vim прямо в веб интерфейсе, Github тоже (попробуйте на странице любого репозитория набрать вопросительный знак на клавиатуре). В каждом браузере существует популярный плагин, позволяющий перемещаться по загруженным страницам в стиле вим. Все пейджеры, такие как less или more, также используют навигацию, портированную из вима. Соответственно и все программы, использующие пейджеры, например, <code class="language-plaintext highlighter-rouge">git log</code> (и другие команды git). Даже в bash достаточно набрать <code class="language-plaintext highlighter-rouge">set -o vi</code>, как командная строка превращается в vi (без m). Кстати, по умолчанию в bash включен режим emacs с горячими клавишами из этого редактора.</p>

<p>Наличие режимов — ключевая, но не единственная причина. Вторая, не менее важная — буферы. В обычных редакторах есть чёткое разграничение на табы с файлами и другие панели, такие как файловое дерево, встроенный терминал, окно вывода ошибок, окно конфигурации, окно отладки и так далее. Все эти сущности живут своей жизнью. У них свои правила работы и отображения, свой набор горячих клавиш и способ перемещения внутри них (если такое перемещение вообще возможно).</p>

<p>В виме любой кусок редактора, открытый в своей собственной рамке — всего лишь текстовый буфер независимо от того, как он используется. Автоматически это означает единый способ взаимодействия с этими буферами. Например, упоминавшийся выше <code class="language-plaintext highlighter-rouge">/</code> поиск прекрасно работает в любой части редактора. То же самое касается перемещения с <code class="language-plaintext highlighter-rouge">hjkl</code>. Содержимое такого буфера можно копировать стандартными средствами как целиком, так и по выделению, его можно закрыть через команду, предназначенную для закрытия буфера (опять же, независимо от его внутренней структуры). Можно даже открыть больше буферов, чем места на рабочей области. Одни буферы могут спокойно перекрывать другие, что не помешает переключению между ними. Буферы настолько удобны, что несмотря на наличие табов (вкладок) в вим, пользуются ими крайне редко.</p>

<p>Еще одно внезапное преимущество появляется из-за текстовой природы самого редактора. Так как он открывается прямо во вкладках терминала, а продвинутые терминалы имеют такую возможность как split окна, то интеграция терминала внутрь vim особо не нужна и с помощью комбинации вкладок терминалов и вима можно очень удобно настроить рабочий процесс.</p>

<p><img src="/assets/images/vim/vim_iterm_split.png" alt="iterm2 with vim and split" />
<br /><small>Терминал iTerm 2 со split-окнами</small></p>

<h2 id="цена">Цена</h2>

<p>Возможности, описанные выше, не даются бесплатно. Существуют определенные пререквизиты. Главный из которых — <a href="/typing/">слепая десятипальцевая печать</a>. Опыт показывает, что если программист печатает вслепую, но не по десятипальцевой схеме, то он либо вообще не может адаптироваться, либо постоянно испытывает дискомфорт. Если же человек пока не научился печатать вслепую вообще, то изучение вима стоит отложить на будущее.</p>

<p>Как правило, люди, печатающие правильно, настолько ценят возможность не смещать руки относительно центральной позиции (смещение руки на стрелки для них доставляет физический дискомфорт и неприятие), что вим становится для них настоящим праздником. Вся система команд идеально ложится на соответствующую концепцию.</p>

<p>Но и здесь есть подводные камни. В те времена когда появился vim, клавиатура выглядела иначе. И в том месте где сейчас caps lock и tab, были ctrl и esc. Последние используются в виме на полную катушку. Если ничего дополнительно не предпринимать, то придется очень серьезно выламывать себе руки (попутно зарабатывая <a href="https://ru.hexlet.io/blog/posts/carpal-tunnel-syndrome">туннельный синдром</a>). Поэтому, первое что делают вимеры, переключают <kbd>ctrl</kbd> на caps lock, а для <kbd>esc</kbd> пользуются либо стандартной комбинацией <kbd>ctrl + [</kbd>, которая легко дается с перемещенным ctrl для тех кто хорошо владеет слепым десятипальцевым методом, либо используют комбинацию <kbd>jj</kbd>, которую определяют самостоятельно.</p>

<p><img src="/assets/images/vim/lsi-adm3a-full-keyboard.jpg" alt="vim keyboard" />
<br /><small>Клавиатура терминала ADM-3A</small></p>

<p>В мире вима есть одна деталь, серьезно влияющая на количество его пользователей. В отличие от современных редакторов, в которых настройка выполняется переключением галочек либо изменением значений в json-файле, вим требует поддержки своего файла конфигурации и ручном управлении буквально всем. В виме нет механизма для просмотра и установки плагинов прямо из редактора. Каждый плагин необходимо самостоятельно найти на гитхабе и вписать в этот файл. Если нужна дополнительная конфигурация, то в этом же файле её и нужно сделать. Сам конфигурационный файл использует язык программирования VimL, тот же, на котором написан сам редактор. К сожалению, не получается один раз настроить его и забыть. Несмотря на то, что в сети огромное число примеров этих конфигурационных файлов, постоянно приходится что-то подкручивать, заменять плагины и дописывать новые горячие клавиши.</p>

<p><img src="/assets/images/vim/vimrc.png" alt="vimrc" />
<br /><small>Фрагмент файла конфигурации vim</small></p>

<h2 id="когда-не-стоит-учить-вим">Когда не стоит учить вим</h2>

<ul>
  <li>Если вас целиком устраивают обычные редакторы</li>
  <li>При недостаточном владении слепой печатью</li>
  <li>Вы не готовы возиться с конфигурацией, а хотите чтобы редактор просто работал</li>
  <li>Вы емаксер (тогда учите <a href="https://github.com/syl20bnr/spacemacs">spacemacs</a>)</li>
</ul>

<p>Отдельно стоит сказать, что не стоит учить вим одновременно с тем, что вы собираетесь делать внутри него. Когнитивная нагрузка при изучении вима настолько высокая, что у вас не будет оставаться никакой энергии на изучение нового языка, фреймворка или, даже, программирования в целом. На вим имеет смысл смотреть тогда, когда вы уже спокойно работаете и хотите новых острых ощущений.</p>

<p>Другой важный аспект — готовность принять идеологию вима. Нередко происходит ситуация, когда программист садится за вим и при этом не начинает пользоваться вимом. Он продолжает использовать стрелки и практически не выходит в командный режим. Такой способ обучения виму самый опасный. Как только произойдет привыкание, переучить себя будет неимоверно сложно. Немалое число людей, считающих себя вимерами, не используют вим и в действительности работают крайне неэффективно.</p>

<p>Обучение виму — процесс сложный морально. Дело в том, что опыт сам по себе не делает вас лучше в чем-то. Научившись как-нибудь набирать текст, человек и через много лет будет делать это как-нибудь (не по скорости, а по эффективности работы с ним). То же самое касается использования редакторов.</p>

<p>Для повышения своей эффективности необходимо постоянно наблюдать за своими действиями, отслеживать те, что занимают слишком много времени, читать статьи и книги в поисках новых способов решения старых проблем. Такой подход, конечно же, важен не только при работе с вимом и даже не только в программировании, но именно в виме по-другому успеха достичь невозможно. Во время обучения нельзя себе давать слабину и действовать из принципа «сейчас сделаю хоть как-нибудь, а потом разберусь». Незаметно для вас сформируются неправильные привычки и дальнейший рост остановится. Если вы к этому не готовы, то изучение стоит отложить.</p>

<h2 id="сколько-понадобится-времени">Сколько понадобится времени</h2>

<p>Если следовать советам выше и постоянно правильно практиковать вим, то время от «любое действие занимает минуту» до «могу неспешно работать периодически подсматривая в документацию» займет около месяца. Дальше процесс пойдет легче, но останавливаться в развитии на этом этапе нельзя. Оттачивание всех необходимых навыков может занять и год. Но не стоит пугаться. В любом случае через месяц-два вы сможете вполне сносно работать.</p>

<h2 id="neovim">NeoVim</h2>

<p>Некоторое время назад был основан проект <a href="https://neovim.io/">NeoVim</a>. Это форк вима, разрабатывающийся энтузиастами. Сейчас он очень популярен и работает лучше, чем оригинальный Vim. Совместимость с плагинами почти полная, к тому же, большинство плагинов сейчас делаются с прицелом и на nvim тоже. Наша рекомендация использовать как основной редактор именно nvim.</p>

<h2 id="процесс-обучения">Процесс обучения</h2>

<ul>
  <li>
    <p>Поставьте nvim и vim (с поддержкой python3).</p>
  </li>
  <li>
    <p>Не все шаги, описанные ниже, нужно выполнять последовательно. То, что можно делать параллельно, стоит делать параллельно. В любом случае перед тем, как решиться распробовать вим, стоит пройти официальный <em>vimtutor</em> который идет в поставке с самим вимом. Он проведет вас через все базовые команды и даст представление о том, как все работает. Откройте терминал и наберите <code class="language-plaintext highlighter-rouge">vimtutor</code>, при необходимости установив <code class="language-plaintext highlighter-rouge">vim</code>. После него можно браться за интерактивные учебники, описанные в полезных ссылках ниже. Делать это стоит одновременно с практикой работы с настоящим вимом.</p>
  </li>
  <li>
    <p>Распечатайте и изучите <a href="https://bit.ly/2urvrMA">vim cheatsheets</a>.</p>
  </li>
  <li>
    <p>Научитесь использовать возможности вашего терминала — сплиты/табы используя горячие клавиши.</p>
  </li>
  <li>
    <p>Измените маппинги клавиш как описано выше.</p>
  </li>
  <li>
    <p>Дальше есть два пути. Либо брать и с нуля настраивать свой собственный <code class="language-plaintext highlighter-rouge">.vimrc</code> (конфиг), что невероятно сложно и затратно на первых порах, либо, что лучше, взять готовую сборку и сосредоточиться на владении самим вимом. А затем, постепенно разбираться с тем как все устроено внутри и по необходимости делать собственную сборку. Я рекомендую использовать свою <a href="https://github.com/mokevnin/dotfiles">сборку</a>. Она вобрала в себя лучше практики и практически не содержит самописного кода. К тому же внутри неё используются самые современные плагины. Внимательно изучите Makefile и выполните все необходимые команды. В процессе работы постоянно смотрите в файл <code class="language-plaintext highlighter-rouge">vimrc</code> и изучайте его содержимое вместе с установленными плагинами. Все плагины хостятся на гитхабе вместе с их документацией.</p>
  </li>
  <li>
    <p>Научитесь работать с пакетным менеджером <a href="https://github.com/junegunn/vim-plug">plug</a>. С него начинается вход в vim.</p>
  </li>
  <li>
    <p>Изучение самого вима включает два аспекта. Первый, работа внутри буфера. К нему, как раз, относится та самая навигация и владение базовыми командами по модификации и перемещению. Второе, навигация по проекту и управление файловой структурой. Управление файловой структурой (создание, переименование и удаление) производятся плагином NERDTree, а для навигации существует три основных и несколько дополнительных способов. Основные: нечеткий поиск (fzf), переключение между буферами (bufexplorer) и перемещение по файловому дереву (NERDTree). Все они важны и используются постоянно. Несмотря на то, что вим поддерживает табы, вимеры редко ими пользуются, но даже если и пользуются, то не для тех целей, для которых табы используются в обычных редакторах. К дополнительным способам навигации относятся прыжки по последним модификациям (вим их запоминает и позволяет ходить вперед назад), а так же комбинация <kbd>gf</kbd>, означающая “go to file”.</p>
  </li>
  <li>
    <p>Изучите набор плагинов, подходящих под ваш стек, и установите их. В интернете много статей для настройки практически любого стека разработки. Единственная рекомендация, смотрите плагины основанные на <a href="https://langserver.org/">lsp</a></p>
  </li>
</ul>

<h2 id="полезные-ссылки">Полезные ссылки</h2>

<ul>
  <li><a href="https://github.com/mhinz/vim-galore">vim-galore</a> - всё, что нужно знать о Vim</li>
  <li><a href="https://vim-adventures.com/">vim-adventures.com</a> - игра с управлением как в виме</li>
  <li><a href="https://www.openvim.com/">www.openvim.com</a> - интерактивный учебник</li>
  <li><a href="https://bit.ly/2TSetS9">vimgenius.com</a> - еще один учебник</li>
  <li><a href="https://vimgolf.com/">vimgolf.com</a> - фановый проект, в котором участники соревнуются кто выполнит модификацию текста с наименьшим числом нажатий</li>
  <li><a href="https://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">Learn Vim Progressively</a> - небольшой гайд по освоению vim от простых команд к сложным</li>
  <li><a href="https://vim-bootstrap.com/">vim-bootstrap.com</a> - генератор преднастроенной конфигурации для vim для работы с различными языками. Список горячих клавиш <a href="https://github.com/avelino/vim-bootstrap#commands">здесь</a></li>
  <li><a href="https://github.com/Andrew8xx8/vimpractise">Andrew8xx8/vimpractise</a> - практические задания для использования команд</li>
  <li><a href="https://ru.wikibooks.org/wiki/Vim">Vim - викиучебник</a></li>
  <li><a href="https://www.youtube.com/watch?v=79OWQ1qJwto">Вебинар Hexlet об использовании vim</a></li>
</ul>

<p>Периодически стоит заглядывать в <a href="https://github.com/vim/vim/blob/master/runtime/doc/intro.txt">документацию</a>. Её также можно открыть в самом vim используя команду <code class="language-plaintext highlighter-rouge">:help</code>.</p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/vagrant/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое Vagrant: установка, запуск, использование
</turbo:topic> -->
            <title>Что такое Vagrant: установка, запуск, использование
</title>
            <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/vagrant/">Что такое Vagrant: установка, запуск, использование
</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/vagrant/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>Vagrant — продукт компании HashiCorp, специализирующейся на инструментах для автоматизации разработки и эксплуатации. Он позволяет создавать и конфигурировать легковесные, повторяемые и переносимые окружения для разработки.</strong></p>

<p>Первая задача любого разработчика на новом проекте - развернуть окружение. Как правило, она сводится к следующим шагам:</p>

<ol>
  <li>Клонировать репозиторий с проектом.</li>
  <li>Поставить необходимые пакеты для работы (например, библиотеку для xml).</li>
  <li>Установить дополнительные программы, такие как базу данных.</li>
  <li>Правильно настроить конфигурационные параметры.</li>
</ol>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Без автоматизации подобный процесс может занимать как часы, так и целые дни, в зависимости от сложности проекта. Причем, для каждого человека в команде. Для каждой смены рабочей машины или после переустановки системы. Проблема усугубляется тем, что чем больше разработчиков на проекте, тем более разнообразные машины они используют, включая разные операционные системы. В подобном случае процесс настройки гарантированно будет разным, что является еще одним источником проблем. Весь процесс настройки должен быть где-то описан, но, как правило, эти описания быстро устаревают и их мало кто хочет поддерживать, а любые попытки поддерживать актуальность в конце концов угасают.</p>

<p>После добавления пары таких проектов операционная система становится сильно захламленной. Даже если вы не работаете над проектом, после включения компьютера начнут стартовать сервисы, которые требуются только для разработки.</p>

<p>Еще одна проблема - изменения. Практически любая перенастройка установленной конфигурации потребует ручного вмешательства, доустановки пакетов, программ или изменения конфигов.</p>

<p>И последнее: нередко требуется возможность развернуть проект и для не программистов, например верстальщиков или тестировщиков. Наличие даже хорошо описанного процесса установки мало им поможет.</p>

<p>Теперь можно попробовать сформулировать требования к идеальному окружению:</p>

<ol>
  <li>Изолированность. Таким образом избегаются возможные конфликты с другими окружениями (например, основной системой) и основная система остается чистой.</li>
  <li>Повторяемость. Пересоздать рабочую среду можно за считанные минуты набрав буквально одну команду. Любое изменение распространяется сразу для всех.</li>
  <li>Переносимость. Окружение разворачивается под любой системой одним универсальным способом.</li>
</ol>

<p>Vagrant создан для решения именно этих задач. Во многом его работа опирается на виртуализацию, для которой, по умолчанию, используется продукт <a href="https://www.virtualbox.org/">VirtualBox</a>. Но в отличие от обычной работы с виртуальной машиной, когда внутри нее стоит система с графической оболочкой, Vagrant создает виртуальную машину доступную только в терминальном режиме (через командную строку), при этом сама разработка продолжается на хост-машине, а вот запуск кода на выполнение происходит внутри машины. Другими словами, редактор ставится на вашу основную систему и код лежит также в ней. Vagrant прозрачно прокидывает код внутрь машины и позволяет его запускать.</p>

<h2 id="подготовка-к-работе">Подготовка к работе</h2>

<p>Использование Vagrant подразумевает некоторую настройку операционной системы и наличие определенных знаний:</p>

<ul>
  <li>Нужно знать, что такое виртуализация и как работать с виртуальными машинами</li>
  <li>Командная строка - единственный способ взаимодействия с Vagrant. Если ваша операционная система Windows, то вам необходимо <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">настроить</a> её.</li>
  <li>Базовое знание сетей, понятие порта.</li>
  <li>На вашем компьютере должно быть хотя бы 4 гигабайта оперативной памяти, хотя даже с таким объемом, работать проблематично. Минимально комфортный уровень - 8 гигабайт.</li>
</ul>

<h2 id="как-установить-vagrant">Как установить Vagrant</h2>

<p>Первым делом необходимо поставить систему виртуализации, например VirtualBox. Скачать его под вашу операционную систему можно <a href="https://www.virtualbox.org/wiki/Downloads">здесь</a>.</p>

<p>Затем скачайте установщик Vagrant под вашу операционную систему на странице <a href="https://www.vagrantup.com/downloads.html">Download</a>.</p>

<p>Откройте терминал и убедитесь что Vagrant работает:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>vagrant <span class="nt">-v</span>
</code></pre></div></div>

<h2 id="инициализация">Инициализация</h2>

<p>Дизайн Vagrant предполагает, что мы создаем отдельную конфигурацию на каждый проект (а соответственно и виртуальную машину), а не одну на все. Инициализация выполняется в папке соответствующего проекта командой <code class="language-plaintext highlighter-rouge">vagrant init ubuntu/xenial64</code>. В результате выполнения этой команды Vagrant создаст файл Vagrantfile. Внутри файла описана конфигурация виртуальной машины на языке Ruby. Не страшно, если вы не знакомы с ним, содержимое файла интуитивно понятно, а документация Vagrant достаточно подробна.</p>

<p>Кроме создания файла, Vagrant скачает на вашу машину образ (image) операционной системы, хранящийся под именем <code class="language-plaintext highlighter-rouge">ubuntu/xenial64</code>. В данном случае речь идет про Ubuntu 16.04. Vagrant поддерживает каталог образов, созданных специально под работу с ним. При необходимости можно выбрать другой, посмотрев его имя в <a href="https://app.vagrantup.com/boxes/search">каталоге</a>. Если открыть файл Vagrantfile, то можно увидеть что имя образа прописано внутри конфигурации:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="no">Vagrant</span><span class="p">.</span><span class="nf">configure</span><span class="p">(</span><span class="s1">'2'</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">box</span> <span class="o">=</span> <span class="s1">'ubuntu/xenial64'</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="рабочий-процесс">Рабочий процесс</h2>

<h3 id="запуск">Запуск</h3>

<p>Старт выполняется командой <code class="language-plaintext highlighter-rouge">vagrant up</code>. Она создает виртуальную машину и запускает ее. Если машина уже была создана (предыдущими запусками), то произойдет только старт.</p>

<p>В этот момент уже можно начинать работать с кодом, лежащим в той же папке, что и Vagrantfile. Все изменения автоматически оказываются внутри запущенной виртуальной машины.</p>

<h3 id="подключение">Подключение</h3>

<p>Для входа внутрь используется команда <code class="language-plaintext highlighter-rouge">vagrant ssh</code>. После выполнения терминал подключается к машине в домашнюю директорию пользователя по умолчанию. Традиционно в Vagrant это пользователь с именем <code class="language-plaintext highlighter-rouge">vagrant</code>. Теперь необходимо выполнить переход в папку <code class="language-plaintext highlighter-rouge">/vagrant</code>. Именно в ней окажется код проекта.</p>

<p>Дальше можно действовать по старинке. Поставить все необходимые пакеты и зависимости, а затем запустить проект. Если это веб-сайт, то он запустится на определенном порту. По умолчанию все, что стартует внутри виртуальной машины, доступно только внутри. Для возможности обращаться к сайту с хост машины (через ваш любимый браузер), необходимо прокинуть соответствующий порт наружу. Об этом достаточно подробно рассказано в <a href="https://www.vagrantup.com/docs/networking/basic_usage.html">документации</a>. Предположим, что внутри Vagrant сайт стартует на порту 8080, и вы хотите обращаться к нему снаружи. Для этого достаточно добавить в конфигурацию:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="no">Vagrant</span><span class="p">.</span><span class="nf">configure</span><span class="p">(</span><span class="s2">"2"</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="c1"># ...</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">vm</span><span class="p">.</span><span class="nf">network</span> <span class="s2">"forwarded_port"</span><span class="p">,</span> <span class="ss">guest: </span><span class="mi">8080</span><span class="p">,</span> <span class="ss">host: </span><span class="mi">8080</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Изменения применяются после перезагрузки машины. Для этого достаточно выполнить команду <code class="language-plaintext highlighter-rouge">vagrant reload</code>.</p>

<h3 id="остановка">Остановка</h3>

<p>В конце работы не забудьте выполнить <code class="language-plaintext highlighter-rouge">vagrant halt</code>, иначе машина останется запущенной и будет потреблять ресурсы. Если вы решили, что пора полностью все удалить и поставить заново, воспользуйтесь командой <code class="language-plaintext highlighter-rouge">vagrant destroy</code>.</p>

<h2 id="конфигурация-системы">Конфигурация системы</h2>

<p>Установка необходимых программ внутрь Vagrant традиционным способом — не самый лучший способ добиться повторяемости. По сути такой подход ничем не отличается от настройки проекта на основной системе. Для решения задачи настройки используются средства configuration management, подобные Ansible. Vagrant хорошо интегрируется с ними. Подробнее об этом можно прочитать в официальной <a href="https://www.vagrantup.com/docs/provisioning/">документации</a>, а в одном из репозиториев хекслета есть <a href="https://github.com/hexlet-boilerplates/vagrant-ansible">пример</a> такой интеграции.</p>

<h2 id="плагины">Плагины</h2>

<p>Vagrant может расширяться плагинами. Полный список можно найти на <a href="https://github.com/hashicorp/vagrant/wiki/Available-Vagrant-Plugins">wiki</a>.</p>

<p>Самый важный из этих плагинов - <a href="https://github.com/dotless-de/vagrant-vbguest">vagrant-vbguest</a>.</p>

<p>Не вдаваясь в подробности, он делает так, что ваша система всегда остается рабочей при обновлении виртуальной машины. Без него возможна ситуация, когда обновив виртуальную машину вы увидите, что папка с кодом перестала синхронизироваться, и внутри Vagrant её нет.</p>

<h2 id="решение-проблем">Решение проблем</h2>

<ul>
  <li>Убедитесь что в BIOS включены все необходимые параметры для нормального функционирования виртуализации.</li>
  <li>В Windows используйте имена пользователей, не содержащие кириллицы.</li>
  <li>Не запускайте Vagrant из под суперпользователя или администратора.</li>
  <li>Если вы испытываете проблемы со скоростью работы, то, возможно, причина в способе синхронизирования папки с проектом. Vagrant <a href="https://www.vagrantup.com/docs/synced-folders/">позволяет</a> настраивать способ синхронизации.</li>
</ul>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li><a href="https://ru.hexlet.io/courses/vagrant-basics">Vagrant: Основы</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/development-on-windows/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как начать разрабатывать в Windows</turbo:topic> -->
            <title>Как начать разрабатывать в Windows</title>
            <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/development-on-windows/">Как начать разрабатывать в Windows</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/development-on-windows/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>В руководстве приводится пример базовой настройки Windows, приближающей её по возможностям к другим операционным системам.</strong></p>

<p>Среда Windows не очень хорошо подходит для разработки, если вы не пишете под .net. Выражается это во многих аспектах: система не <a href="https://ru.wikipedia.org/wiki/POSIX">POSIX</a>-совместимая (а большинство библиотек пишется именно для таких систем, например linux или mac), в Windows нет примитивных средств, которые необходимы любому разработчику для комфортной работы.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<p>Несмотря на все написанное ниже, наша основная рекомендация — ставить Linux-дистрибутив, например, Ubuntu и полностью погружаться в него. Подавляющее большинство веб-проектов работает под управлением Linux-систем. А постоянное использование такой системы на домашнем и рабочем компьютере равносильно погружению в языковую среду при изучении иностранных языков.</p>

<h2 id="командная-строка">Командная строка</h2>

<p>Первое, к чему сразу нужно привыкать — командная строка. Работа на удаленных серверах, git, пакетные менеджеры и многое другое, всё это делается, в первую очередь, в командной строке. Хотя такой способ и непривычен для обычного пользователя, он имеет множество преимуществ перед использованием мыши. К ним относятся:</p>

<ul>
  <li>Скорость работы значительно возрастает и намного опережает оконные интерфейсы</li>
  <li>Легкая возможность автоматизации действий за счет скриптования. Другими словами, любые команды можно записать в файл и использовать его. Никаких специальных средств не требуется</li>
  <li>Гораздо более хорошее понимание происходящих процессов</li>
  <li>На серверах оконного интерфейса не бывает в принципе, так что тут без вариантов</li>
</ul>

<p>Если вы пользуетесь IDE, то, скорее всего, знаете, что они интегрируют внутри себя множество инструментов. И хотя местами такая интеграция удобна (не для всех), не стоит ей злоупотреблять в самом начале пути. Гораздо лучше научиться пользоваться чистыми инструментами для лучшего понимания происходящего. К тому же, вы не будете зависеть от среды и всегда будете ориентироваться на местности.</p>

<p>Под термином “командная строка” скрывается сразу несколько тесно связанных, но все же независимых инструментов: терминал и командная оболочка.</p>

<p><strong>Командная оболочка</strong> (shell, командный интерпретатор) — программа, позволяющая с помощью текстовых команд выполнять функции операционной системы и управлять другими программами. Например с помощью <em>shell</em> можно перемещаться по файловой системе и выполнять операции по созданию и удалению файлов. Сам по себе <em>shell</em> представляет из себя REPL (Read Eval Print Loop). Другими словами после запуска оболочки, появляется строка ввода в которую вводятся команды. После того как команда отработает, <em>shell</em> снова входит в режим ожидания ввода команд. Кстати у многих языков программирования есть свой собственный REPL, позволяющий в таком же стиле запускать код.</p>

<p>В Windows по умолчанию используется <code class="language-plaintext highlighter-rouge">command.com</code>, а в Linux — Bash. Кроме них существует множество других оболочек, но Bash — стандарт де-факто, и его нужно знать.</p>

<p>Чтобы запустить <em>shell</em> нужна еще одна программа — <strong>терминал</strong> (term, Terminal Emulator). Терминал — это и есть то самое окно, внутри которого запускается оболочка. Этот термин изначально использовался для отдельно стоящих монитора и клавиатуры, посредством которых можно было подключиться к мейнфрейму (большим многопользовательским компьютерам древности). Терминалы популярны и сейчас: те же банкоматы и устройства для пополнения денег на счетах всевозможных сервисов. Поэтому тот терминал, который представлен программой на наших компьютерах, называют эмулятором, ведь у него нет железной части.</p>

<p>Терминалов, как и оболочек существует множество. Разница заключается в том, какие возможности для удобной работы они предоставляют. Например, очень важно чтобы терминал поддерживал вкладки. Тогда очень сильно упрощается работа с большим количеством терминалов. Стандартный эмулятор в Windows не умеет работать ни с вкладками, ни с чем либо ещё. По сути, все что он делает — запускает <code class="language-plaintext highlighter-rouge">cmd.exe</code> и больше никак не участвует в процессе.</p>

<p>А вот что могут хорошие терминалы:</p>

<ul>
  <li>Вкладки</li>
  <li>Split Panes — разделение рабочей области на части</li>
  <li>Поиск</li>
  <li>Профили</li>
</ul>

<p>и многое другое.</p>

<p>В Windows часто бывает так, что терминал одновременно поставляется с командной оболочкой.</p>

<h2 id="основная-общая-конфигурация">Основная (общая) конфигурация</h2>

<h3 id="chocolatey">Chocolatey</h3>

<p>Пакетные менеджеры в средах, отличных от Windows — это основной способ установки программ и библиотек на компьютер. Если вам понадобится поставить Node.js, то достаточно сделать следующее:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>// mac
<span class="nv">$ </span>brew <span class="nb">install </span>node

// ubuntu
<span class="nv">$ </span>apt <span class="nb">install </span>node
</code></pre></div></div>

<p>Удобств в таком способе довольно много. Во-первых, не нужно бродить в поисках необходимого софта по всему интернету и тратить уйму времени. Во-вторых, всё, что можно набрать в командной строке автоматизируется. Другими словами, можно написать скрипт, который сам будет ставить всё, что нужно (подробнее смотрите <a href="https://www.ansible.com/">Ansible</a>).</p>

<p>Для Windows существует несколько пакетных менеджеров, но именно <a href="https://chocolatey.org/">Chocolatey</a> стал стандартом де-факто. Установка <em>choco</em> стоит из нескольких простых шагов, которые хорошо описаны в <a href="https://chocolatey.org/install">соответствующем разделе</a>.</p>

<p>В чем-то Chocolaty справляется даже лучше, чем brew или apt. С его помощью можно ставить не только специализированный софт (например, для программистов), но и любые программы вообще.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>choco <span class="nb">install </span>GoogleChrome
</code></pre></div></div>

<p>или, что тоже самое</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>cinst GoogleChrome
</code></pre></div></div>

<p>Список того, что можно поставить находится <a href="https://chocolatey.org/packages">здесь</a>.</p>

<p>В тексте ниже подразумевается, что вы установили Chocolatey и знаете как им пользоваться.</p>

<h3 id="терминалы">Терминалы</h3>

<h4 id="cmder-базируется-на-conemu">Cmder (базируется на ConEmu)</h4>

<p>Эмулятор, поставляющийся вместе с командной оболочкой <a href="https://git-for-windows.github.io/">Git Bash</a>. Его установка решает сразу две задачи. С одной стороны вы получаете продвинутый терминал, с другой, из коробки, эмулятор Bash (настоящий bash получить нельзя, он работает только в *NIX системах).</p>

<p>Запустите программу <code class="language-plaintext highlighter-rouge">cmd.exe</code> и выполните там следующую команду:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>choco <span class="nb">install </span>cmder
</code></pre></div></div>

<p>После установки Cmder всё остальное следует делать только из под него.</p>

<h4 id="mobaxterm">MobaXterm</h4>

<p>Альтернативный эмулятор, доступный по ссылке: <a href="https://mobaxterm.mobatek.net/">MobaXterm</a>. Также как и Cmder, из коробки поставляется с командной оболочкой. Бесплатен для домашнего использования.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>choco <span class="nb">install </span>mobaxterm
</code></pre></div></div>

<h4 id="hyperjs">Hyper.js</h4>

<p>Рассмотрен здесь для полноты картины. В отличие от предыдущих предоставляет только терминал. По умолчанию запускает внутри себя <code class="language-plaintext highlighter-rouge">cmd.exe</code>, но можно настроить на любую оболочку.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>choco <span class="nb">install </span>hyper
</code></pre></div></div>

<h2 id="ubuntu-for-windows">Ubuntu for Windows</h2>

<p>Ремарка для владельцев последних версий Windows. Microsoft интегрировала Ubuntu внутрь Windows. Особенности установки и включения этой интеграции зависят от конкретной версии Windows, но в целом это сводится к нажатию нескольких кнопок. Подробности можно найти в нашей <a href="https://guides.hexlet.io/ubuntu-linux-in-windows/">инструкции по установке Ubuntu Linux внутри Windows</a>.</p>

<h2 id="vagrant">Vagrant</h2>

<p><a href="https://www.vagrantup.com/">Vagrant</a> — программа, созданная для разворачивания окружения разработчика, работающая во всех основных операционных системах. Она работает совместно с одной из <a href="https://ru.wikipedia.org/wiki/Виртуализация">систем виртуализации</a> (например <a href="https://www.virtualbox.org/">VirtualBox</a>). Главное преимущество перед другими способами работы в Windows в том, что это не эмуляция, а полноценная виртуальная машина с Linux на борту.</p>

<p>Вагрант, в отличие от прямого использования виртуальной машины, дает множество полезностей для разработчика. Подробнее про преимущества и процесс установки читайте в <a href="/vagrant/">отдельном руководстве</a>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>choco <span class="nb">install </span>virtualBox
choco <span class="nb">install </span>vagrant
</code></pre></div></div>

<h2 id="babun-cygwin">Babun (Cygwin)</h2>

<p>Cygwin — программное обеспечение, эмулирующее среду Linux на Windows. С его помощью можно запускать программы, написанные под Linux. Конечно, у этого способа множество ограничений, но все же он лучше, чем ничего.</p>

<p>С Cygwin работать напрямую не очень удобно, поэтому был создан Babun. Это командная оболочка, построенная на Cygwin. В отличие от других вариантов, Babun поставляется с собственной экосистемой. Например, он включает в себя пакетный менеджер <em>pact</em>, что приводит к конфликту с Chocolatey.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$ </span>choco <span class="nb">install </span>babun
</code></pre></div></div>

<hr />

<p><em>Кирилл Мокевнин</em></p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/learning/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как учиться и справляться с негативными мыслями</turbo:topic> -->
            <title>Как учиться и справляться с негативными мыслями</title>
            <pubDate>Sun, 22 Oct 2017 00:00:00 +0000</pubDate>
            <author>Рахим Давлеткалиев</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/learning/">Как учиться и справляться с негативными мыслями</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/learning/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Если начать активные и регулярные физические тренировки, то в первое время тело будет сопротивляться: ноющая боль в мышцах, усталость, нежелание продолжать. Если выйти на пробежку впервые за годы, то организм чётко сообщит вам: «не нужно так делать». Это — естественная реакция. Эволюционный инструмент защиты от перегрузок и опасностей.</p>

<p>Любые занятия физкультурой или спортом учат людей справляться с этой реакцией и строить свои тренировки в балансе с организмом.</p>

<p>Если начать активные и регулярные ментальные тренировки (например, изучение программирования), то в первое время разум будет сопротивляться. У разума намного больше инструментов сопротивления, чем у мышц: он может рождать мысли о вашем неумении, о бесполезности действий, о том, что «это не моё, и лучше мне заняться чем-то другим», что «у меня не математический склад ума» и так далее.</p>

<p>Эта статья посвящена сопротивлению разума при столкновении с проблемами и преодолению этих проблем. Она состоит из четырех шагов:</p>

<ol>
  <li><strong>Осознание</strong>. Заметить, осознать, стать учёным.</li>
  <li><strong>Мышление</strong>. Понять, от чего зависит успех.</li>
  <li><strong>Открытость</strong>. Исключить одно из главных условий ступора.</li>
  <li><strong>Прогресс</strong>. Принять реалии процесса изучения.</li>
</ol>

<h2 id="шаг-1-осознание">Шаг 1: Осознание</h2>

<p>В первую очередь необходимо чётко заметить и осознать появляющееся сопротивление разума. Отнеситесь к своему телу и разуму как к научному эксперименту: они подают вам — наблюдателю — какие-то сигналы, они реагируют на действия и окружение.</p>

<p><img src="/assets/images/learning/learning_1.png" alt="Мысли и их разнообразие" /></p>

<p>Постарайтесь замечать или даже записывать условия, при которых возникают подобные мысли. На ментальное состояние влияет куча факторов, в том числе физическое состояние, рабочее окружение, сон, питание, стресс, цели, отношения с людьми и так далее.</p>

<p>Можно завести таблицу и записывать в ней параметр каждого дня: сколько спал, что делал, что ел, сколько читал, как расслаблялся и как в итоге прошёл очередной учебный сеанс.</p>

<p>Будет отлично, если вы сможете выявить параметры удачных и неудачных дней. Возможно, меньше 7 часов сна + встреча с кем-то до обеда практически всегда коррелируют с неудачами в учебе. Или физическая нагрузка и пониженное потребление сладкого коррелирует с удачными учебными сеансами. Возможно, здесь есть не просто корреляция, а причинно-следственная связь.</p>

<p>Проводите эксперименты и будьте учёным.</p>

<h2 id="шаг-2-мышление">Шаг 2: Мышление</h2>

<p><a href="https://en.wikipedia.org/wiki/Carol_Dweck">Кэрол Дуэк</a>, психолог из Стэнфорда, выявила два типа мышления у людей: фиксированное мышление (fixed mindset) и мышление роста (growth mindset).</p>

<p><img src="/assets/images/learning/learning_2.png" alt="Виды мышления" /></p>

<p>Под мышлением подразумевается набор установок, идей и концепций, которыми руководствуется разум.</p>

<p><strong>Фиксированное мышление</strong> характеризуются такими установками:</p>

<ul>
  <li>я такой, какой есть, и люди не меняются</li>
  <li>успех зависит от таланта</li>
  <li>люди делятся на чёткие категории: технари, гуманитарии, сильные и слабые, умные и глупые, и т.д.</li>
  <li>изменений и испытаний нужно избегать</li>
  <li>усилия обычно бесполезны</li>
  <li>нужно выбирать путь наименьшего сопротивления</li>
  <li>критика — это плохо</li>
  <li>о проблемах и неудачах стоит жаловаться</li>
</ul>

<p><strong>Мышление роста</strong> характеризуется такими установками:</p>

<ul>
  <li>я могу измениться если приложу усилия</li>
  <li>успех зависит от труда</li>
  <li>категории людей — это в лучшем случае приближенные описания текущего состояния и направления интересов, а не судьба</li>
  <li>изменения и испытания приветствуются — они позволяют расти</li>
  <li>усилия двигают вперед</li>
  <li>сопротивление и трудности — признаки роста</li>
  <li>критика — полезнейший источник информации</li>
  <li>жалобы не имеют смысла и отвлекают от реально ценного</li>
</ul>

<p>Можно заметить рекурсивную ловушку: фиксированное мышление заставляет человека думать, что его судьба — это фиксированное мышление, и измениться не получится.</p>

<p>Исследования типов мышлений приводят к интересному выводу: качество жизни и удовлетворение в большей степени зависят от субъективного отношения, а <em>не от таланта или интеллекта</em>. Иными словами, человек способен развить в себе мышление роста убеждениями и рациональными доказательствами.</p>

<p>Используйте ощущения сопротивления («наверное, это не для меня», «очевидно, что я не технарь…», «не стать мне программистом») как отправную точку в трансформации своего мышления.</p>

<p>Сопротивление, проблемы и неудачи никуда не денутся. У любого успешного специалиста в тысячи раз больше проблем и неудач, чем у бросившего путь новичка. Их отличает в первую очередь отношение к проблемам.</p>

<p>Сопротивление — это хорошо. Это признак роста. Не упустите возможность расти.</p>

<h2 id="шаг-3-открытость">Шаг 3: Открытость</h2>

<p>Забудьте миф о трудолюбивом гении, который закопался в библиотеке и вышел оттуда специалистом. Лучший способ попасть в перманентный ступор — изолироваться от других учащихся и от учителей.</p>

<p><img src="/assets/images/learning/learning_3.png" alt="Процесс обучения" /></p>

<ol>
  <li><strong>Задавайте вопросы</strong>. Если вы изучаете программирование на Хекслете, то вы получите ответ в любом случае — наши менторы закрывают все вопросы во всех уроках. А сам факт формулирования вопроса зачастую помогает разложить все по полочкам в вашем сознании и приблизить к решению. Абстрактная проблема в голове и сформулированная текстом — разные вещи.</li>
  <li><strong>Общайтесь</strong>. Можно называть себя экстравертом или интровертом, но общение в разной степени требуется всем, и это особенно важно в обучении. Очень полезно видеть других людей с подобными вашим проблемами, их прогресс и опыт. В Хекслете для этого есть большой <a href="https://slack-ru.hexlet.io/">дружелюбный чат</a>.</li>
  <li><strong>Принимайте и делитесь опытом</strong>. Найдите людей в схожих ситуациях и условиях. Кто-то прямо сейчас так же, как вы, пытается изучить программирование или новый язык. Кто-то испытывает похожие трудности. Почитайте, к примеру, блог <a href="https://medium.com/@sayoBye">Альберта</a> об изучении программирования. Подумайте о том, чтобы завести свой блог.</li>
</ol>

<h2 id="шаг-4-прогресс">Шаг 4: Прогресс</h2>

<p>Процесс изучения новой области временами может казаться слишком медленным или даже бесконечным. В эссе «<a href="https://rakh.im/learning/">Процесс изучения</a>» я рассказал о полезной аналогии, описывающей процесс изучения новых тем. Советую прочитать его чтобы разобраться с подобными проблемами:</p>

<ul>
  <li>С какой книги начать?</li>
  <li>Вот я вроде понял каждую тему по отдельности, но как они связаны – не понимаю. И зачем это вообще изучал – не пойму.</li>
  <li>Изучаю-изучаю, но все равно ничего не понятно!</li>
</ul>

<p><img src="/assets/images/learning/learning_4.png" alt="Пазлы" /></p>

<p>Также советую прочитать статью Кирилла Мокевнина об <a href="https://ru.hexlet.io/blog/posts/how-to-read-books">эффективном чтении профессиональной литературы</a>.</p>

<p>Временное отсутствие видимого прогресса — это нормально, но продолжительное отсутствие прогресса — признак фундаментальных проблем. Например, если после полугода обучения основам программирования вы все еще не можете написать и запустить простую программу — пора вносить изменения в условия и процесс обучения. Попытайтесь как можно скорее (не обязательно успешно!) создать собственный проект, приложение, сайт и так далее.</p>

<p>Хорошая стратегия — следить за прогрессом, записывая проблемы и успехи в дневник. Время от времени заглядывайте в прошлое и сравнивайте. Если прошлые проблемы вам кажутся немного смешными или вам даже слегка <a href="https://hello.rakh.im/how_to_evaluate_personal_growth/">стыдно</a> — супер. Вы очевидно выросли. Если старые проблемы никуда не ушли, то стоит изменить подход, условия и инструменты обучения.</p>

<p>Как это часто бывает, все подобные темы можно свести к короткому древнегреческому изречению: γνῶθι σεαυτόν — <strong>познай себя</strong>.</p>

<h2 id="литература">Литература</h2>

<p>Советую эти книги если вам интересна тема:</p>

<ol>
  <li><a href="https://www.mann-ivanov-ferber.ru/books/mif/mindset/">Кэрол Дуэк, «Гибкое сознание»</a>. Новый взгляд на психологию развития взрослых и детей.</li>
  <li><a href="https://www.ozon.ru/context/detail/id/6233608/?partner=hexlet">Михай Чиксентмихайи, «Поток. Психология оптимального переживания»</a>. Подход к проблемам эмоциональной жизни человека и регуляции поведения.</li>
  <li><a href="https://www.ozon.ru/context/detail/id/10512826/?partner=hexlet">Виктор Франкл, «Человек в поисках смысла»</a></li>
</ol>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/how-to-search/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как искать техническую информацию</turbo:topic> -->
            <title>Как искать техническую информацию</title>
            <pubDate>Tue, 03 Oct 2017 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/how-to-search/">Как искать техническую информацию</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/how-to-search/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>Поиск ответов на вопросы и решение проблем с помощью Гугла — важнейший навык для программиста. Большинство проблем, с которыми сталкивается новичок, уже решены и описаны. Нужно лишь научиться находить эти решения и ответы.</strong></p>

<h2 id="сайты">Сайты</h2>

<p>Основные сайты с ответами на вопросы:</p>

<ul>
  <li><a href="https://github.com">GitHub</a></li>
  <li><a href="https://stackoverflow.com">Stackoverflow</a></li>
</ul>

<h2 id="язык">Язык</h2>

<p>Как показывает практика, в самом начале своего пути немалая часть программистов пытается найти ответы, задавая вопросы поисковой системе на русском языке. Иногда так можно найти ответ, но в большинстве случаев — нет. <strong>Главный язык программистов — английский</strong>, весь мир говорит именно на нем. Количество информации в англоязычном сегменте на порядки больше, чем в русскоязычном. К тому же она свежее. Учитесь формулировать свои мысли, а в случае поиска — набор слов, на английском. Заодно быстрее изучите терминологию.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.code-basics.com/?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Code Basics: бесплатные курсы программирования
</a>
</div>

<h2 id="поисковая-система">Поисковая система</h2>

<p>Связано с предыдущим пунктом. Искать нужно в Гугле. Яндекс хоть и хорош для определенных задач, все же англоязычный сегмент — не его основной рынок, и там он значительно уступает Гуглу. Например, вы заметите, что через некоторое время Гугл адаптируется к вашим запросам и начнет показывать более релевантные ссылки. Он вполне способен понять, какой язык программирования вы предпочитаете, чтобы показывать ответы, применимые именно к нему.</p>

<p>Еще один важный момент. Гугл даже лучше, чем специфические поиски конкретных сайтов. Если вам нужно что-то на том же Гитхабе, то лучше сформировать правильный запрос в Гугле и получить результат лучше и быстрее. Ниже, в разделе «язык запросов» об этом рассказано подробнее.</p>

<h2 id="язык-запросов">Язык запросов</h2>

<p>Каждая поисковая система обладает языком запросов. В него входят специальные операторы, позволяющие более точно указать то, что вы хотите. Вот некоторые важные возможности:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">site:stackoverflow.com how to test react code</code> — поиск будет произведен среди страниц сайта <a href="https://stackoverflow.com/">Stackoverflow</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">add class to element -jquery</code> — дефисом обозначаются стоп-слова, то есть будут найдены все варианты, в которых эти слова не упоминаются.</li>
  <li><code class="language-plaintext highlighter-rouge">"immutable js"</code> — двойные кавычки указывают на то, что нужно искать точное совпадение.</li>
</ul>

<p>Полный список можно найти <a href="https://support.google.com/websearch/answer/2466433?visit_id=1-636424030566191968-2246914586&amp;p=adv_operators&amp;hl=en&amp;rd=1">на сайте поддержки Гугл</a>.</p>

<h2 id="поиск-библиотек">Поиск библиотек</h2>

<p>Подавляющее большинство библиотек находятся (говорят, «хостятся») на <a href="https://github.com">Гитхабе</a>. Предположим, понадобилось найти библиотеку для выполнения HTTP-запросов в JavaScript. Для этого можно сформировать следующий запрос: <code class="language-plaintext highlighter-rouge">github js http client</code>. Гугл выдаст десяток ссылок на разные репозитории. Конечно, можно использовать и язык запросов: <code class="language-plaintext highlighter-rouge">site:github.com js http client</code>, но чаще всего достаточно просто указать <code class="language-plaintext highlighter-rouge">github</code>.</p>

<p>Точно такая же стратегия поиска может использоваться для библиотек с известным названием: <code class="language-plaintext highlighter-rouge">github express</code>.</p>

<h2 id="поиск-по-сообщению-об-ошибке">Поиск по сообщению об ошибке</h2>

<p>Перед тем, как искать по сообщению об ошибке, нужно понять, где же тут <em>сообщение об ошибке</em>. Часто вывод с ошибками содержит много информации, которая хоть и относится к делу, но не является описанием той самой ошибки. Пример:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="syntax"><code>There was 1 failure:

1<span class="o">)</span> App<span class="se">\S</span>olutionTest::testResult with data <span class="nb">set</span> <span class="c">#2 (0, 2, 2, 1, 2)</span>
Failed asserting that <span class="s1">'1'</span> matches expected 0.

/usr/src/app/tests/App/Tests/SolutionTest.php:15

FAILURES!
Tests: 3, Assertions: 3, Failures: 1.
Makefile:2: recipe <span class="k">for </span>target <span class="s1">'test'</span> failed
make: Leaving directory <span class="s1">'/usr/src/app'</span>
make: <span class="k">***</span> <span class="o">[</span><span class="nb">test</span><span class="o">]</span> Error 1
</code></pre></div></div>

<p>В этом выводе много текста, но реальное сообщение об ошибке только одно: <code class="language-plaintext highlighter-rouge">Failed asserting that '1' matches expected 0.</code>. Конкретно в этом случае примерно понятно, что не так и куда смотреть (в стектрейсе ниже указан файл и строчка). Но так бывает далеко не всегда. Если вам удалось точно идентифицировать сообщение об ошибке, то не лишним будет сделать еще кое-что. Часто подобные сообщения индивидуальны. В них подставляются конкретные значения каких-то параметров, относящихся именно к вашему окружению. Например, пути до файлов. Соответственно, если вы будете искать по всему тексту ошибки, то скорее всего Гугл ничего не найдет. Например, в сообщении выше такими параметрами являются <code class="language-plaintext highlighter-rouge">'1'</code> и <code class="language-plaintext highlighter-rouge">0</code>. Если очистить фразу, то получится <code class="language-plaintext highlighter-rouge">Failed asserting that matches expected</code>. Именно её и надо искать. Не лишним бывает добавить имя языка: <code class="language-plaintext highlighter-rouge">php Failed asserting that matches expected</code>.</p>

<h2 id="поиск-по-поведению">Поиск по поведению</h2>

<p>Нередко сообщение об ошибке либо отсутствует, либо не может привести к правильному ответу (потому что оно — следствие, а не причина). В этой ситуации нужно проявить креативность и составить предложение на английском языке. Набор ключевых слов тоже подойдет. Если поиск не увенчался успехом, то к поисковой фразе полезно добавить <code class="language-plaintext highlighter-rouge">site:stackoverflow.com</code>. Stackoverflow — место, где есть ответы практически на все подобные вопросы.</p>

<p>Если известно, к какой библиотеке или программе относится ошибка, то полезно найти её репозиторий на Гитхабе и поизучать раздел Issues. Если ошибка действительно есть, и она актуальная, то почти наверняка о ней уже кто-то отписался.</p>

<h2 id="официальная-документация">Официальная документация</h2>

<p>Поиск — это хорошо, но никогда не забывайте про официальную документацию используемых инструментов (в том числе языков программирования). Официальная (и не только) документация, как правило, делится на несколько видов:</p>

<ol>
  <li><a href="https://guides.rubyonrails.org/getting_started.html">Getting Started</a> — небольшое (не всегда) пошаговое руководство по созданию минимально рабочей версии. Первым делом нужно искать именно этот документ. Он позволяет быстро стартануть чтобы посмотреть инструмент в деле.</li>
  <li><a href="https://laravel.com/docs/5.5/routing">Guides</a> — описания компонентов рассматриваемого инструмента. Написаны в повествовательной манере, что позволяет их прочитывать от и до. По гайдам удобно изучать большие блоки.</li>
  <li><a href="https://bit.ly/2uq98XM">API</a> — сухая документация по всем возможным функциям приложения. В нее имеет смысл смотреть только для поиска ответов на конкретные вопросы.</li>
  <li><a href="https://blog.codeship.com/an-introduction-to-apis-with-phoenix/">Tutorials</a> — в отличие от гайдов, направлены на различные варианты использования инструмента.</li>
</ol>

<hr />

<p><em>Кирилл Мокевнин</em></p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/typing/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Как научиться слепой печати на клавиатуре</turbo:topic> -->
            <title>Как научиться слепой печати на клавиатуре</title>
            <pubDate>Fri, 22 Sep 2017 00:00:00 +0000</pubDate>
            <author>Кирилл Мокевнин</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/typing/">Как научиться слепой печати на клавиатуре</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/typing/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>Слепой метод набора — способ эффективно набирать текст десятью пальцами не глядя на клавиатуру.</strong></p>

<h2 id="зачем-нужна-слепая-печать">Зачем нужна слепая печать?</h2>

<p>Слепой набор позволяет не думать о процессе печати и сосредоточиться на тексте и своих мыслях. Также:</p>

<ul>
  <li>Хорошая техника позволяет сократить количество ошибок</li>
  <li>С опытом скорость набора текста станет выше</li>
  <li>При необходимости достаточно легко учатся новые алфавиты</li>
</ul>

<h2 id="как-это-работает">Как это работает?</h2>

<p>Слепой набор включает в себя несколько важных компонентов:</p>

<h3 id="постановка-рук">Постановка рук</h3>

<p><img src="/assets/images/typing/keyboard_bumps.jpg" alt="Выпирающие полоски на клавишах F и J" /></p>

<p>Выпирающие полоски на клавишах F и J — это специальные метки, показывающие место для указательных пальцев в состоянии покоя.</p>

<p><img src="/assets/images/typing/keyboard_scheme.jpg" alt="Как правильно держать руки" /></p>

<p>Постановка рук — это первое с чего начинают практику слепого набора.</p>

<h3 id="набор">Набор</h3>

<p>В слепом наборе у каждого пальца есть своя зона на клавиатуре. Только соответствующий палец может нажимать клавиши своей зоны. Это особенно сложное ограничение для тех, кто уже постоянно и активно печатает, так как требует от человека изменения привычек.</p>

<p>К сожалению, стандартные клавиатуры сделаны так, что большая нагрузка выпадает на мизинцы, особенно на правый мизинец у программистов. У эргономичных клавиатур управляющие клавиши часто выносят под большие пальцы, так как они недозагружены и, в целом, более сильные и подвижные по сравнению с мизинцами.</p>

<p><img src="/assets/images/typing/microsoft_sculpt_ergo.jpg" alt="Пример эргономичной клавиатуры" /></p>

<h3 id="чередование">Чередование</h3>

<p>Наиболее эффективный набор в слепом режиме происходит когда пальцы постоянно чередуются. Попробуйте проверить это сами. Наберите слово “папа” указательным пальцем левой руки (эти буквы находятся в его зоне), а затем слово “гага” (указательные пальцы обоих рук).</p>

<p>Большинство раскладок проектировалось с учетом этого фактора, например, раскладка ЙЦУКЕН. А вот QWERTY создавалась слишком давно, когда приходилось учитывать другие факторы (например, залипание клавиш), и это отразилось на эффективности. Поэтому были созданы альтернативные раскладки, такие как DVORAK и Colemak. Вот что написано в Википедии по поводу последней:</p>

<ul>
  <li>Скорость. Быстрее QWERTY и несколько быстрее Дворака, так как в Colemak разгружены мизинцы и чаще применяется чередование рук.</li>
  <li>Эргономичность. 10 наиболее распространённых букв английского языка и клавиша Backspace расположены на втором (домашнем) ряду клавиатуры. В Colemak домашний ряд используется в среднем на 3 % чаще, чем в раскладке Дворака, и 40 % чаще, чем в QWERTY. Благодаря этому при печати на Colemak пальцам приходится меньше перемещаться, чем при печати на QWERTY.</li>
</ul>

<p>Но чередование — это не только раскладка, но и техника. Пробел лежит сразу под двумя большими пальцами, а значит у нас есть выбор пальца для нажатия. В слепой печати пробел должен нажиматься большим пальцем той руки, которая не была задействована в нажатии предыдущего символа. Например, если мы набираем слово “код”, то пробел после него нажимается левой рукой, если слово “моя”, то правой.</p>

<h2 id="как-научиться">Как научиться?</h2>

<p>Можно и самостоятельно, просто следуя правилам выше. Но с большой долей вероятности процент ошибок во время набора будет высок, и в процессе обучения, и после. Специализированные сервисы помогают учиться печатать с минимальным числом ошибок. Подобных сервисов много, и вам стоит найти их в Гугле и попробовать разные варианты (в комментариях ниже читатели делятся ссылками).</p>

<p>Основным препятствием является не столько отсутствие времени на обучение, сколько работа, связанная с набором текста. Так как в этом случае для быстрого печатания приходится делать это привычным способом. Главное после некоторой практики на тренажерах заставить себя полностью отказаться от набора старым способом и нажимать клавиши только теми пальцами, которыми того требует слепой набор. Причем совершенно нормально, если вы будете подсматривать на клавиатуру. Техника заключается не в том, чтобы не смотреть, а в том, чтобы правильно перемещаться по клавиатуре. Со временем необходимость смотреть отпадет. И да, скорость при этом упадет катастрофически, но не волнуйтесь, восстановится она очень быстро, уже через пару недель вы, вероятно, догоните себя прежнего, а затем начнете двигаться вперед.</p>

<h2 id="сколько-времени-потребуется">Сколько времени потребуется?</h2>

<p>Зависит от многих факторов, но, в среднем, можно научиться основам за пару недель и стать эффективным за пару месяцев.</p>

<h2 id="как-попробовать-прямо-сейчас">Как попробовать прямо сейчас?</h2>

<ul>
  <li><a href="https://github.com/Hexlet/interactive-courses#%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0-%D1%81%D0%BB%D0%B5%D0%BF%D0%BE%D0%B9-%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%B8">Подборка бесплатных сервисов для прокачки слепой печати от сообщества Хекслета</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/ssh/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое протокол SSH</turbo:topic> -->
            <title>Что такое протокол SSH</title>
            <pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate>
            <author>Рахим Давлеткалиев</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/ssh/">Что такое протокол SSH</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/ssh/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>SSH — защищенный протокол для удаленного доступа к компьютерам. Через SSH можно выполнять операции в командной строке компьютера, который физически находится в другом месте.</strong></p>

<p>Иными словами, SSH — это дистанционная командная строка. Визуально вы работаете на своем компьютере, но в реальности — на другом.</p>

<h2 id="что-значит-протокол">Что значит «протокол»?</h2>

<p>Протокол — это набор соглашений, правил, по которым разные программы могут обмениваться информацией. SSH — это набор правил, который известен и вашему компьютеру, и физически отдаленному компьютеру.</p>

<blockquote>
  <p><strong>Пример</strong>: вы вводите команду удаления файла, и эта команда передается на другой компьютер и выполняется там. Ответ (или сообщение об ошибке) возвращается и показывается на вашем компьютере.</p>
</blockquote>

<h2 id="что-значит-защищенный">Что значит «защищенный»?</h2>

<p>Вся информация передается в зашифрованном виде. Подобно тому, как некоторые сайты работают по HTTPS, шифруя информацию. Например, ваш онлайн-банкинг обязательно должен работать по защищенному соединению. В таком случае даже если всю информацию перехватывает злоумышленник, он не сможет расшифровать её.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/devops-for-programmers?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: Девопс для программистов. Вся база за 3 месяца
</a>
</div>

<h2 id="для-чего-нужен-ssh">Для чего нужен SSH?</h2>

<p>Не всегда есть возможность физически находиться у компьютера, с которым нужно работать. Например, если вы хотите создать свой сайт, то он будет размещен на компьютере хостинг-провайдера. Этот компьютер может находиться на другом конце света. Вам нужен способ запускать команды на этом компьютере не выходя из своего дома.</p>

<h2 id="как-подключаться-по-ssh">Как подключаться по SSH?</h2>

<p>Для подключения к удаленной машине по SSH нужен клиент — специальная программа. В *nix-подобных системах (Linux, macOS) клиент обычно установлен в системе по умолчанию, и достаточно открыть терминал.</p>

<p>Для подключения нужно указать адрес сервера и, опционально, имя пользователя и порт. Вот как выглядит команда при использовании консольного клиента (в терминале):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ssh username@remote_host <span class="nt">-p</span> port
</code></pre></div></div>

<p>Например, для подключения к серверу <code class="language-plaintext highlighter-rouge">52.307.149.244</code> в аккаунт <code class="language-plaintext highlighter-rouge">ivan</code> нужно ввести:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ssh ivan@52.307.149.244
</code></pre></div></div>

<p>Если не указывать порт, то будет использован порт SSH по умолчанию — <code class="language-plaintext highlighter-rouge">22</code>. Используемый порт задается при настройке SSH-сервера, программы, которая запущена на удаленном компьютере и ожидает подключения извне.</p>

<h3 id="fingerprint">Fingerprint</h3>

<p>При первом подключении появится сообщение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>The authenticity of host '52.307.149.244 (52.307.149.244)' can't be established.
ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
Are you sure you want to continue connecting (yes/no)? yes
</code></pre></div></div>

<p>Введите <code class="language-plaintext highlighter-rouge">yes</code> в первый раз.</p>

<p>Это нужно для повышения безопасности. При настройке SSH-сервера создается уникальная комбинация символов — fingerprint («отпечатки пальцев»). Ваш компьютер запоминает эту комбинацию и сверяет ее при каждом новом соединении. Если кто-то переустановит SSH-сервер, или всю операционную систему, или вообще заменит удаленный компьютер, сохранив его адрес, то при следующем соединении вы узнаете об этом, потому что изменится fingerprint.</p>

<p>Если fingerprint не меняется, то такое сообщение не будет появляться.</p>

<h2 id="подключение-по-ssh-по-паролю">Подключение по SSH по паролю</h2>

<p>Простейший вариант — подключение по паролю. После ввода команды <code class="language-plaintext highlighter-rouge">ssh</code> система запросит пароль:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ivan@52.307.149.244's password:
</code></pre></div></div>

<p>Пароль придется вводить каждый раз.</p>

<h2 id="подключение-по-ssh-по-ключу-без-пароля">Подключение по SSH по ключу, без пароля</h2>

<p>Для удобного подключения по SSH (и многим другим сервисам) без ввода пароля можно использовать ключи.</p>

<p>Нужно создать пару ключей: <strong>приватный</strong> (закрытый) ключ и <strong>публичный</strong> (открытый) ключ. Приватный ключ нужно хранить и никогда никому не показывать. Публичный ключ можно показывать всем и распространять свободно.</p>

<p>Эти <em>ключи связаны друг с другом</em> таким образом, что зашифровав информацию одним ключом, расшифровать ее можно только другим. Например, если ваш друг зашифрует письмо вашим публичным ключом, то прочитать его сможете только вы, потому что для этого нужен ваш приватный ключ. И наоборот: если вы зашифруете что-то своим приватным ключом, то расшифровать его можно только вашим публичным ключом. Так как публичный ключ доступен всем, любой может расшифровать это сообщение. Но он может быть уверен, что сообщение пришло именно от вас. В этом заключается идея цифровой подписи.</p>

<h3 id="генерация-ключей">Генерация ключей</h3>

<p>Создадим пару ключей:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ssh-keygen
</code></pre></div></div>

<p>Программа запустится и спросит, куда сохранять ключи:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Generating public/private rsa key pair.
Enter file in which to save the key (/home/demo/.ssh/id_rsa):
</code></pre></div></div>

<p>Нажмите Enter для сохранения в стандартное место — директорию <em>.ssh/id_rsa</em> в вашей домашней директории.</p>

<p>Программа запросит passphrase. Это вроде пароля для ключа. Можно просто нажать Enter и пропустить этот шаг. Или ввести passphrase — тогда его нужно будет вводить каждый раз, когда используется ключ.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Enter passphrase (empty for no passphrase):
Enter same passphrase again:
</code></pre></div></div>

<p>Ключи созданы:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Your identification has been saved in /home/demo/.ssh/id_rsa.
Your public key has been saved in /home/demo/.ssh/id_rsa.pub.
The key fingerprint is:
8c:e9:7c:fa:bf:c4:e5:9c:c9:b8:60:1f:fe:1c:d3:8a root@here
The key's randomart image is:
+--[ RSA 2048]----+
|                 |
|                 |
|                 |
|       +         |
|      o S   .    |
|     o   . * +   |
|      o + = O .  |
|       + = = +   |
|      ....Eo+    |
+-----------------+
</code></pre></div></div>

<p>Теперь у вас есть два файла:</p>

<ul>
  <li><em>~/.ssh/id_rsa</em> — приватный ключ. <strong>Никогда никому и никуда не передавайте его!</strong></li>
  <li><em>~/.ssh/id_rsa.pub</em> — публичный ключ. Спокойно распространяйте его.</li>
</ul>

<p>В Windows можно использовать <code class="language-plaintext highlighter-rouge">ssh-gen</code> в подсистеме Ubuntu for Windows или в командной строке Git for Windows.</p>

<h3 id="загрузка-публичного-ключа-на-сервер">Загрузка публичного ключа на сервер</h3>

<p>Нужно добавить публичный ключ на сервер в файл <em>~/.ssh/authorized_keys</em>. Самый простой способ — запустить на локальной машине команду для копирования ключа:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ssh-copy-id <span class="nt">-i</span> /home/demo/.ssh/id_rsa.pub ivan@52.307.149.244
</code></pre></div></div>

<p>Другой способ — подключиться по паролю, открыть в редакторе файл <em>~/.ssh/authorized_keys</em> и добавить в конец текст из вашего файла <em>~/.ssh/id_rsa.pub</em>.</p>

<p>Теперь при подключении пароль запрашиваться не будет<sup>1</sup>.</p>

<p>После включения соединений по ключу <strong>рекомендуется отключить подключение по паролю</strong>.</p>

<h2 id="ssh-agent">ssh-agent</h2>

<p>При работе с ключами возможны две неудобные ситуации:</p>

<ol>
  <li>Если при создании ключа вы указали passphrase (пароль для ключа), то вам придется вводить пароль при каждом подключении.</li>
  <li>Если у вас есть несколько ключей для разных целей, то при соединении по <code class="language-plaintext highlighter-rouge">ssh</code> придется указывать нужный ключ вручную</li>
</ol>

<p>ssh-agent решает эти проблемы. Этот агент аутентификации (authentication agent) работает на фоне в *nix-системах. В зависимости от системы, вам, возможно, придется установить и настроить его автозапуск самостоятельно.</p>

<p>Если добавить ключ к агенту, то:</p>

<ol>
  <li>для него больше не будет спрашиваться passphrase</li>
  <li>не нужно будет вводить ключ вручную — он будет автоматически использован при соответствующем подключении</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">ssh-add /home/demo/.ssh/id_rsa</code> добавит ключ <em>id_rsa</em> в запущенный в системе агент. Если у него есть passphrase, то агент попросит ввести его.</p>

<p>Если запустить <code class="language-plaintext highlighter-rouge">ssh-add</code> без аргументов, то будут добавлены ключи <em>~/.ssh/id_rsa</em>, <em>~/.ssh/id_dsa</em>, <em>~/.ssh/id_ecdsa</em>, <em>~/.ssh/id_ed25519</em> и <em>~/.ssh/identity</em>.</p>

<p>Список добавленных в агент ключей можно посмотреть командой <code class="language-plaintext highlighter-rouge">ssh-add -L</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>→ ssh-add <span class="nt">-L</span>
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC91r/+5WEQHcxVMrxpP9jKuONjlrnEHshfG3v/ab2NKDSljdskODOIsdhaaoDoiSADhAaoDISHasoiDiASisjadOHISDdKJDASHSidshIHDSIHDIAsdjasAs7XG/drBhi16zQ2e8VcLD7bVQS1Cpo0O1tP+93YQBvcIE02RltqVKYo7BlgCaJzpdowK8fHSzpfCYsEFjdjosOjfdsjdjkAJOKkKKHJHhaIiAiaihsiIoqkpqdmlnvnuuUSCaAS8aDhajiadiiAahhakKAKDHAKurmD08jnX9HfH/d15pLK/Glo1Su6iEOU3bW8k92QlY54pPFLKiNRPFuUryE5md7T /Users/demo/.ssh/some_key.pem
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAsLC9WpSZ/9YpQ2z1FTSsORcP+ohzCdVjYaoc3C0fRnUbkp4SnvMHFTHNFFod0FhV0cQcOLvBsZAK/0tUPIXeDDFvYD70r5i0AsQbqA0k7gK3b3MP7tmnPxMHd607TI+1FMO54Yig0vnpZOgKmgCsxWq6tckwyLB91BlPiGxLBZiu5yPDIguEQCSnAwkF0vjqrNGsoHB4+fkj0USfjiifsjihf39hifSIHiJFHSijshfj39jfsjisfiisfiissr893IFsifijfsjSOIiAShadfhssU0q0JpjaDEWcMmYXmuz3xSnbhkueGLBXMU2zXDFDWCDSHq9/oRr29UAfVaHAMw<span class="o">==</span> /Users/demo/.ssh/id_rsa
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ssh-agent</code> привязан к сессии. Поэтому, например, если перезагрузить компьютер, то ключи нужно будет добавлять в агент заново.</p>

<h2 id="форвардинг-проброс-ключей">Форвардинг (проброс) ключей</h2>

<p>Если вы подключились к удаленному серверу <strong>X</strong>, и с него хотите подключиться к другому серверу <strong>Y</strong>, например, чтобы сделать <code class="language-plaintext highlighter-rouge">git pull</code> с GitHub’а, то придется держать копию ваших ключей на сервере <strong>X</strong>.</p>

<p>Утилита <code class="language-plaintext highlighter-rouge">ssh</code> с флагом <code class="language-plaintext highlighter-rouge">-A</code> позволяет «пробросить» ключи с подключаемой машины в удаленную:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="syntax"><code>ssh <span class="nt">-A</span> ivan@52.307.149.244
</code></pre></div></div>

<p>Ключи, добавленные к агенту аутентификации (ssh-agent) станут доступными на удаленном сервере. При этом файлы-ключи физически не будут находиться на сервере.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ol>
  <li><a href="https://www.youtube.com/watch?v=sbVYRf_6Hvg">Основы SSH / Видео на канале Хекслета</a></li>
  <li><a href="https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys">SSH Essentials: Working with SSH Servers, Clients, and Keys</a></li>
  <li><a href="https://habrahabr.ru/post/122445/">Памятка пользователям ssh</a></li>
</ol>

<hr />

<ol>
  <li>Возможность и специфика подключения по ключу зависит от настроек SSH-сервера. Возможно такое, что подключение по ключу запрещено администратором.</li>
</ol>

<hr />

<p><em>Рахим Давлеткалиев</em></p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/markdown/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Что такое Markdown</turbo:topic> -->
            <title>Что такое Markdown</title>
            <pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate>
            <author>Рахим Давлеткалиев</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/markdown/">Что такое Markdown</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/markdown/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p><strong>Markdown — язык разметки текстов. Такие тексты легко писать и читать. Их можно без труда сконвертировать в HTML. Большинство программистов предпочитают Markdown для написания документации, описаний своих проектов, написания блогов и так далее.</strong></p>

<h2 id="что-это-значит">Что это значит?</h2>

<p>«Язык разметки» — это просто набор соглашений, правил.</p>

<p>Допустим, что вы общаетесь с другом по СМС. В них нельзя сделать текст жирным или наклонным. Вы договариваетесь с другом: если я пишу <code class="language-plaintext highlighter-rouge">*что-то*</code> вот так между звездочками, то считай, что это наклонный текст. А если я пишу <code class="language-plaintext highlighter-rouge">**что-то**</code> между двумя звездочками, то считай, что это жирный текст. Вы придумали <em>правила</em>.</p>

<p>Markdown — это набор подобных правил.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/layout-designer-basics?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Интенсив: «Верстка веб-приложений». Вся база за 2 месяца
</a>
</div>

<p>Правила понятны разным программам и сайтам. Например, «Вопросы и ответы» в уроках на Хекслете поддерживают Markdown. Это значит, что вы можете писать туда тексты по правилам Markdown, а после нажатия «Отправить» разметка станет реальной: текст в одинарных звездочках станет наклонным, текст в двойных звездочках станет жирным и так далее. Это конвертация из Markdown в HTML.</p>

<h2 id="зачем-это-нужно">Зачем это нужно?</h2>

<ol>
  <li>Для добавления разметки туда, где невозможна реальная разметка. Например, в простом текстовом файле или в тех же СМС, где невозможно выделение жирным, создание заголовков, выделение цитат и пр.</li>
  <li>Для более удобного написания текстов для последующей конвертации в HTML или другие форматы.</li>
</ol>

<h2 id="синтаксис-markdown">Синтаксис Markdown</h2>

<p>Это краткий справочник основных элементов синтаксиса Markdown. Единого стандарта не существует и разные версии Markdown могут отличаться в деталях. Но базовые элементы из списка ниже поддерживаются во всех стандартах.</p>

<h3 id="выделение-текста">Выделение текста</h3>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="ge">*Этот текст будет наклонным (курсив)*</span>
<span class="ge">_Этот текст будет наклонным (курсив)_</span>

<span class="gs">**Этот текст будет жирным**</span>
<span class="gs">__Этот текст будет жирным__</span>

<span class="ge">_Можно **вставлять** один тип в другой_</span>
</code></pre></div></div>

<h3 id="заголовки">Заголовки</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code># Это самый крупный заголовок, он превращается в тег &lt;h1&gt;
## &lt;h2&gt;
### &lt;h3&gt;
#### &lt;h4&gt;
##### &lt;h5&gt;
###### &lt;h6&gt;
</code></pre></div></div>

<h3 id="ссылки">Ссылки</h3>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code>https://hexlet.io — текст простой ссылки станет кликабельной ссылкой автоматически
</code></pre></div></div>

<p>Ссылкой можно сделать любой текст:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">[</span><span class="nv">Это ссылка на Хекслет</span><span class="p">](</span><span class="sx">https://hexlet.io</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="цитата">Цитата</h3>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="gt">&gt; Это мудрая цитата</span>
<span class="gt">&gt; Мудрого человека.</span>
</code></pre></div></div>

<h3 id="картинки">Картинки</h3>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">![</span><span class="nv">Это опциональный alt-текст</span><span class="p">](</span><span class="sx">/assets/images/markdown/markdown.png</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="код">Код</h3>

<p>Для выделения кода (или любого неотформатированного текста) используются специальные символы — обратные тики: <code class="language-plaintext highlighter-rouge">`</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="syntax"><code>Иногда нужно добавить кусок кода `function(12);` в обычную строчку текста.
</code></pre></div></div>

<pre><code>А иногда нужно вставить целый блок кода:

&#96;&#96;&#96;javascript
const func = (num) =&gt; {
  if (num &gt; 0) {
    return num - 1;
  }
  return num + 1;
};
&#96;&#96;&#96;
</code></pre>

<h3 id="списки">Списки</h3>

<p>Непронумерованный список:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">*</span> Пункт
<span class="p">*</span> Еще один пункт
<span class="p">  *</span> Подпункт
<span class="p">  *</span> Еще один подпункт
</code></pre></div></div>

<p>Пронумерованный список:</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="p">1.</span> Пункт
<span class="p">1.</span> Еще один пункт
<span class="p">  1.</span> Подпункт
<span class="p">  1.</span> Еще один подпункт
</code></pre></div></div>

<p>В пронумерованном списке можно использовать любые числа — это не важно. При конвертации в HTML или другой формат числа станут правильными и последовательными (1, 2, 3 и т.д.).</p>

<h2 id="дополнительно-про-markdown">Дополнительно про Markdown</h2>

<ol>
  <li><a href="https://en.wikipedia.org/wiki/Markdown">Markdown в Википедии</a></li>
  <li><a href="https://commonmark.org/help/tutorial/">10-минутный интерактивный туториал</a></li>
</ol>

<hr />

<p><em>Рахим Давлеткалиев</em></p>

              ]]>
            </turbo:content>
        </item>
        
        <item turbo="true">
            <turbo:extendedHtml>true</turbo:extendedHtml>
            <link>https://guides.hexlet.io/ru/bootstrap/</link>
            <!-- <turbo:source></turbo:source> -->
            <!-- <turbo:topic>Bootstrap простыми словами: что это, для чего нужен, как работает фреймворк
</turbo:topic> -->
            <title>Bootstrap простыми словами: что это, для чего нужен, как работает фреймворк
</title>
            <pubDate>Mon, 10 Jul 2017 00:00:00 +0000</pubDate>
            <author>Никита Михайлов</author>
            <!-- <yandex:related></yandex:related> -->
            <turbo:content>
              <![CDATA[
                <div data-block="breadcrumblist">
                  <a href="https://guides.hexlet.io/">Hexlet Guides</a>
                  <a href="https://guides.hexlet.io/ru/bootstrap/">Bootstrap простыми словами: что это, для чего нужен, как работает фреймворк
</a>
                </div>
                <button
                  formaction="https://guides.hexlet.io/ru/bootstrap/"
                  data-background-color="#eee"
                  data-color="dark"
                  data-turbo="false"
                  data-primary="false"
                >
                  Читать полную версию на сайте
                </button>
                <p>Разработка веб-страницы с точки зрения верстальщика — непрерывный процесс доработки и создания новых блоков. Чем больше проект, тем чаще происходит итерация «идея — функционал — вёрстка». Решая задачи бизнеса, стадии должны решаться быстро и качественно. И если качество вёрстки напрямую зависит от верстальщика, то скорость — фактор, который зависит от команды.</p>

<div class="fs-3 border-start p-4 mb-3 bg-light border-info border-3 banner">
    <a href="https://ru.hexlet.io/programs/layout-designer?utm_source=hexlet-guides&amp;utm_medium=referral" target="_blank">Профессия «Верстальщик» на Хекслете
</a>
</div>

<p>Для решения проблемы скорости разработчики постоянно придумывают новые инструменты. В среде верстальщиков таким инструментом стали CSS-фреймворки — набор готовых блоков, классов и внутренних функций, которые обеспечивают быструю и удобную разработку.</p>

<p>В 2010 году в недрах компании Twitter появился проект Twitter Blueprint. Его задачей было создание системы для разработки новых компонентов внутри компании. Twitter Blueprint имел набор базовых блоков с готовым дизайном, который использовался в компании. Это решение обрело популярность внутри компании благодаря своей простоте, так как любой сотрудник, имея минимальный опыт разработки, мог сделать новый концепт блока и предложить его для дальнейшей разработки.</p>

<p>В этом же году на Twitter Hack Week проект обрёл первую популярность. Его заметили не только внутри компании, но и за её пределами. Такое решение не могло оставаться внутренней разработкой и уже в 2011 году проект вышел в открытый доступ под названием Bootstrap. С тех пор Bootstrap удерживает лидерство среди инструментов по созданию сайтов. По разным статистикам, фреймворк используют от 17 до 30% всех сайтов в интернете. Код Bootstrap можно найти на сайтах таких проектов, как:</p>

<ul>
  <li>Hexlet,</li>
  <li>GitHub,</li>
  <li>PayPal,</li>
  <li>Spotify,</li>
  <li>Twitter,</li>
  <li>Duolingo.</li>
</ul>

<p>Это далеко не весь список, который можно привести. Таким образом Bootstrap не является библиотекой для создания админок и прототипов, как о нём говорят.</p>

<h2 id="bootstrap-как-набор-готовых-элементов">Bootstrap как набор готовых элементов</h2>

<p>Одной из сторон Bootstrap является то, что его можно использовать исключительно как набор уже готовых элементов. Для это не требуется серьёзных знаний HTML и CSS — достаточно уметь создавать самые простые страницы и прочитать документацию. Например, для создания кнопки используется два класса, один из которых отвечает за структуру кнопки, а другой за оформление. Такой подход называется <strong>OOCSS</strong> — Object Oriented CSS или объектно-ориентированный CSS. Про объектно-ориентированный подход CSS в блоге Hexlet есть <a href="https://ru.hexlet.io/blog/posts/oocss-basics">отдельная статья</a>.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nt">&lt;button</span> <span class="na">class=</span><span class="s">"btn btn-primary"</span><span class="nt">&gt;</span>Я — синяя кнопка<span class="nt">&lt;/button&gt;</span>
</code></pre></div></div>

<p>Второй подход, который используется в Bootstrap — Atomic CSS. На нём построены утилиты во фреймворке. <strong>Atomic CSS</strong> — подход, при котором один класс использует одно свойство.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nt">&lt;section</span> <span class="na">class=</span><span class="s">"d-flex bg-white"</span><span class="nt">&gt;</span>
  <span class="c">&lt;!-- HTML вёрстка --&gt;</span>
<span class="nt">&lt;/section&gt;</span>
</code></pre></div></div>

<p>В этом примере тег <code class="language-plaintext highlighter-rouge">&lt;section&gt;</code> получит два свойства:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">background-color: #fff;</code></li>
  <li><code class="language-plaintext highlighter-rouge">display: flex;</code>.</li>
</ol>

<p>Использование утилит предполагает более углублённые знания в CSS, так как это будет похоже на использование правил. Только вместо записи в CSS-файле используются классы.</p>

<p>Компоненты и утилиты позволяют очень быстро создать проект различной сложности. Единственное, в чём вы будете ограничены — выбор дизайна. Если не заниматься переписыванием компонентов, то страница будет выглядеть в точности, как в документации. Это не минус, так как Bootstrap современный фреймворк и его дизайн не пугает при первом взгляде. Многие небольшие компании используют такой подход.</p>

<h3 id="плюсы-использования-bootstrap-как-набора-готовых-элементов">Плюсы использования Bootstrap, как набора готовых элементов</h3>

<h4 id="скорость">Скорость</h4>

<p>Процесс разработки сопровождается непрерывной работой по добавлению или удалению функционала на странице. Чем крупнее проект, тем чаще происходят эти процессы и скорость реализации не в последнюю очередь зависит от того, как скоро функционал «обрастёт» внешним видом. Используя готовые компоненты и утилиты Bootstrap можно быстро ввести новый функционал на сайт и дать его пользователям. Таким образом это решает одну из проблем цикла «идея — функционал — вёрстка».</p>

<h4 id="кроссбраузерность">Кроссбраузерность</h4>

<p>В веб пространстве множество различных браузеров: Chrome, Firefox, Edge, Opera, Safari и т.д. Они предоставляют пользователям комфортный веб-сёрфинг. Но каждый из этих браузеров может обрабатывать HTML и CSS немного по своему, из-за чего верстальщикам необходимо приводить стандартные элементы к единому виду. Такая задача требует скрупулёзного подхода и знание  частых проблем и отличий браузеров между собой. Компоненты Bootstrap учитывают различия браузеров и оптимизированы таким образом, чтобы минимизировать различия между ними.</p>

<h4 id="адаптивность">Адаптивность</h4>

<p>Bootstrap имеет готовую 12-колоночную сетку, по которой можно располагать компоненты. Сетка является самым популярным компонентом бутстрап и её используют даже те, кто скептически относится к фреймворку. Сетка использует подход, при котором возможно сразу настроить адаптивность. Используя готовые компоненты можно быть уверенным в том, что они будут хорошо отображаться на разных устройствах.</p>

<h4 id="доступность">Доступность</h4>

<p>Разработчики уделяют внимание на использование страниц с компонентами людьми с ограниченными возможностями. Документация описывает ситуации, как сделать компонент доступным. Но и без этого компоненты имеют базовую доступность. Один из самых полезных классов, связанный с доступностью — <code class="language-plaintext highlighter-rouge">.sr-only</code>. Он позволяет скрыть элемент для всех устройств, кроме скринридера. Это важно для правильной организации вёрстки форм на сайте.</p>

<h4 id="низкий-порог-вхождения">Низкий порог вхождения</h4>

<p>Создание страницы по компонентам не требует экспертного знания HTML и CSS. Это позволяет создавать новые блоки не только верстальщику, но и любому работнику компании, который знает базовые основы вёрстки. Таким образом разработчики могут оснастить новое решение готовой вёрсткой с использованием фреймворка. Bootstrap также может пригодиться небольшим компаниям, которые не готовы потратить большие деньги на разработку веб-сайта. В качестве промежуточного решения Bootstrap будет незаменим. В последствии возможно и остановиться на нём, как мы и сделали на Хекслете.</p>

<h3 id="минусы-использования-bootstrap-как-набора-готовых-элементов">Минусы использования Bootstrap, как набора готовых элементов</h3>

<h4 id="вес-проекта">Вес проекта</h4>

<p>Фреймворк Bootstrap даёт не только набор классов, но и интерактивные компоненты. Для их работы используется несколько JavaScript библиотек, которые увеличивают вес подключаемых файлов на странице. В Bootstrap 4 вместе со библиотеками JavaScript весит ~ 300кб. Это может стать критичной точкой при разработке мобильных приложений, ориентированных на использование при слабом интернет соединении. В качестве таких приложений могут быть материалы для оказания экстренной помощи, вызова спасательных служб и так далее.</p>

<h4 id="дизайн">Дизайн</h4>

<p>Стандартные компоненты накладывают ограничения на дизайн. Эти рамки выражены в том, что компоненты возможно расширять только вглубь, вставляя одни компоненты внутрь других. Модификация компонентов потребует знаний в вёрстке, так как даже незначительные изменения необходимо проверить в браузерах и на разных разрешениях. При этом дизайн стандартных компонентов Bootstrap лаконичен и является примером для дизайнера. При своей простоте они функциональны и помогают правильно подать информацию. Даже в таких ограничениях создаются красивые и удобные сайты засчёт грамотной работы с UI.</p>

<h4 id="функционал">Функционал</h4>

<p>Как и в случае с дизайном, функционал блоков определён заранее и изменение приводит к существенным доработкам. Это касается и интерактивных элементов, которые используют JavaScript код. Разработчики для таких элементов внесли классы, которые помогают немного изменить поведение, но этого не всегда бывает достаточно.</p>

<h2 id="bootstrap-как-фреймворк">Bootstrap как фреймворк</h2>

<p>Помимо средств разработки, таких как набор компонентов и утилит, Bootstrap предлагает широкие возможности по созданию пользовательских компонентов. Это достигается засчёт большой кодовой базы в исходниках.</p>

<p>Что же такое фреймворк? Можно представить это как каркас будущего приложения. Своеобразным фундаментом, на котором мы возведём стены, установим окна и заставим мебелью. Таким фундаментом и является Bootstrap. В нём находится десятки функций и миксинов, которые позволят верстальщику создать свою собственную дизайн-систему. Этот функционал является самым недооценённым среди разработчиков и по этой причине о Bootstrap сформировалось неправильное мнение.</p>

<p>Представьте себе новый компонент, который разработчик добавляет на страницу. Используя бутстрап, зачастую разработка ведётся следующим образом:</p>

<ul>
  <li>Подбираются похожие компоненты из документации.</li>
  <li>Подбираются новые классы для создания новых стилей.</li>
  <li>В дополнительном CSS файле перезаписываются и добавляются новые стили для блока.</li>
</ul>

<p>При таком подходе, даже получив необходимые блоки, разработчик решит только ближайшую задачу, но может испытать трудности на дистанции. Все они связаны с отсутствием взаимодействия между компонентом и фреймворком:</p>

<ul>
  <li>Обновление кодовой базы Bootstrap никак не повлияет на поведение компонента. Разработчики постоянно обновляют версии, внося множество улучшений и исправляя ошибки.</li>
  <li>Изменение настроек не повлияет на компонент. Распространённая ситуация — смена цветовой схемы. Возникает необходимость править цвета у каждого пользовательского компонента вручную.</li>
  <li>Генерация новых утилит превращается в дублирование кода, без создания системы. Таким образом могут создавать новые утилиты для цвета фона и текста.</li>
</ul>

<p>Создание утилит, начиная с Bootstrap 5, решается добавлением нового массива, который передаётся в обработчик, отдавая на выходе новые классы. А как создаётся новый компонент? В большинстве случаев достаточно внимательно пройтись по файлу <em>_variables.scss</em></p>

<p>Что там можно обнаружить? Например, цвета, которые используются в качестве цветовой схемы:</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nv">$blue</span><span class="p">:</span>     <span class="mh">#0d6efd</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$green</span><span class="p">:</span>    <span class="mh">#198754</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$cyan</span><span class="p">:</span>     <span class="mh">#0dcaf0</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$yellow</span><span class="p">:</span>   <span class="mh">#ffc107</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$red</span><span class="p">:</span>      <span class="mh">#dc3545</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$gray-100</span><span class="p">:</span> <span class="mh">#f8f9fa</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$gray-600</span><span class="p">:</span> <span class="mh">#6c757d</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$gray-900</span><span class="p">:</span> <span class="mh">#212529</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>

<span class="nv">$primary</span><span class="p">:</span>       <span class="nv">$blue</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$secondary</span><span class="p">:</span>     <span class="nv">$gray-600</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$success</span><span class="p">:</span>       <span class="nv">$green</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$info</span><span class="p">:</span>          <span class="nv">$cyan</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$warning</span><span class="p">:</span>       <span class="nv">$yellow</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$danger</span><span class="p">:</span>        <span class="nv">$red</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$light</span><span class="p">:</span>         <span class="nv">$gray-100</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
<span class="nv">$dark</span><span class="p">:</span>          <span class="nv">$gray-900</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>

<span class="nv">$theme-colors</span><span class="p">:</span> <span class="p">(</span>
  <span class="s2">"primary"</span><span class="o">:</span>    <span class="nv">$primary</span><span class="o">,</span>
  <span class="s2">"secondary"</span><span class="o">:</span>  <span class="nv">$secondary</span><span class="o">,</span>
  <span class="s2">"success"</span><span class="o">:</span>    <span class="nv">$success</span><span class="o">,</span>
  <span class="s2">"info"</span><span class="o">:</span>       <span class="nv">$info</span><span class="o">,</span>
  <span class="s2">"warning"</span><span class="o">:</span>    <span class="nv">$warning</span><span class="o">,</span>
  <span class="s2">"danger"</span><span class="o">:</span>     <span class="nv">$danger</span><span class="o">,</span>
  <span class="s2">"light"</span><span class="o">:</span>      <span class="nv">$light</span><span class="o">,</span>
  <span class="s2">"dark"</span><span class="o">:</span>       <span class="nv">$dark</span>
<span class="p">)</span> <span class="o">!</span><span class="nb">default</span><span class="p">;</span>
</code></pre></div></div>

<p>Цветов в файле <em>_variables.scss</em> намного больше, но именно эти формируют базовую цветовую схему проекта. Вы можете добавить новые цвета, определить их в качестве базовых и после компиляции все компоненты и утилиты получат новые значения. Именно такое поведение отличает фреймворк от простого набора готовых компонентов.</p>

<p>Именно такая работа с Bootstrap позволит создать нечто большее, чем просто прототип, лендинг или панель администратора. На Hexlet, в качестве третьего проекта по вёрстке Bootstrap используется для создания внешнего вида полноценного чата</p>

<p><img src="/assets/images/bootstrap/bootstrap-chat.jpg" alt="Приложение на Bootstrap" /></p>

<p>Так как Bootstrap является набором функций и миксинов, то это снимает преграды его использования вместе с другими методологиями. Например, c БЭМ. Это распространённое мнение, что использовать бутстрап вместе с БЭМ невозможно. Взгляните на следующие миксины, которые доступны для создания сетки:</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="k">@mixin</span> <span class="nf">make-container</span><span class="p">();</span>
<span class="k">@mixin</span> <span class="nf">make-row</span><span class="p">();</span>
<span class="k">@mixin</span> <span class="nf">make-col</span><span class="p">();</span>
</code></pre></div></div>

<p>Если вы уже работали с Bootstrap, то в этих названиях найдёте привычную схему «Контейнер → строка → колонка». Используя эти миксины можно добавить логику фреймворка в абсолютно любой проект и не привязываться к именованию.</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="syntax"><code><span class="nc">.search-form</span> <span class="p">{</span>
  <span class="k">@include</span> <span class="nd">make-container</span><span class="p">();</span>

  <span class="k">&amp;</span><span class="nt">__content</span> <span class="p">{</span>
    <span class="k">@include</span> <span class="nd">make-row</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">&amp;</span><span class="nt">__input</span><span class="o">,</span>
  <span class="k">&amp;</span><span class="nt">__button</span> <span class="p">{</span>
    <span class="k">@include</span> <span class="nd">make-col-auto</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Таким образом можно добавлять не только элементы сетки, но и доступные компоненты и утилиты. При этом после компиляции не будет необходимости нести за собой множество кода, который не используется.</p>

<h2 id="выводы">Выводы</h2>

<p>Изучение Bootstrap может сильно развить вас как разработчика. Ведь кроме написания кода, можно изучать и чужой, который создан и поддерживается тысячами людей по всему миру. В коде можно найти интересные решения, грамотное структурирование и множество полезных функций. Благодаря этому Bootstrap можно использовать во множестве сценариев: от создания прототипов, до вёрстки сложных макетов, а возможность использование отдельных частей позволяет добавить частичку Bootstrap в проект без необходимости переделывания структуры.</p>

<h2 id="дополнительные-ссылки">Дополнительные ссылки</h2>

<ul>
  <li><a href="https://getbootstrap.com/docs/5.0/getting-started/introduction/">Документация Bootstrap</a></li>
  <li><a href="https://github.com/twbs/bootstrap">Репозиторий Bootstrap</a></li>
  <li><a href="https://ru.hexlet.io/courses/bootstrap_basic">Bootstrap 5: Основы верстки</a></li>
</ul>

              ]]>
            </turbo:content>
        </item>
        
    </channel>
</rss>
