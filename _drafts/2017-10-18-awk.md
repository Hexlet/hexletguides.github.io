---
layout: post
title: Что такое awk
subtitle: Подзаголовок (выводится на странице поста)
summary: Эффективная работа в консоли
cover_url: "/images/vscode_eslint.png"
---

***awk* - один ключевых инструментов работы в консоли, наряду с *sed*, *grep*, *cat*, *less* и другими. По сути, это очень гибкий язык программирования для работы над текстовыми данными, позволяющий, в том числе, писать быстрые однострочники.**

Если достаточно хорошо изучить простейший синтаксис *awk*-команд, “держать команды на пальцах“, можно за секунды решать большое количество рутинных, повседневных задач. *awk* можно рассматривать как интерпретатор си-подобного языка, с очень похожим синтаксисом для арифметических операций. 

Он имеет встроенные возможности для манипулирования строками и имеет удобный инструмент - ассоциативные массивы. *awk* работает построчно, т.е. он прогоняет всю свою программу для каждой строчки данных, поступающей на вход. Язык не многословный, установлен на всех Unix-системах, работает быстро.

### Основы синтаксиса

#### Выполнение awk-скрипта

Есть несколько вариантов запуска *awk* скрипта:

* `awk -f script.awk data.in` — Запуск скрипта awk, код описан в файле `script.awk`. Данные берутся из файла `data.in`
* `awk '<AWK CODE>' data.in` — Аналогично, данные берутся из файла `data.in`, однако код записан прямо в командной строке (полезно для небольших скриптов). Далее следуют вариации предыдущих вариантов, в качестве данных выступает `stdout` из предыдущей команды
* `cmd | awk -f script.awk`
* `cmd | awk '<AWK CODE>'`

### Структура программы

#### Теория

Программы на awk всегда описываются по шаблону `pattern { action }`

`pattern` - это тест, который проверяет, когда выполнять действие, описанное в блоке `{ action }`. В качестве теста могут выступать следующие конструкции:

* Тест может просто отсутствовать, тогда считается, что он вернул true
* Зарезервированное слово

        BEGIN
        END
* Условие, возвращающее boolean

        (NR == 15)
        ($1 == “asdf”)
        1                   # всегда true
* Регулярное выражение, которое проверяется на всей входящей строке

        /^something/
        /,\s*some_field.*AAA/
* Триггер для включение и выключения

        pattern1,pattern2

При выполнении условия `pattern1` триггер переводится в true, и находится в этом состоянии, пока какая-то следующая строка не приведет к выполнению условия `pattern2`, тогда он переводится в false. В качестве `pattern1`, `pattern2` могут выступать как регулярные выражения, так и просто условия, возвращающие boolean. Блоков может быть несколько, в этом случае они могут располагаться в разных строчках:

        pattern1 {action1}
        pattern2 {action2}

А могут и в одной строке:

        pattern1{action1} pattern2{action2}
        pattern1{action1};pattern2{action2}

#### Примеры

Для примера рассмотрим следующий скрипт `script1.awk`:

        BEGIN  { print “START” }            # BEGIN - сработает до чтения первой строчки
        /asdf/ { print “line with asdf”  }  # сработает, если в строке встретится “asdf”
        /1234/ { print “line with 1234”  }  # сработает, если в строке встретится “1234"
               { print “all lines”  }       # будет срабатывать на каждой строчке
        END    { print “STOP”  }            # END сработает после чтения последней строчки

Данная программа выполняется следующим образом. Для каждой строчки, поданной на вход, прогоняются все тесты. И для тех тестов, которые вернули `true`, выполняется действие напротив этого блока.
Давайте прогоним эту программу на следующих данных (файл `data1.in`):

        String 1 with some headers
        String 2 with text “hello”
        String 3 with text “asdf”
        String 4 with some footers

Запуск:

        cat data1.in | awk -f script1.awk

Или, что равнозначно:

        awk -f script1.awk data1.in

Выдача:

        START               <- напечатано до начала данных правилом `BEGIN`
        all lines           <- напечатано для ‘String 1’ пустым правилом
        all lines           <- напечатано для ‘String 2’ пустым правилом
        line with asdf      <- напечатано для ‘String 2’ правилом `/asdf/`
        all lines           <- напечатано для ‘String 3’ пустым правилом
        all lines           <- напечатано для ‘String 4’ пустым правилом
        STOP                <- напечатано после всех данных правилом `END`

### Базовый синтаксис и семантика

#### Теория

Как уже упоминалось, awk - это си-подобный язык. В отличие от си точка с запятой может опускаться в конце строки. Еще одно отличие от си - в awk нет типов, точнее, там только один тип, который, в зависимости от контекста, воспринимается как строка или как число. Преобразование между ними всегда делается неявно:

        echo “” | awk ‘{print “123" + “2”}’     # вернется 125
        echo “” | awk ‘{print “123X” + “2"}’    # вернется 125, символ ‘X’ отбросится
        echo “” | awk ‘{print “12X3X” + “2”}’   # вернется 14, строка “X3X” отбросилась

Далее простейшие понятные элементы:

* Арифметика очень похожа на язык си: `+`, `-`, `*`, `/`, `%` (взятие по модулю), `++`, `--`, `+=`, `-=`, `*=`, `/=`, `%=`

        x = 1 + 2*3 % 4
        x += 3

* Условные выражения, возвращающие boolean для условий: `==`, `!=`, `>`, `>=`, `<`, `<=`

        x == 3
        x <= y*4

* Проверка регулярных выражений: `~` - регулярное выражение соответствует поданной строке

        `!~` - не соответствует
        str1 !~ /Hello world/       # строка str1 не содержит “Hello world”
        str2 ~ /(one|two|three)/    # строка str2 содержит “one” или “two” или “three”

* Операции над boolean: `&&`, `||`

Наконец, основные команды *awk* с некоторыми пояснениями:

* `string1 string2`

    Две строковые переменные записанные через пробел конкатенируются.

        x = “Hello ” “world!”

    Аналогично, конкатенируются два числа, и число и строка:

        y = “Hello, ” name
        z = “You are ” age ” years old”

* `variable=expression`
    
    Присвоение значения переменной

* `print [ expression-list ] [ > expression ]`

    Печать выражения (выражений). Если указано перенаправление - то в указанный файл.
    Перенос строки `\n` всегда подставляется в конце выражения

* `printf format [ , expression-list ] [ > expression ]`

    Оператор очень похож на аналогичный в языке си. Печать выражений с определением формата. Добавление `\n` не происходит. При этом, из-за того, что все числа преобразовываются в строки, можно работать и без строчки, определяющей формат. Следующие две программы выдают одинаковый результат:

        awk ‘{printf NF “\n”}’
        awk ‘{print NF}’

    Стандартный пример из си:

        awk -F, ‘{printf “%8.3f\n”, (2/NF)}’

* `if ( conditional ) statement [ else statement ]`
* `while ( conditional ) statement`
* `for ( expression ; conditional ; expression ) statement`
* `for ( variable in array ) statement`
* `break`
* `continue`
* `{ [ statement ] ...}`
* `next `
* `exit`

### Примеры:

Имея блоки `BEGIN` и `END`, а также учитывая, что программа выполняется для каждой строки входных данных,можно написать простой скрипт, подсчитывающий количество строк в файле

        cat /etc/passwd | awk ‘BEGIN{lines=0} {lines++} END{print “В файле ” lines ” строк“}’

Конечно, лучше всего использовать короткие переменные, тогда программа получится короче.

        awk ‘BEGIN{l=0} {l++} END{print l}’ /etc/passwd

Кстати, можно не инициализировать переменные нулем в `BEGIN`, awk может это делать за вас. В больших программах рекомендуют все-таки проводить инициализацию, это признак хорошего вкуса. В однострочника же, наоборот, чем меньше напечатаешь, тем быстрее получишь результат.

        awk ‘{l++} END{print l}’ /etc/passwd

Кстати, последняя команда, подсчитывающая строки, может быть записана и короче, с помощью встроенной переменной `NR` (см. ниже):

        awk ‘END{print NR}’

Или с помощью утилиты `wc`:

        cat /etc/passwd | wc -l

---

Используя регулярные выражения, можно подсчитать, сколько пользователей в системе используют `/bin/bash` в качестве основного SHELL. Конечно, необходимо знать [формат файла /etc/passwd](https://ru.wikipedia.org/wiki//etc/passwd).

        awk ‘BEGIN{b=0} /bash\s*$/{b++} END{print b}’ /etc/passwd

Здесь мы использовали знание, что SHELL записывается в самом конце, и после него до конца строки (`$`) может идти произвольное количество пробельных символов, табов и т.п. (`\s*`). Кстати, эта команда равносильна следующей:

        cat /etc/passwd | grep -e “bash\s*$” | wc -l

---

Подсчет пустых строк реализуется точно так же

        awk ‘/^\s*$/{b++} END{print b}’ /etc/passwd

Если выполнить эту команду, скорее всего, она напечатает пустую строчку. Т.к. ни одной пустой строки не было найдено, ни разу оператор `b++` не выполнился, и строка `b` инициализировалась пустой строкой во момент использования. Если вам всегда нужно число на выходе, нужно всегда проводить инициализацию:

        awk ‘BEGIN{b=0} /^\s*$/{b++} END{print b}’ /etc/passwd

---

Напечатать все, переводя значения всех полей в абсолютные значения:

        awk ‘{for (i=1; i<=NF; i++) if ($i < 0) $i = -$i; print }’

## Встроенные переменные *awk*

### Теория

*awk* очень хорошо подходит для случаев, когда входные данные представляют из себя некоторую таблицу, с колонками данных, тогда каждая строка - это некоторая запись в этой таблице, разделенная определенным символом. В этом случае встроенные в язык возможности позволяют обращаться напрямую к произвольному полю записи. Например, следующий скрипт напечатает все имена пользователей в системе:

        awk ‘BEGIN{FS=“:”} {print $1}’ /etc/passwd

`FS` - это встроенная переменная, которая хранит разделитель между полями, по умолчанию это пробел. Мы можем переопределить переменную _до_ того, как нам начнут поступать данные. И в дальнейшем ссылаться на первое поле в этих данных Аналогично, ее можно переопределить с помощью опции:

        awk -F: ‘{print $1}’ /etc/passwd

`$1` - функция, которая получает первое поле из строки. Аналогично можно получать второе, третье и т.д. Если копнуть чуть глубже, то знак доллара `$` - это триггер, который из следующего за ним операнда получает число, и потом вытаскивает поле, порядковый номер которого совпадает с числом из операнда. Т.е. данные программы эквивалентны:

        ‘{print $1}’
        ‘{X=1; print $X}’

`$0` -  используется чтобы получить всю строку. Является аргументом по умолчанию для некоторых функций, например print. Следующие программы идентичны:

        ‘{print $0}’
        ‘{print}’
        ‘1;’           # pattern всегда true, используется действие по умолчанию - “print 0”

**Список часто используемых встроенных переменных**:

* `FS` - “Field separator”, мы его уже обсудили
* `OFS`  - “Output field separator”.
    Имеет очень похожее на `FS` назначение, только не для входных, а для выходных значений.
    Применяется как разделитель, когда печатается несколько полей:
        cat /etc/passwd | awk -F: ‘{print $2, $7}’ # печать имени пользователя, и используемого SHELL
    Здесь по умолчанию будет печать в формате `<username> <shell>`.
    Если хочется, чтобы было через двоеточие, следует использовать переменную `OFS`
        cat /etc/passwd | awk -F: ‘BEGIN{OFS=“:”} {print $2, $7}’
* `NF` - “Number of fields”
    Переменная содержит информацию, сколько всего переменных в данной строке.
    Может быть использована для получения последнего поля в строке:
        ‘{print $NF}’
    Или предпоследнего:
        ‘{print $(NF-1)}’
* `NR` - “Number of records”.
    Содержит информацию о номере данной строки в общем потоке данных.
    Например, вот так можно напечатать первые 5 строк файла passwd
        awk -F: ‘{if(NR <= 5) print $0}’ /etc/passwd
    Кстати, это проще сделать с помощью команды `head`:
        head -5 /etc/passwd
* `ORS` - “Output record separator”.
    Переменная, используемая для разделения исходящих строк. По умолчанию, это перевод строки.
    Программа выводит все имена пользователей в одну строку:
        awk -F: ‘BEGIN{ORS=” “}{print $1} END{printf”\n”}’ /etc/passwd

### Примеры:

Продолжим разбирать `passwd`. Скажем, мы хотим напечатать домашний каталог пользователя ‘john’.
Это можно сделать разными способами

        awk -F: ‘{if ($1 == “john”) print $6}’ /etc/passwd

Здесь мы сравнение имени пользователя поставили в блок, и выполняем этот блок для каждой строки.
Можно сделать по другому, можно выполнять блок только если условие прошло:

        awk -F: ‘$1 == “john” {print $6}’ /etc/passwd

А можно видоизменить проверку условия, используя регулярное выражение:

        awk -F: ‘/^john:/ {print $6}’ /etc/passwd

---

Скажем, у нас есть файл, в котором записаны расходы в формате “<Имя>,<Дата>,<Сумма>“.
При этом может быть несколько строчек с одним именем и датой. Скажем, у нас есть файл data2.in:

        Fred,15.07.2014,12300
        Fred,15.07.2014,1500
        John,15.07.2014,3200
        Fred,16.07.2014,300
        Sam,16.07.2014,28500

Надо посчитать общее количество потраченных денег, сколько потратил Fred всего, и сколько было потрачено всеми 16 июля. Можно написать три разных команды для этого:

        awk -F, ‘BEGIN{fred=0} $1==“Fred”{fred+=$3} END{print fred}’ data2.in
        awk -F, ‘BEGIN{sum=0} {sum+=$3} END{print sum}’ data2.in
        awk -F, ‘BEGIN{jul16=0} $2==“16.07.2014" {jul16+=$3} END{print jul16}’ data2.in

А можно все сделать и внутри одной команды:

        awk -F, ‘BEGIN{fred=0; sum=0; jul16=0} {sum+=$3} $1==“Fred”{fred+=$3} $2==“16.07.2014" {jul16+=$3} END{print fred, sum, jul16}’ data2.in

Можно также упростить скрипты, удалив полностью блок BEGIN, и с неинициализированностью переменных бороться с помощью функции `int` (см. ниже)

        awk -F, ‘$1==“Fred”{fred+=$3} END{print int(fred)}’ data2.in
        awk -F, ‘{sum+=$3} END{print int(sum)}’ data2.in
        awk -F, ‘$2==“16.07.2014" {jul16+=$3} END{print int(jul16)}’ data2.in

Или

        awk -F, ‘{sum+=$3} $1==“Fred”{fred+=$3} $2==“16.07.2014" {jul16+=$3} END{print int(fred), int(sum), int(jul16)}’ data2.in

---

Напечатать все строки, но удалить дубликаты (предполагается, что дубликаты идут подряд). Строка целиком содержится в $0. Для проверки на дубль, надо сравнивать $0 с ее предыдущим значением

        awk ‘{if ($0 != prev) print; prev=$0}’

Проверку условия можно вынести в pattern. При этом сохранение старого значения можно перенести в другой блок

        awk ‘$0 != prev {print} {prev=$0}’

Блок, содержащий только печать ‘print’ можно опускать (action по умолчанию). И чтобы подчеркнуть, что это два разных шаблона, разделяем точкой с запятой эти два блока

        awk ‘$0 != prev;{prev=$0}’

### Встроенные переменные *awk*
#### Теория

*awk* имеет некоторый набор встроенных функций, которые еще более увеличивают мощь языка.
В зависимости от версии *awk* (NAWK, GAWK, AWK) список этих функций может отличаться, смотрите документацию на свою версию. Наибольшим количеством возможностей обладает GAWK, он же является наиболее распространенной версией.

**Математические функции**

Они достаточно простые и не нуждаются в объяснениях: `cos`, `exp`, `int` (truncate, convert to int), `log`, `sin`, `sqrt`, `atan2`, `rand`, `srand` (random with seed)

**Строковые функции**

Перечислим только основные, они достаточно простые, чтобы не погружаться в детали:

    * index(string,search)
    * length(string)
    * split(string,array,separator)
    * substr(string,position)
    * substr(string,position,max)
    * sub(regex,replacement)
    * sub(regex,replacement,string)
    * tolower(string)
    * toupper(string)

#### Примеры
* Напечатать все строки, длиной более 80 символов
        awk ‘length($0) > 80’
*  Перевести строку, начинающуюся на “UP” в верхний регистр
        awk ‘/^UP/{print toupper($0)}’

### Примеры комбинаций с другими утилитами
Свою исключительную силу awk показывает в консоли при объединенной работе с другими утилитами, такими как `find`, `grep`, `sort`, `sed`, и т.д.

*Посчитать рекурсивно общий объем ‘*.c’ файлов текущего каталога*. Все подобные задачи нужно решать, разбивая их на этапы.

* Сперва надо понять, как найти все файлы ‘*.c’. Обычно задачи поиска решаются с помощью `find`

        find . -name “*.c”
* Далее, надо как-то получить их размер. Это можно сделать с помощью еще одной утилиты `xargs`:
        find . -name “*.c” | xargs ls -l
    Либо с помощью встроенной в `find` функциональностью:
        find . -name “*.c” -ls
    Воспользуемся второй возможностью. При этом возвращаемый формат будет примерно следующий:
        521721    4 -rw-r--r--   1 gli      gli     871 Nov 13  2013 ./src/lambda.c
    Размер файла в байтах здесь - это “871”, т.е. седьмое поле в строке
* Далее, нужно суммировать все размеры файлов
        find . -name “*.c” -ls | awk ‘{s += $7} END{print s}’
Чаще всего, большинство задач можно решить более, чем одним способом. Так и здесь, эта же задача может быть решена так:
        find . -name “*.c” | xargs wc -c | tail -1

---

*Иван Глушков*
